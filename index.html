<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZaapFlow - Construtor de Funil</title>
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Biblioteca para criar arquivos ZIP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <style>
        :root {
            --bg-main: #111111; --bg-secondary: #1C1C1C; --bg-tertiary: #2A2A2A;
            --text-primary: #EAEAEA; --text-secondary: #A0A0A0; --border-color: #363636;
            --accent-yellow: #FFD23F; --accent-yellow-dark: #F8B700;
            --accent-yellow-glow: rgba(255, 210, 63, 0.5); --shadow-color: rgba(0, 0, 0, 0.5);
        }
        body { font-family: 'Inter', sans-serif; background-color: var(--bg-main); color: var(--text-primary); }
        
        #flow-canvas {
            background-color: var(--bg-main);
            background-image: radial-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 20px 20px;
            cursor: grab;
        }
        #flow-canvas.drag-over { background-color: rgba(255, 210, 63, 0.05); }
        #flow-canvas:active { cursor: grabbing; }
        
        .neon-yellow-text { color: var(--accent-yellow); text-shadow: 0 0 5px var(--accent-yellow-glow), 0 0 10px var(--accent-yellow-glow); }
        .neon-yellow-bar { background-color: var(--accent-yellow); box-shadow: 0 0 8px var(--accent-yellow-glow); }
        
        .draggable {
            display: flex; align-items: center; padding: 0.75rem;
            border-radius: 0.375rem; background-color: var(--bg-tertiary);
            cursor: move; transition: background-color 0.2s;
        }
        .draggable:hover { background-color: #3a3a3a; }
        .draggable i { width: 2rem; text-align: center; }
        .draggable span { margin-left: 0.75rem; font-size: 0.875rem; font-weight: 500; }
        
        .canvas-component {
            position: absolute; cursor: grab; z-index: 100 !important; width: 280px;
            background-color: var(--bg-secondary); border: 1px solid var(--border-color);
            border-radius: 8px; box-shadow: 0 10px 20px var(--shadow-color);
            transition: box-shadow 0.2s ease;
        }
        .canvas-component:hover {
            box-shadow: 0 10px 25px var(--shadow-color), 0 0 10px var(--accent-yellow-glow);
        }
        .component-header {
            background-color: var(--bg-tertiary); border-top-left-radius: 7px;
            border-top-right-radius: 7px; border-bottom: 1px solid var(--border-color);
        }
        .component-header .accent-bar { height: 3px; width: 100%; border-top-left-radius: 7px; border-top-right-radius: 7px; }

        .connector-point {
            position: absolute; top: 50%; width: 16px; height: 16px;
            background-color: var(--bg-tertiary); border: 2px solid var(--text-secondary);
            border-radius: 50%; cursor: crosshair; z-index: 11; transition: all 0.2s ease;
        }
        .connector-point:hover { border-color: var(--accent-yellow); transform: translateY(-50%) scale(1.2); }
        .connector-point.input { left: -8px; transform: translateY(-50%); }
        .connector-point.output { right: -8px; transform: translateY(-50%); }
        .multi-output-container .connector-point.output { position: relative; right: 0; top: 0; transform: none; }

        /* Sistema de conexões SVG customizado */
        #connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1 !important;
            overflow: visible;
            clip-path: none;
        }
        
        .connection-line {
            stroke: #fbbf24;
            stroke-width: 3;
            fill: none;
            z-index: 1;
        }

        /* Botão X de desconexão */
        .connection-delete-btn {
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s ease;
            pointer-events: auto;
            z-index: 10;
        }
        
        .connection-delete-btn:hover {
            opacity: 1;
        }
        
        .connection-delete-circle {
            fill: rgba(239, 68, 68, 0.8);
            stroke: white;
            stroke-width: 1;
            pointer-events: auto;
            transition: fill 0.3s ease;
        }
        
        .connection-delete-btn:hover .connection-delete-circle {
            fill: rgba(239, 68, 68, 1);
        }
        
        .connection-delete-text {
            fill: white;
            font-family: Arial, sans-serif;
            font-size: 12px;
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
            user-select: none;
        }

        /* SVG das conexões */
        #connections-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: visible;
            z-index: 1;
        }
        
        /* Permitir eventos nos botões de delete */
        .connection-delete-btn {
            pointer-events: auto !important;
        }
        
        .component-controls { display: none; }
        .canvas-component:hover .component-controls { display: flex; }
        
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.7); z-index: 9999 !important; display: flex;
            justify-content: center; align-items: center;
        }
        .modal-content {
            background-color: var(--bg-secondary); padding: 24px; border-radius: 8px;
            border: 1px solid var(--border-color); width: 90%; max-width: 500px;
            z-index: 10000 !important; position: relative;
        }

        input[type="text"], input[type="password"], input[type="number"], textarea, select {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        /* Estilo para select de formato de vídeo */
        select {
            background-color: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 12px;
            border-radius: 4px;
            outline: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
        }
        
        select:focus {
            border-color: var(--accent-yellow);
            box-shadow: 0 0 0 2px rgba(255, 210, 63, 0.2);
        }
        
        select:hover {
            border-color: var(--accent-yellow);
            background-color: var(--bg-tertiary);
        }
        
        select option {
            background-color: var(--bg-tertiary) !important;
            color: var(--text-primary) !important;
            padding: 8px 12px;
        }
        
        select option:hover {
            background-color: var(--accent-yellow) !important;
            background: var(--accent-yellow) !important;
            color: #111 !important;
        }
        input[type="color"] {
             -webkit-appearance: none; border: none; width: 100%; height: 40px;
             padding: 0; background-color: transparent;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; }
        input[type="color"]::-webkit-color-swatch { border-radius: 6px; border: 1px solid var(--border-color); }

        .btn-action-yellow {
            background-color: var(--accent-yellow); color: #111;
            font-weight: 600; transition: background-color 0.2s ease;
        }
        .btn-action-yellow:hover { background-color: var(--accent-yellow-dark); }
        .btn-action-yellow:disabled { background-color: #a0a0a0; color: #555; cursor: not-allowed; }

        #preview-chat-container {
            background-color: #e5ddd5;
            background-image: url('https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png');
        }
        #preview-chat-body::-webkit-scrollbar { width: 6px; }
        #preview-chat-body::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 3px; }
        
        .audio-player-container {
            align-self: flex-start; max-width: 80%; background-color: #fff;
            padding: 8px; border-radius: 10px; border-top-left-radius: 0;
            box-shadow: 0 1px 1px rgba(0,0,0,0.1); color: #333;
            display: flex; align-items: center; gap: 8px; width: 290px;
        }
        .audio-player-container img { width: 40px; height: 40px; border-radius: 50%; }
        .audio-player-container .play-pause-btn {
            background: none; border: none; font-size: 1.5rem; color: #555; cursor: pointer;
        }
        .audio-player-container .progress-bar-container {
            flex-grow: 1; height: 4px; background-color: #ccc; border-radius: 2px;
            position: relative; cursor: pointer;
        }
        .audio-player-container .progress-bar {
            height: 100%; background-color: #666; border-radius: 2px;
            width: 0; position: relative;
        }
        .audio-player-container .progress-bar::after {
            content: ''; position: absolute; right: -6px; top: -4px;
            width: 12px; height: 12px; border-radius: 50%; background-color: #666;
        }
        .audio-player-container .time-info {
            display: flex; flex-direction: column; align-items: flex-end;
            font-size: 0.7em; color: #999;
        }

        /* Estilos da Tela de Login */
        #login-overlay {
            background: radial-gradient(ellipse at bottom, rgba(255, 210, 63, 0.4) 0%, var(--bg-main) 60%);
        }
        @keyframes shake {
          10%, 90% { transform: translate3d(-1px, 0, 0); }
          20%, 80% { transform: translate3d(2px, 0, 0); }
          30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
          40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .animate-shake {
          animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
        }

        /* Toast Notification */
        #toast-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translate(-50%, 200%);
            background-color: var(--accent-yellow);
            color: var(--bg-main);
            padding: 12px 24px;
            border-radius: 8px;
            font-weight: 600;
            z-index: 100;
            transition: transform 0.5s ease-in-out;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        #toast-notification.show {
            transform: translate(-50%, 0);
        }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">
    
    <!-- Tela de Login -->
    <div id="login-overlay" class="fixed inset-0 z-50 flex items-center justify-center transition-opacity duration-500">
        <div id="login-box" class="w-full max-w-sm p-8 space-y-6 bg-bg-secondary/80 rounded-2xl shadow-2xl shadow-black/50 backdrop-blur-md border border-border-color">
            <div class="flex justify-center items-center gap-3">
                <i class="fa-solid fa-bolt text-4xl neon-yellow-text"></i>
                <h1 class="text-4xl font-bold text-primary">ZaapFlow</h1>
            </div>

            <form id="login-form" class="space-y-6">
                <div>
                    <label for="username" class="text-sm font-semibold text-text-secondary">Usuário</label>
                    <input id="username" name="username" type="text" required class="w-full p-3 mt-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#FFD23F] transition">
                </div>
                <div>
                    <label for="password" class="text-sm font-semibold text-text-secondary">Senha</label>
                    <input id="password" name="password" type="password" required class="w-full p-3 mt-2 rounded-lg focus:outline-none focus:ring-2 focus:ring-[#FFD23F] transition">
                </div>
                <p id="error-message" class="text-red-500 text-sm text-center hidden">Usuário ou senha inválidos.</p>
                <div>
                    <button type="submit" class="w-full py-3 mt-2 font-bold text-black bg-[#FFD23F] rounded-lg hover:bg-[#F8B700] focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-bg-secondary focus:ring-[#FFD23F] transition-all duration-300 shadow-lg shadow-yellow-500/20">
                        Entrar
                    </button>
                </div>
            </form>
        </div>
    </div>

    <!-- Conteúdo Principal da Aplicação -->
    <div id="app-wrapper" class="h-full flex flex-col overflow-hidden hidden">
        <header class="bg-secondary shadow-md px-4 md:px-6 py-3 flex justify-between items-center z-30 border-b border-border-color flex-shrink-0">
            <div class="flex items-center gap-3">
                <i class="fa-solid fa-bolt text-2xl neon-yellow-text"></i>
                <h1 class="text-lg md:text-xl font-bold text-primary">ZaapFlow</h1>
            </div>
            <div class="hidden md:block text-lg font-semibold">Construtor de Funil</div>
            <div class="flex items-center gap-2 flex-wrap">
                <button id="import-btn" class="px-3 py-1.5 rounded-md text-sm flex items-center gap-2 bg-tertiary hover:bg-opacity-70"><i class="fas fa-upload"></i> Importar</button>
                <button id="export-btn" class="px-3 py-1.5 rounded-md text-sm flex items-center gap-2 bg-tertiary hover:bg-opacity-70"><i class="fas fa-download"></i> Exportar</button>
                <button id="copy-html-btn" class="px-3 py-1.5 rounded-md text-sm flex items-center gap-2 bg-tertiary hover:bg-opacity-70"><i class="fas fa-copy"></i> Copiar HTML</button>
                <button id="download-zip-btn" class="px-3 py-1.5 rounded-md text-sm flex items-center gap-2 bg-tertiary hover:bg-opacity-70"><i class="fas fa-file-zipper"></i> Baixar .zip p/ Netlify</button>
                <input type="file" id="import-file-input" class="hidden" accept=".json">
                <button id="logout-btn" class="ml-4 px-3 py-1.5 rounded-md text-sm flex items-center gap-2 bg-red-600 hover:bg-red-700 text-white transition-colors"><i class="fas fa-sign-out-alt"></i> Deslogar</button>
            </div>
        </header>

        <div class="flex-1 flex flex-col lg:flex-row overflow-hidden">
            <!-- Painel Esquerdo: Configurações e Componentes -->
            <aside class="w-full lg:w-72 bg-secondary p-4 overflow-y-auto border-r border-border-color flex-shrink-0">
                <div class="mb-6">
                    <h3 class="font-semibold text-text-secondary mb-3">CONFIGURAÇÕES</h3>
                    <div class="space-y-3">
                        <div>
                            <label for="chat-name-input" class="text-sm text-text-secondary">Nome do Chat</label>
                            <input type="text" id="chat-name-input" value="ZaapFlow" class="w-full mt-1 p-2 rounded-md text-sm">
                        </div>
                        <div>
                            <label for="chat-photo-input" class="text-sm text-text-secondary">URL da Foto de Perfil</label>
                            <input type="text" id="chat-photo-input" value="https://i.ibb.co/fzj6mf9K/Chat-GPT-Image-1-de-jul-de-2025-16-45-48.png" class="w-full mt-1 p-2 rounded-md text-sm">
                        </div>
                        <div>
                            <label for="pixel-id-input" class="text-sm text-text-secondary">ID do Pixel do Facebook</label>
                            <input type="text" id="pixel-id-input" placeholder="Ex: 1234567890123456" class="w-full mt-1 p-2 rounded-md text-sm">
                        </div>
                        <div>
                            <label for="custom-scripts-input" class="text-sm text-text-secondary">Scripts Adicionais (head)</label>
                            <textarea id="custom-scripts-input" placeholder="Cole aqui scripts do UTMfy, Google Analytics, etc." class="w-full mt-1 p-2 rounded-md text-sm" rows="4"></textarea>
                        </div>
                        <button id="save-settings-btn" class="w-full p-2 rounded-md text-sm btn-action-yellow">Salvar Configurações</button>
                    </div>
                </div>
                <hr class="border-border-color my-6">
                <div class="mb-6">
                    <h3 class="font-semibold text-text-secondary mb-3">MENSAGENS</h3>
                    <div class="space-y-2">
                        <div class="draggable" draggable="true" data-component-type="sent-message"><i class="fas fa-paper-plane neon-yellow-text"></i><span>Mensagem Enviada</span></div>
                        <div class="draggable" draggable="true" data-component-type="image-message"><i class="fas fa-image neon-yellow-text"></i><span>Imagem</span></div>
                        <div class="draggable" draggable="true" data-component-type="audio-message"><i class="fas fa-file-audio neon-yellow-text"></i><span>Áudio</span></div>
                        <div class="draggable" draggable="true" data-component-type="video-message"><i class="fab fa-youtube neon-yellow-text"></i><span>Vídeo do YouTube</span></div>
                        <div class="draggable" draggable="true" data-component-type="direct-video-message"><i class="fas fa-video neon-yellow-text"></i><span>Vídeo Direto</span></div>
                    </div>
                </div>
                <div>
                    <h3 class="font-semibold text-text-secondary mb-3">LÓGICA E AÇÕES</h3>
                    <div class="space-y-2">
                         <div class="draggable" draggable="true" data-component-type="ask-question"><i class="fas fa-question-circle neon-yellow-text"></i><span>Pergunta com Botões</span></div>
                         <div class="draggable" draggable="true" data-component-type="user-input"><i class="fas fa-keyboard neon-yellow-text"></i><span>Campo de Resposta</span></div>
                         <div class="draggable" draggable="true" data-component-type="cta-button"><i class="fas fa-mouse-pointer neon-yellow-text"></i><span>Botão (CTA)</span></div>
                         <div class="draggable" draggable="true" data-component-type="delay"><i class="fas fa-clock neon-yellow-text"></i><span>Esperar (Delay)</span></div>
                    </div>
                </div>
                <hr class="border-border-color my-6">
                <div class="mb-6">
                    <h3 class="font-semibold text-text-secondary mb-3">FERRAMENTAS</h3>
                    <div class="space-y-2">
                        <a href="https://catbox.moe" target="_blank" class="w-full p-2 rounded-md text-sm btn-action-yellow text-center flex items-center justify-center gap-2">
                            <i class="fas fa-cloud-upload-alt"></i> Hospedar arquivos
                        </a>
                    </div>
                </div>
            </aside>

            <!-- Área Central: Canvas do Funil -->
            <main class="flex-1 relative border-r border-border-color overflow-hidden">
                <div id="flow-canvas" class="w-full h-full">
                    <div id="flow-transformer" class="w-full h-full" style="transform-origin: 0 0;">
                        <!-- SVG para conexões customizadas -->
                        <svg id="connections-svg" xmlns="http://www.w3.org/2000/svg">
                            <defs>
                                <filter id="glow">
                                    <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                                    <feMerge> 
                                        <feMergeNode in="coloredBlur"/>
                                        <feMergeNode in="SourceGraphic"/>
                                    </feMerge>
                                </filter>
                            </defs>
                        </svg>
                    </div>
                </div>
                <div class="absolute bottom-4 right-4 flex flex-col gap-2 z-20">
                    <button id="zoom-in-btn" class="w-10 h-10 bg-tertiary rounded-md flex items-center justify-center text-lg hover:bg-opacity-80"><i class="fas fa-plus"></i></button>
                    <button id="zoom-out-btn" class="w-10 h-10 bg-tertiary rounded-md flex items-center justify-center text-lg hover:bg-opacity-80"><i class="fas fa-minus"></i></button>
                    <button id="reset-view-btn" class="w-10 h-10 bg-tertiary rounded-md flex items-center justify-center text-lg hover:bg-opacity-80"><i class="fas fa-expand"></i></button>
                </div>
            </main>

            <!-- Painel Direito: Prévia ao Vivo -->
            <aside class="w-full lg:w-1/3 bg-secondary p-4 flex flex-col flex-shrink-0">
                <div class="flex justify-between items-center mb-4 flex-shrink-0">
                       <h2 class="text-lg font-bold text-primary border-b border-transparent pb-2">Prévia ao Vivo</h2>
                       <button id="test-flow-btn" class="px-3 py-1 rounded-md text-sm flex items-center gap-2 btn-action-yellow"><i class="fas fa-play"></i> Testar Fluxo</button>
                </div>
                <div id="preview-container" class="flex-1 bg-main rounded-lg p-2 flex flex-col min-h-0">
                      <div id="preview-chat-container" class="w-full max-w-md mx-auto rounded-xl shadow-inner overflow-hidden flex flex-col flex-1"></div>
                </div>
                <a href="https://www.netlify.com" target="_blank" class="mt-4 w-full text-center px-4 py-2 rounded-md text-white font-semibold bg-blue-600 hover:bg-blue-700 transition-colors">
                    <i class="fas fa-rocket mr-2"></i>Publicar Funil
                </a>
            </aside>
        </div>
    </div>

    <!-- Modal de Edição -->
    <div id="edit-modal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h3 id="modal-title" class="text-lg font-bold mb-4">Editar Componente</h3>
            <div id="modal-body"></div>
            <div class="flex justify-end gap-3 mt-6">
                <button id="modal-cancel" class="px-4 py-2 rounded-md bg-tertiary hover:bg-opacity-70">Cancelar</button>
                <button id="modal-save" class="px-4 py-2 rounded-md btn-action-yellow">Salvar</button>
            </div>
        </div>
    </div>

    <!-- Notificação Toast -->
    <div id="toast-notification">Mensagem aqui</div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- LÓGICA DE LOGIN E LOGOUT ---
        const loginOverlay = document.getElementById('login-overlay');
        const loginBox = document.getElementById('login-box');
        const loginForm = document.getElementById('login-form');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const errorMessage = document.getElementById('error-message');
        const appWrapper = document.getElementById('app-wrapper');
        const logoutBtn = document.getElementById('logout-btn');

        if (localStorage.getItem('isLoggedIn') === 'true') {
            loginOverlay.style.display = 'none';
            appWrapper.classList.remove('hidden');
            appWrapper.classList.add('flex');
        } else {
            loginOverlay.style.opacity = '1';
        }

        loginForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const username = usernameInput.value;
            const password = passwordInput.value;

            // Substitua por sua lógica de autenticação real
            if (username === 'admin' && password === 'admin123') {
                localStorage.setItem('isLoggedIn', 'true');
                errorMessage.classList.add('hidden');
                loginOverlay.classList.add('opacity-0');
                
                setTimeout(() => {
                    loginOverlay.style.display = 'none';
                    appWrapper.classList.remove('hidden');
                    appWrapper.classList.add('flex');
                }, 500);

            } else {
                errorMessage.classList.remove('hidden');
                passwordInput.value = '';
                loginBox.classList.add('animate-shake');
                
                setTimeout(() => {
                    loginBox.classList.remove('animate-shake');
                }, 500);
            }
        });

        logoutBtn.addEventListener('click', () => {
            localStorage.removeItem('isLoggedIn');
            appWrapper.classList.add('hidden');
            appWrapper.classList.remove('flex');
            
            usernameInput.value = '';
            passwordInput.value = '';
            errorMessage.classList.add('hidden');
            
            loginOverlay.style.display = 'flex';
            requestAnimationFrame(() => {
                 loginOverlay.classList.remove('opacity-0');
            });
        });

        // --- LÓGICA DO CONSTRUTOR DE FUNIL ---
        const flowCanvas = document.getElementById('flow-canvas');
        const transformer = document.getElementById('flow-transformer');
        let connectionsSvg = document.getElementById('connections-svg');
        const modal = document.getElementById('edit-modal');
        const toast = document.getElementById('toast-notification');
        
        let connections = [];
        let currentDrawingLine = null;
        let startElementForLine = null;
        let elementToEdit = null;

        let panX = 0, panY = 0, zoom = 1;
        let isPanning = false;
        let panStartX, panStartY;

        let chatName = 'ZaapFlow';
        let profilePicUrl = 'https://i.ibb.co/fzj6mf9K/Chat-GPT-Image-1-de-jul-de-2025-16-45-48.png';

        const componentInfoMap = {
            'sent-message': { name: 'Mensagem Enviada', icon: 'fa-paper-plane', text: '{{saudacao}} {{nome}}, como posso ajudar?' },
            'ask-question': { name: 'Pergunta com Botões', icon: 'fa-question-circle', text: '{{nome}}, você gostou do nosso serviço?', buttons: 'Sim;Não' },
            'delay': { name: 'Esperar (Delay)', icon: 'fa-clock', delay: 2 },
            'image-message': { name: 'Imagem', icon: 'fa-image', url: 'https://placehold.co/600x400/2A2A2A/EAEAEA?text=Imagem' },
            'audio-message': { name: 'Áudio', icon: 'fa-file-audio', url: '' },
            'video-message': { name: 'Vídeo do YouTube', icon: 'fab fa-youtube', url: '' },
            'direct-video-message': { name: 'Vídeo Direto', icon: 'fas fa-video', url: '' },
            'cta-button': { name: 'Botão (CTA)', icon: 'fa-mouse-pointer', text: 'Clique Aqui', url: '#', color: '#FFD23F', neon: 'true' },
            'user-input': { name: 'Campo de Resposta', icon: 'fa-keyboard', placeholder: 'Digite sua resposta...' },
        };

        const showToast = (message) => {
            toast.textContent = message;
            toast.classList.add('show');
            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        };

        // Sistema de conexões SVG customizado
        class CustomConnection {
            constructor(startConnector, endConnector) {
                this.startConnector = startConnector;
                this.endConnector = endConnector;
                this.startElement = startConnector.closest('.canvas-component');
                this.endElement = endConnector.closest('.canvas-component');
                this.startIndex = startConnector.dataset.outputIndex;
                
                // Criar grupo SVG para a conexão
                this.group = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.group.classList.add('connection-group');
                connectionsSvg.appendChild(this.group);
                
                // Criar linha SVG
                this.path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                this.path.classList.add('connection-line');
                this.group.appendChild(this.path);
                
                // Criar botão X de desconexão
                this.deleteBtn = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                this.deleteBtn.classList.add('connection-delete-btn');
                
                this.deleteCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                this.deleteCircle.classList.add('connection-delete-circle');
                this.deleteCircle.setAttribute('r', '8');
                
                this.deleteText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                this.deleteText.classList.add('connection-delete-text');
                this.deleteText.textContent = '×';
                
                this.deleteBtn.appendChild(this.deleteCircle);
                this.deleteBtn.appendChild(this.deleteText);
                this.group.appendChild(this.deleteBtn);
                
                // Event listener para o botão de delete
                this.deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    this.remove();
                });
                
                this.updatePosition();
            }
            
            updatePosition() {
                const startRect = this.getElementPosition(this.startElement);
                const endRect = this.getElementPosition(this.endElement);
                
                // Pontos de conexão
                const startX = startRect.x + startRect.width;
                const startY = startRect.y + startRect.height / 2;
                const endX = endRect.x;
                const endY = endRect.y + endRect.height / 2;
                
                // Verificar se a linha passa pela barra lateral (assumindo que ela tem 288px de largura)
                const sidebarWidth = 288;
                let pathData;
                let midX, midY;
                
                if (startX < sidebarWidth && endX > sidebarWidth) {
                    // Linha passa pela barra lateral, criar curva que contorna
                    const controlX1 = startX + 50;
                    const controlY1 = startY;
                    const controlX2 = sidebarWidth + 50;
                    const controlY2 = endY;
                    pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
                    
                    // Calcular ponto médio da curva Bézier
                    const t = 0.5;
                    midX = Math.pow(1-t, 3) * startX + 3 * Math.pow(1-t, 2) * t * controlX1 + 3 * (1-t) * Math.pow(t, 2) * controlX2 + Math.pow(t, 3) * endX;
                    midY = Math.pow(1-t, 3) * startY + 3 * Math.pow(1-t, 2) * t * controlY1 + 3 * (1-t) * Math.pow(t, 2) * controlY2 + Math.pow(t, 3) * endY;
                } else {
                    // Criar curva suave normal
                    const controlX1 = startX + (endX - startX) * 0.5;
                    const controlY1 = startY;
                    const controlX2 = startX + (endX - startX) * 0.5;
                    const controlY2 = endY;
                    pathData = `M ${startX} ${startY} C ${controlX1} ${controlY1}, ${controlX2} ${controlY2}, ${endX} ${endY}`;
                    
                    // Para curva simétrica, o ponto médio é mais simples
                    midX = (startX + endX) / 2;
                    midY = (startY + endY) / 2;
                }
                
                this.path.setAttribute('d', pathData);
                
                // Posicionar o botão X usando getPointAtLength se disponível
                try {
                    const pathLength = this.path.getTotalLength();
                    if (pathLength > 0) {
                        const midPoint = this.path.getPointAtLength(pathLength / 2);
                        this.deleteCircle.setAttribute('cx', midPoint.x);
                        this.deleteCircle.setAttribute('cy', midPoint.y);
                        this.deleteText.setAttribute('x', midPoint.x);
                        this.deleteText.setAttribute('y', midPoint.y);
                    } else {
                        // Fallback para cálculo manual
                        this.deleteCircle.setAttribute('cx', midX);
                        this.deleteCircle.setAttribute('cy', midY);
                        this.deleteText.setAttribute('x', midX);
                        this.deleteText.setAttribute('y', midY);
                    }
                } catch (e) {
                    // Fallback para cálculo manual
                    this.deleteCircle.setAttribute('cx', midX);
                    this.deleteCircle.setAttribute('cy', midY);
                    this.deleteText.setAttribute('x', midX);
                    this.deleteText.setAttribute('y', midY);
                }
            }
            
            getElementPosition(element) {
                // Usar getBoundingClientRect para obter posição real do elemento
                const rect = element.getBoundingClientRect();
                const canvasRect = flowCanvas.getBoundingClientRect();
                
                // Calcular posição relativa ao canvas
                const relativeX = rect.left - canvasRect.left;
                const relativeY = rect.top - canvasRect.top;
                
                // Converter para coordenadas do SVG (considerando pan e zoom)
                const svgX = (relativeX - panX) / zoom;
                const svgY = (relativeY - panY) / zoom;
                
                return {
                    x: svgX,
                    y: svgY,
                    width: rect.width / zoom,
                    height: rect.height / zoom
                };
            }
            
            remove() {
                if (this.group && this.group.parentNode) {
                    this.group.parentNode.removeChild(this.group);
                }
                
                const index = connections.indexOf(this);
                if (index > -1) {
                    connections.splice(index, 1);
                }
            }
        }

        const applyTransform = () => {
            transformer.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            
            // Atualizar posições das conexões (as transformações SVG são herdadas automaticamente)
            connections.forEach(conn => {
                conn.updatePosition();
            });
        };

        flowCanvas.addEventListener('wheel', e => {
            e.preventDefault();
            const zoomSpeed = 0.1;
            const oldZoom = zoom;
            zoom -= e.deltaY > 0 ? zoomSpeed : -zoomSpeed;
            zoom = Math.max(0.2, Math.min(2, zoom));
            const rect = flowCanvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            panX = mouseX - (mouseX - panX) * (zoom / oldZoom);
            panY = mouseY - (mouseY - panY) * (zoom / oldZoom);
            applyTransform();
        });

        flowCanvas.addEventListener('mousedown', e => {
            if (e.button === 1 || (e.button === 0 && e.target === flowCanvas)) { 
                isPanning = true;
                panStartX = e.clientX - panX;
                panStartY = e.clientY - panY;
                flowCanvas.style.cursor = 'grabbing';
            }
        });
        window.addEventListener('mousemove', e => { if (isPanning) { panX = e.clientX - panStartX; panY = e.clientY - panStartY; applyTransform(); } });
        window.addEventListener('mouseup', () => { isPanning = false; flowCanvas.style.cursor = 'grab'; });

        document.getElementById('zoom-in-btn').onclick = () => { zoom = Math.min(2, zoom + 0.1); applyTransform(); };
        document.getElementById('zoom-out-btn').onclick = () => { zoom = Math.max(0.2, zoom - 0.1); applyTransform(); };
        document.getElementById('reset-view-btn').onclick = () => { panX = 0; panY = 0; zoom = 1; applyTransform(); };

        document.querySelectorAll('.draggable').forEach(draggable => {
            draggable.addEventListener('dragstart', e => {
                e.dataTransfer.setData('text/plain', e.target.dataset.componentType);
                e.dataTransfer.setData('isNew', 'true');
            });
        });
        flowCanvas.addEventListener('dragover', e => { e.preventDefault(); flowCanvas.classList.add('drag-over'); });
        flowCanvas.addEventListener('dragleave', () => flowCanvas.classList.remove('drag-over'));
        flowCanvas.addEventListener('drop', e => {
            e.preventDefault();
            flowCanvas.classList.remove('drag-over');
            if (e.dataTransfer.getData('isNew') === 'true') {
                const rect = flowCanvas.getBoundingClientRect();
                const x = (e.clientX - rect.left - panX) / zoom;
                const y = (e.clientY - rect.top - panY) / zoom;
                createFlowComponent(e.dataTransfer.getData('text/plain'), x, y);
            }
        });

        function createFlowComponent(type, x, y, data = {}) {
            const id = data.id || `component_${Date.now()}`;
            const wrapper = document.createElement('div');
            wrapper.id = id;
            wrapper.className = 'canvas-component';
            wrapper.style.left = `${data.left || x}px`;
            wrapper.style.top = `${data.top || y}px`;
            wrapper.dataset.componentType = type;

            const info = componentInfoMap[type];
            const initialData = { ...info, ...(data.dataset || data) };
            Object.keys(initialData).forEach(key => {
                if(key !== 'name' && key !== 'icon') wrapper.dataset[key] = initialData[key];
            });

            let contentHTML = '';
            if (type === 'ask-question') {
                const buttons = initialData.buttons.split(';');
                contentHTML += `<div class="p-3"><p class="component-text text-sm text-text-secondary truncate">${initialData.text}</p></div>`;
                contentHTML += `<div class="multi-output-container border-t border-border-color divide-y divide-border-color">`;
                buttons.forEach((btn, index) => {
                    contentHTML += `<div class="flex justify-between items-center p-2 text-sm text-text-secondary">
                                        <span class="truncate">${btn}</span>
                                        <div class="connector-point output" data-output-index="${index}"></div>
                                    </div>`;
                });
                contentHTML += `</div>`;
            } else {
                let displayText = initialData.text || `Aguardar por ${initialData.delay} segundos`;
                if (['image-message', 'audio-message', 'video-message', 'direct-video-message'].includes(type)) {
                    displayText = `URL: ${initialData.url || 'Não definida'}`;
                    if (type === 'video-message' || type === 'direct-video-message') {
                        const format = initialData.format || 'landscape';
                        displayText += ` (${format === 'landscape' ? 'Deitado' : 'Shorts'})`;
                    }
                }
                if (type === 'cta-button') displayText = `Botão: ${initialData.text}`;
                if (type === 'user-input') displayText = `Placeholder: ${initialData.placeholder}`;
                contentHTML = `<div class="p-3"><p class="component-text text-sm text-text-secondary truncate">${displayText}</p></div>`;
            }

            wrapper.innerHTML = `
                <div class="component-header">
                    <div class="accent-bar neon-yellow-bar"></div>
                    <div class="flex justify-between items-center p-2">
                        <p class="text-sm font-semibold flex items-center"><i class="fas ${info.icon} mr-2 neon-yellow-text"></i> ${info.name}</p>
                        <div class="component-controls gap-2">
                            <button class="control-btn edit text-xs" title="Editar"><i class="fas fa-pencil-alt"></i></button>
                            <button class="control-btn remove text-xs" title="Remover"><i class="fas fa-times"></i></button>
                        </div>
                    </div>
                </div>
                ${contentHTML}
                <div class="connector-point input"></div>
                ${type !== 'ask-question' ? '<div class="connector-point output"></div>' : ''}
            `;
            transformer.appendChild(wrapper);
            makeDraggable(wrapper);
            setupControls(wrapper);
            return wrapper;
        }

        function makeDraggable(element) {
            let pos1 = 0, pos2 = 0, pos3 = 0, pos4 = 0;
            let isDragging = false;
            
            element.onmousedown = e => {
                // Não iniciar drag se estiver clicando em conectores, controles ou inputs
                if (e.target.closest('.connector-point, .component-controls, input, textarea, button')) return;
                if (isDrawingConnection) return; // Não arrastar durante desenho de conexão
                
                e.preventDefault();
                e.stopPropagation();
                isDragging = true;
                pos3 = e.clientX; 
                pos4 = e.clientY;
                document.onmouseup = closeDragElement; 
                document.onmousemove = elementDrag;
            };
            
            function elementDrag(e) {
                if (!isDragging) return;
                e.preventDefault();
                pos1 = (pos3 - e.clientX) / zoom;
                pos2 = (pos4 - e.clientY) / zoom;
                pos3 = e.clientX; 
                pos4 = e.clientY;
                element.style.top = `${element.offsetTop - pos2}px`;
                element.style.left = `${element.offsetLeft - pos1}px`;
                updateConnectionsForElement(element);
            }
            
            function closeDragElement() { 
                isDragging = false;
                document.onmouseup = null; 
                document.onmousemove = null; 
            }
        }
        
        function setupControls(element) {
            element.querySelector('.remove').onclick = () => {
                removeConnectionsForElement(element);
                element.remove();
                updatePreview();
            };
            element.querySelector('.edit').onclick = () => openEditModal(element);
        }

        // Sistema de desenho de conexões
        let isDrawingConnection = false;
        
        document.addEventListener('mousedown', e => {
            if (e.target.classList.contains('output')) {
                e.preventDefault();
                e.stopPropagation();
                isDrawingConnection = true;
                startElementForLine = e.target;
                
                // Criar linha temporária para visualização
                currentDrawingLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                currentDrawingLine.setAttribute('stroke', 'rgba(255, 210, 63, 0.7)');
                currentDrawingLine.setAttribute('stroke-width', '2');
                currentDrawingLine.setAttribute('fill', 'none');
                currentDrawingLine.setAttribute('stroke-dasharray', '5,5');
                connectionsSvg.appendChild(currentDrawingLine);
            }
        });

        document.addEventListener('mousemove', e => { 
            if (isDrawingConnection && currentDrawingLine && startElementForLine) {
                const rect = flowCanvas.getBoundingClientRect();
                const canvasX = (e.clientX - rect.left - panX) / zoom;
                const canvasY = (e.clientY - rect.top - panY) / zoom;
                
                const startElement = startElementForLine.closest('.canvas-component');
                const startRect = {
                    x: parseFloat(startElement.style.left) || 0,
                    y: parseFloat(startElement.style.top) || 0,
                    width: startElement.offsetWidth,
                    height: startElement.offsetHeight
                };
                
                const startX = startRect.x + startRect.width;
                const startY = startRect.y + startRect.height / 2;
                
                const pathData = `M ${startX} ${startY} L ${canvasX} ${canvasY}`;
                currentDrawingLine.setAttribute('d', pathData);
            }
        });
        
        document.addEventListener('mouseup', e => {
            if (isDrawingConnection) {
                if (currentDrawingLine) {
                    currentDrawingLine.remove();
                    currentDrawingLine = null;
                }
                
                if (e.target.classList.contains('input')) {
                    const endElement = e.target.closest('.canvas-component');
                    const startElement = startElementForLine.closest('.canvas-component');
                    
                    if (endElement && startElement && endElement !== startElement) {
                        // Verificar se já existe uma conexão para este input
                        const existingConnection = connections.find(conn => 
                            conn.endElement === endElement
                        );
                        
                        if (existingConnection) {
                            existingConnection.remove();
                        }
                        
                        createConnection(startElementForLine, e.target);
                    }
                }
                
                isDrawingConnection = false;
                startElementForLine = null;
            }
        });

        function createConnection(startConnector, endConnector) {
            const connection = new CustomConnection(startConnector, endConnector);
            connections.push(connection);
            return connection;
        }

        function updateConnectionsForElement(element) { 
            connections.forEach(conn => { 
                if (conn.startElement === element || conn.endElement === element) {
                    conn.updatePosition();
                }
            }); 
        }
        
        function removeConnectionsForElement(element) {
            const toRemove = connections.filter(conn => 
                conn.startElement === element || conn.endElement === element
            );
            toRemove.forEach(conn => conn.remove());
        }

        function updatePreview(chatBody) {
            if (!chatBody) {
                const previewChatContainer = document.getElementById('preview-chat-container');
                if (!previewChatContainer) return;
                previewChatContainer.innerHTML = `
                    <div style="background-color: #075E54; color: white; padding: 10px 15px; display: flex; align-items: center; gap: 15px; flex-shrink: 0;">
                        <img src="${profilePicUrl}" alt="Foto" style="width: 45px; height: 45px; border-radius: 50%; border: 2px solid white; object-fit: cover;" onerror="this.src='https://placehold.co/45x45/075E54/FFFFFF?text=??'">
                        <div><div style="font-weight: bold;">${chatName}</div><div style="font-size: 0.8em; color: #d1d1d1;">online</div></div>
                    </div>
                    <div id="preview-chat-body" style="flex-grow: 1; padding: 20px 10px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px;"></div>
                `;
                chatBody = document.getElementById('preview-chat-body');
            }
            
            chatBody.innerHTML = '';
        }

        document.getElementById('save-settings-btn').onclick = () => {
            chatName = document.getElementById('chat-name-input').value;
            profilePicUrl = document.getElementById('chat-photo-input').value;
            updatePreview();
            showToast('Configurações salvas!');
        };

        function insertTextAtCursor(textarea, text) {
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            const value = textarea.value;
            textarea.value = value.substring(0, start) + text + value.substring(end);
            textarea.selectionStart = textarea.selectionEnd = start + text.length;
            textarea.focus();
        }

        function openEditModal(element) {
            elementToEdit = element;
            const type = element.dataset.componentType;
            const modalBody = modal.querySelector('#modal-body');
            let formHTML = '';
            let hasVariableButton = false;

            switch(type) {
                case 'sent-message':
                    formHTML = `<label class="block text-sm font-medium text-text-secondary mb-2">Texto</label><textarea id="text-input" class="w-full p-2 rounded-md" rows="4">${element.dataset.text}</textarea>`;
                    hasVariableButton = true;
                    break;
                case 'ask-question':
                    formHTML = `<label class="block text-sm font-medium text-text-secondary mb-2">Texto da Pergunta</label><textarea id="text-input" class="w-full p-2 rounded-md" rows="3">${element.dataset.text}</textarea>
                                <label class="block text-sm font-medium text-text-secondary mt-4 mb-2">Botões (um por linha)</label><textarea id="buttons-input" class="w-full p-2 rounded-md" rows="3">${element.dataset.buttons.split(';').join('\n')}</textarea>`;
                    hasVariableButton = true;
                    break;
                case 'delay':
                    formHTML = `<label class="block text-sm font-medium text-text-secondary mb-2">Tempo de espera (segundos)</label><input type="number" id="delay-input" class="w-full p-2 rounded-md" value="${element.dataset.delay}">`;
                    break;
                case 'image-message': case 'audio-message':
                    let label = type.includes('image') ? 'Imagem' : 'Áudio';
                    formHTML = `<label class="block text-sm font-medium text-text-secondary mb-2">URL do ${label}</label><input type="text" id="url-input" class="w-full p-2 rounded-md" value="${element.dataset.url}">`;
                    break;
                case 'video-message':
                    formHTML = `<label class="block text-sm font-medium text-text-secondary mb-2">URL do Vídeo do YouTube</label><input type="text" id="url-input" class="w-full p-2 rounded-md" value="${element.dataset.url}">
                                <label class="block text-sm font-medium text-text-secondary mt-4 mb-2">Formato do Vídeo</label>
                                <select id="format-input" class="w-full p-2 rounded-md">
                                    <option value="landscape" ${element.dataset.format === 'landscape' ? 'selected' : ''}>Deitado (16:9)</option>
                                    <option value="shorts" ${element.dataset.format === 'shorts' ? 'selected' : ''}>Shorts (9:16)</option>
                                </select>`;
                    break;
                case 'direct-video-message':
                    formHTML = `<label class="block text-sm font-medium text-text-secondary mb-2">URL do Vídeo Direto</label><input type="text" id="url-input" class="w-full p-2 rounded-md" value="${element.dataset.url}">
                                <label class="block text-sm font-medium text-text-secondary mt-4 mb-2">Formato do Vídeo</label>
                                <select id="format-input" class="w-full p-2 rounded-md">
                                    <option value="landscape" ${element.dataset.format === 'landscape' ? 'selected' : ''}>Deitado (16:9)</option>
                                    <option value="shorts" ${element.dataset.format === 'shorts' ? 'selected' : ''}>Shorts (9:16)</option>
                                </select>`;
                    break;
                case 'cta-button':
                    formHTML = `<label class="block text-sm font-medium text-text-secondary mb-2">Texto do Botão</label><input type="text" id="text-input" class="w-full p-2 rounded-md" value="${element.dataset.text}">
                                <label class="block text-sm font-medium text-text-secondary mt-4 mb-2">URL do Link</label><input type="text" id="url-input" class="w-full p-2 rounded-md" value="${element.dataset.url}">
                                <label class="block text-sm font-medium text-text-secondary mt-4 mb-2">Cor do Botão</label><input type="color" id="color-input" class="w-full h-10" value="${element.dataset.color}">
                                <div class="flex items-center mt-4"><input type="checkbox" id="neon-input" class="h-4 w-4 rounded bg-tertiary border-border-color" ${element.dataset.neon === 'true' ? 'checked' : ''}><label for="neon-input" class="ml-2 text-sm text-text-secondary">Efeito Neon</label></div>`;
                    break;
                case 'user-input':
                    formHTML = `<label class="block text-sm font-medium text-text-secondary mb-2">Texto do Placeholder</label><input type="text" id="placeholder-input" class="w-full p-2 rounded-md" value="${element.dataset.placeholder}">`;
                    break;
            }
            
            if (hasVariableButton) {
                formHTML += `<div class="mt-2 flex flex-wrap gap-2">
                                     <button type="button" data-variable="{{nome}}" class="insert-variable-btn px-3 py-1 rounded-md text-xs bg-tertiary hover:bg-opacity-70">Inserir {{nome}}</button>
                                     <button type="button" data-variable="{{saudacao}}" class="insert-variable-btn px-3 py-1 rounded-md text-xs bg-tertiary hover:bg-opacity-70">Inserir {{saudacao}}</button>
                                     <button type="button" data-variable="{{dia_semana}}" class="insert-variable-btn px-3 py-1 rounded-md text-xs bg-tertiary hover:bg-opacity-70">Inserir {{dia_semana}}</button>
                                   </div>`;
            }

            modalBody.innerHTML = formHTML;
            
            if (hasVariableButton) {
                modalBody.querySelectorAll('.insert-variable-btn').forEach(btn => {
                    btn.onclick = () => {
                        const textInput = modalBody.querySelector('#text-input');
                        insertTextAtCursor(textInput, btn.dataset.variable);
                    };
                });
            }

            modal.classList.remove('hidden');
        }

        modal.querySelector('#modal-save').onclick = () => {
            if (!elementToEdit) return;
            const type = elementToEdit.dataset.componentType;
            let displayText = '';

            switch(type) {
                case 'sent-message':
                    elementToEdit.dataset.text = modal.querySelector('#text-input').value;
                    displayText = elementToEdit.dataset.text;
                    break;
                case 'ask-question':
                    elementToEdit.dataset.text = modal.querySelector('#text-input').value;
                    const buttons = modal.querySelector('#buttons-input').value.split('\n').filter(b => b);
                    elementToEdit.dataset.buttons = buttons.join(';');
                    displayText = elementToEdit.dataset.text;
                    let buttonOutputsHTML = '';
                    buttons.forEach((btn, index) => {
                        buttonOutputsHTML += `<div class="flex justify-between items-center p-2 text-sm text-text-secondary"><span class="truncate">${btn}</span><div class="connector-point output" data-output-index="${index}"></div></div>`;
                    });
                    elementToEdit.querySelector('.multi-output-container').innerHTML = buttonOutputsHTML;
                    break;
                case 'delay':
                    elementToEdit.dataset.delay = modal.querySelector('#delay-input').value;
                    displayText = `Aguardar por ${elementToEdit.dataset.delay} segundos`;
                    break;
                case 'image-message': case 'audio-message':
                    elementToEdit.dataset.url = modal.querySelector('#url-input').value;
                    displayText = `URL: ${elementToEdit.dataset.url}`;
                    break;
                case 'video-message': case 'direct-video-message':
                    elementToEdit.dataset.url = modal.querySelector('#url-input').value;
                    elementToEdit.dataset.format = modal.querySelector('#format-input').value;
                    const formatText = elementToEdit.dataset.format === 'landscape' ? 'Deitado' : 'Shorts';
                    displayText = `URL: ${elementToEdit.dataset.url} (${formatText})`;
                    break;
                case 'cta-button':
                    elementToEdit.dataset.text = modal.querySelector('#text-input').value;
                    elementToEdit.dataset.url = modal.querySelector('#url-input').value;
                    elementToEdit.dataset.color = modal.querySelector('#color-input').value;
                    elementToEdit.dataset.neon = modal.querySelector('#neon-input').checked;
                    displayText = `Botão: ${elementToEdit.dataset.text}`;
                    break;
                case 'user-input':
                    elementToEdit.dataset.placeholder = modal.querySelector('#placeholder-input').value;
                    displayText = `Placeholder: ${elementToEdit.dataset.placeholder}`;
                    break;
            }
            if(elementToEdit.querySelector('.component-text')) elementToEdit.querySelector('.component-text').innerText = displayText;
            modal.classList.add('hidden');
            elementToEdit = null;
            updatePreview();
        };
        
        modal.querySelector('#modal-cancel').onclick = () => modal.classList.add('hidden');

        function createSentMessagePreview(text) {
            const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
            const wrapper = document.createElement('div');
            wrapper.style.cssText = "display: flex; flex-direction: column; align-items: flex-end; margin-bottom: 12px;";
            wrapper.innerHTML = `
                <div style="max-width: 80%; background-color: #dcf8c6; padding: 10px 15px; border-radius: 10px; border-top-right-radius: 0; box-shadow: 0 1px 1px rgba(0,0,0,0.1); color: #333;">
                    ${text}
                    <span style="display: block; font-size: 0.7em; color: #999; text-align: right; margin-top: 5px;">${time}</span>
                </div>`;
            return wrapper;
        }

        function createPreviewComponent(element, variables = {}, profilePicUrl, flowData) {
            const type = element.dataset.componentType;
            const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
            const wrapper = document.createElement('div');
            wrapper.style.cssText = "display: flex; flex-direction: column; align-items: flex-start; margin-bottom: 12px;";

            let textContent = element.dataset.text || '';
            for (const key in variables) {
                textContent = textContent.replace(new RegExp(`{{${key}}}`, 'g'), variables[key]);
            }

            switch(type) {
                case 'delay':
                    wrapper.innerHTML = `<div style="align-self: flex-start; display: flex; align-items: center; padding: 10px 15px;"><span style="height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out;"></span><span style="height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out -1.1s;"></span><span style="height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out -0.9s;"></span></div><style>@keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }</style>`;
                    break;
                case 'audio-message':
                     const audioUrl = element.dataset.url || 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA='; // Default silent audio
                     wrapper.innerHTML = `<div class="audio-player-container">
                                 <img src="${profilePicUrl}" onerror="this.src='https://placehold.co/40x40/777/FFFFFF?text=??'">
                                 <button class="play-pause-btn"><i class="fas fa-play"></i></button>
                                 <div class="progress-bar-container"><div class="progress-bar"></div></div>
                                 <div class="time-info">
                                     <span class="current-time">0:00</span>
                                     <span class="timestamp">${time}</span>
                                 </div>
                                 <audio class="hidden-audio" src="${audioUrl}"></audio>
                             </div>`;
                    break;
                case 'video-message':
                    const videoId = element.dataset.url.split('v=')[1]?.split('&')[0] || element.dataset.url.split('/').pop();
                    const videoFormat = element.dataset.format || 'landscape';
                    let videoHtml = '';
                    if (videoFormat === 'landscape') {
                        videoHtml = `<iframe style="width: 100%; aspect-ratio: 16/9; border-radius: 8px;" src="https://www.youtube.com/embed/${videoId}" frameborder="0" allowfullscreen></iframe>`;
                    } else { // shorts
                        videoHtml = `<iframe style="width: 100%; aspect-ratio: 9/16; height: 300px; border-radius: 8px;" src="https://www.youtube.com/embed/${videoId}" frameborder="0" allowfullscreen></iframe>`;
                    }
                    wrapper.innerHTML = `<div style="align-self: flex-start; max-width: 80%; background-color: transparent; padding: 5px; border-radius: 10px;">${videoHtml}</div>`;
                    break;
                case 'direct-video-message':
                    const directVideoFormat = element.dataset.format || 'landscape';
                    let directVideoHtml = '';
                    if (directVideoFormat === 'landscape') {
                        directVideoHtml = `<video controls style="width: 100%; aspect-ratio: 16/9; border-radius: 8px;"><source src="${element.dataset.url}" type="video/mp4">Seu navegador não suporta vídeos.</video>`;
                    } else { // shorts
                        directVideoHtml = `<video controls style="width: 100%; aspect-ratio: 9/16; height: 300px; border-radius: 8px;"><source src="${element.dataset.url}" type="video/mp4">Seu navegador não suporta vídeos.</video>`;
                    }
                    wrapper.innerHTML = `<div style="align-self: flex-start; max-width: 80%; background-color: transparent; padding: 5px; border-radius: 10px;">${directVideoHtml}</div>`;
                    break;
                case 'image-message':
                     wrapper.innerHTML = `<div style="align-self: flex-start; max-width: 80%; background-color: #fff; padding: 5px; border-radius: 10px; border-top-left-radius: 0; box-shadow: 0 1px 1px rgba(0,0,0,0.1);"><img src="${element.dataset.url}" style="width: 100%; border-radius: 8px;" alt="Imagem do fluxo" onerror="this.src='https://placehold.co/600x400/2A2A2A/EAEAEA?text=Erro!'"><span style="display: block; font-size: 0.7em; color: #999; text-align: right; padding: 0 5px 2px;">${time}</span></div>`;
                    break;
                case 'cta-button':
                    const color = element.dataset.color;
                    const neon = element.dataset.neon === 'true' ? `box-shadow: 0 0 10px ${color}, 0 0 20px ${color}80;` : '';
                    wrapper.innerHTML = `<div style="padding: 10px; align-self: center;"><a href="${element.dataset.url}" target="_blank" class="cta-pixel-trigger" style="padding: 12px 24px; background-color: ${color}; color: #111; font-weight: bold; border-radius: 30px; text-decoration: none; ${neon}">${textContent}</a></div>`;
                    wrapper.style.alignItems = 'center';
                    break;
                case 'user-input':
                    wrapper.innerHTML = `<div style="width: 100%; background-color: transparent; padding: 10px; display: flex; gap: 10px; margin-top: auto;">
                                         <input type="text" placeholder="${element.dataset.placeholder}" class="preview-input" style="flex-grow: 1; border: none; padding: 12px 15px; border-radius: 20px; font-size: 1em; background-color: #fff; color: #000; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                                         <button class="preview-send-btn" style="background-color: #075E54; color: white; border: none; border-radius: 50%; width: 45px; height: 45px; font-size: 1.2em; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"><i class="fa-solid fa-paper-plane"></i></button>
                                     </div>`;
                    break;
                case 'sent-message':
                case 'ask-question':
                    wrapper.style.alignItems = 'flex-start';
                    wrapper.innerHTML = `<div style="max-width: 80%; background-color: #fff; padding: 10px 15px; border-radius: 10px; border-top-left-radius: 0; box-shadow: 0 1px 1px rgba(0,0,0,0.1); color: #333;">
                                             ${textContent}
                                             <span style="display: block; font-size: 0.7em; color: #999; text-align: right; margin-top: 5px;">${time}</span>
                                         </div>`;
                    if (type === 'ask-question') {
                        const btnContainer = document.createElement('div');
                        btnContainer.style.cssText = "align-self: flex-start; display: flex; flex-wrap: wrap; gap: 10px; padding: 5px 0 10px 0;";
                        element.dataset.buttons.split(';').forEach((btnText, index) => {
                            const button = document.createElement('button');
                            button.innerText = btnText;
                            button.dataset.buttonIndex = index;
                            button.style.cssText = "background-color: #fff; border: 1px solid #075E54; color: #075E54; padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s;";
                            btnContainer.appendChild(button);
                        });
                        wrapper.appendChild(btnContainer);
                    }
                    break;
            }
            return wrapper;
        }

        /**
         * Gera variáveis dinâmicas como saudação e dia da semana.
         * Esta função estava faltando no escopo principal, causando o erro.
         */
        function getLiveVariables() {
            const now = new Date();
            const hour = now.getHours();
            const day = now.getDay();
            const weekdays = ["domingo", "segunda-feira", "terça-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sábado"];
            let saudacao;
            if (hour >= 5 && hour < 12) {
                saudacao = "Bom dia";
            } else if (hour >= 12 && hour < 18) {
                saudacao = "Boa tarde";
            } else {
                saudacao = "Boa noite";
            }
            return {
                saudacao: saudacao,
                dia_semana: weekdays[day]
            };
        }

        async function runFlowTest() {
            const testBtn = document.getElementById('test-flow-btn');

            try {
                const flowData = getFlowData();
                const allComponents = flowData.components;

                if (allComponents.length === 0) {
                    showToast("Adicione componentes ao funil para testar.");
                    return;
                }
                
                const chatBody = document.getElementById('preview-chat-body');
                updatePreview(chatBody);
                
                const delay = ms => new Promise(res => setTimeout(res, ms));
                const liveVariables = getLiveVariables();

                // Criar mapa de componentes e conexões
                const componentMap = new Map(allComponents.map(comp => [comp.id, comp]));
                const endNodeIds = new Set(flowData.connections.map(conn => conn.endId));
                let startNodes = allComponents.filter(comp => !endNodeIds.has(comp.id));

                if (startNodes.length === 0 && allComponents.length > 0) {
                    console.error("Nenhum componente de início encontrado. O fluxo pode estar em um loop.");
                    startNodes.push(allComponents[0]);
                }

                // Verificar se algum componente no fluxo usa a variável {{nome}}
                const needsNameInput = allComponents.some(comp => 
                    (comp.dataset.text || '').includes('{{nome}}')
                );

                // Função para solicitar nome quando necessário
                const askForName = async () => {
                    return new Promise(resolve => {
                        const questionHTML = `<div style="max-width: 80%; background-color: #fff; padding: 10px 15px; border-radius: 10px; border-top-left-radius: 0; box-shadow: 0 1px 1px rgba(0,0,0,0.1); color: #333;">Qual é o seu nome?</div>`;
                        chatBody.innerHTML += questionHTML;
                        
                        const inputContainer = document.createElement('div');
                        inputContainer.innerHTML = `<div style="width: 100%; background-color: transparent; padding: 10px; display: flex; gap: 10px; margin-top: auto;">
                            <input type="text" placeholder="Digite seu nome..." class="preview-input" style="flex-grow: 1; border: none; padding: 12px 15px; border-radius: 20px; font-size: 1em; background-color: #fff; color: #000; box-shadow: 0 1px 2px rgba(0,0,0,0.1);">
                            <button class="preview-send-btn" style="background-color: #075E54; color: white; border: none; border-radius: 50%; width: 45px; height: 45px; font-size: 1.2em; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"><i class="fa-solid fa-paper-plane"></i></button>
                        </div>`;
                        chatBody.appendChild(inputContainer);
                        
                        const inputField = inputContainer.querySelector('.preview-input');
                        const sendButton = inputContainer.querySelector('.preview-send-btn');
                        inputField.focus();

                        const handleSend = () => {
                            const userText = inputField.value || "Visitante";
                            inputContainer.remove();
                            chatBody.appendChild(createSentMessagePreview(userText));
                            chatBody.scrollTop = chatBody.scrollHeight;
                            if (typeof fbq === 'function' && flowData.settings.pixelId) { fbq('track', 'Lead'); }
                            resolve(userText);
                        };
                        sendButton.onclick = handleSend;
                        inputField.onkeypress = (e) => { if (e.key === 'Enter') handleSend(); };
                    });
                };

                const executeComponent = async (component) => {
                    if (!component) return;
                    const type = component.dataset.componentType;
                    let nextComponentId = null;
                    
                    // Verificar se este componente específico precisa do nome e ainda não temos
                    if ((component.dataset.text || '').includes('{{nome}}') && !liveVariables.nome) {
                        liveVariables.nome = await askForName();
                        await delay(500);
                    }
                    
                    if (type === 'delay') {
                        const indicator = createPreviewComponent(component, liveVariables, flowData.settings.profilePicUrl, flowData);
                        chatBody.appendChild(indicator);
                        chatBody.scrollTop = chatBody.scrollHeight;
                        await delay(component.dataset.delay * 1000);
                        indicator.remove();
                    } else {
                        const indicator = createPreviewComponent({dataset: {componentType: 'delay'}}, liveVariables, flowData.settings.profilePicUrl, flowData);
                        chatBody.appendChild(indicator);
                        chatBody.scrollTop = chatBody.scrollHeight;
                        await delay(800);
                        indicator.remove();

                        const previewElement = createPreviewComponent(component, liveVariables, flowData.settings.profilePicUrl, flowData);
                        chatBody.appendChild(previewElement);
                        
                        const ctaButton = previewElement.querySelector('.cta-pixel-trigger');
                        if (ctaButton) {
                            ctaButton.addEventListener('click', () => {
                                if (typeof fbq === 'function' && flowData.settings.pixelId) {
                                    fbq('track', 'Contact');
                                }
                            });
                        }

                        if(previewElement.querySelector('.audio-player-container')) {
                            setupAudioPlayer(previewElement);
                        }
                        chatBody.scrollTop = chatBody.scrollHeight;
                        await delay(500);
                    }

                    if (type === 'ask-question') {
                        const chosenIndex = await new Promise(resolve => {
                            const buttons = chatBody.querySelectorAll('button[data-button-index]');
                            buttons.forEach(button => {
                                button.addEventListener('click', (e) => {
                                    chatBody.appendChild(createSentMessagePreview(e.target.innerText));
                                    buttons.forEach(btn => {
                                        btn.disabled = true; btn.style.cursor = 'not-allowed'; btn.style.backgroundColor = '#f0f0f0'; btn.style.borderColor = '#ccc'; btn.style.color = '#aaa';
                                    });
                                    e.target.style.backgroundColor = '#075E54'; e.target.style.color = 'white';
                                    
                                    if (typeof fbq === 'function' && flowData.settings.pixelId) {
                                        fbq('trackCustom', 'QuestionResponse', { 
                                            question: component.dataset.text.substring(0, 100),
                                            response: e.target.innerText.substring(0, 100)
                                        });
                                    }

                                    setTimeout(() => {
                                        chatBody.scrollTop = chatBody.scrollHeight;
                                        resolve(e.target.dataset.buttonIndex)
                                    }, 500);
                                }, { once: true });
                            });
                        });
                        const connection = flowData.connections.find(c => c.startId === component.id && c.startIndex == chosenIndex);
                        if (connection) nextComponentId = connection.endId;

                    } else if (type === 'user-input') {
                        await new Promise(resolve => {
                            const inputContainer = chatBody.lastElementChild;
                            const inputField = inputContainer.querySelector('.preview-input');
                            const sendButton = inputContainer.querySelector('.preview-send-btn');
                            inputField.disabled = false; inputField.focus();
                            const handleSend = () => {
                                const userText = inputField.value || "Resposta simulada";
                                inputContainer.remove();
                                chatBody.appendChild(createSentMessagePreview(userText));
                                chatBody.scrollTop = chatBody.scrollHeight;
                                if (typeof fbq === 'function' && flowData.settings.pixelId) { fbq('track', 'Lead'); }
                                resolve();
                            };
                            sendButton.onclick = handleSend;
                            inputField.onkeypress = (e) => { if (e.key === 'Enter') handleSend(); };
                        });
                        const connection = flowData.connections.find(c => c.startId === component.id);
                        if (connection) nextComponentId = connection.endId;
                    } else {
                        const connection = flowData.connections.find(c => c.startId === component.id);
                        if (connection) nextComponentId = connection.endId;
                    }
                    
                    if (nextComponentId) {
                        await executeComponent(componentMap.get(nextComponentId));
                    }
                };
                
                // Executar o fluxo seguindo a ordem das conexões
                for (const node of startNodes) {
                    await executeComponent(node);
                }
            } catch (error) {
                console.error("Erro ao testar o fluxo:", error);
                showToast("Ocorreu um erro ao testar o fluxo.");
            }
        }


        function setupAudioPlayer(playerContainer) {
            const audio = playerContainer.querySelector('.hidden-audio');
            const playBtn = playerContainer.querySelector('.play-pause-btn i');
            const progressBar = playerContainer.querySelector('.progress-bar');
            const currentTimeEl = playerContainer.querySelector('.current-time');
            const totalTimeEl = playerContainer.querySelector('.total-time');

            const formatTime = (time) => {
                const minutes = Math.floor(time / 60);
                const seconds = Math.floor(time % 60).toString().padStart(2, '0');
                return `${minutes}:${seconds}`;
            }

            audio.addEventListener('loadedmetadata', () => {
                if(totalTimeEl) totalTimeEl.textContent = formatTime(audio.duration);
            });

            audio.addEventListener('timeupdate', () => {
                const progress = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = `${progress}%`;
                currentTimeEl.textContent = formatTime(audio.currentTime);
            });

            audio.addEventListener('ended', () => {
                playBtn.classList.remove('fa-pause');
                playBtn.classList.add('fa-play');
                progressBar.style.width = '0%';
            });

            playBtn.parentElement.addEventListener('click', () => {
                if (audio.paused) {
                    audio.play();
                    playBtn.classList.remove('fa-play');
                    playBtn.classList.add('fa-pause');
                } else {
                    audio.pause();
                    playBtn.classList.remove('fa-pause');
                    playBtn.classList.add('fa-play');
                }
            });
        }

        document.getElementById('test-flow-btn').addEventListener('click', runFlowTest);
        
        function getFlowData() {
            const componentsData = Array.from(transformer.querySelectorAll('.canvas-component')).map(comp => ({
                id: comp.id,
                type: comp.dataset.componentType,
                left: comp.style.left,
                top: comp.style.top,
                dataset: { ...comp.dataset }
            }));

            const connectionsData = connections.map(conn => ({
                startId: conn.startElement.id,
                endId: conn.endElement.id,
                startIndex: conn.startIndex
            }));
            
            const settingsData = {
                chatName: document.getElementById('chat-name-input').value,
                profilePicUrl: document.getElementById('chat-photo-input').value,
                pixelId: document.getElementById('pixel-id-input').value,
                customScripts: document.getElementById('custom-scripts-input').value
            };

            return {
                settings: settingsData,
                components: componentsData,
                connections: connectionsData
            };
        }

        function exportFlow() {
            const flowData = getFlowData();
            const dataStr = JSON.stringify(flowData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'zaapflow-funil.json';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function triggerImport() {
            document.getElementById('import-file-input').click();
        }

        function handleFileImport(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const flowData = JSON.parse(event.target.result);
                    loadFlow(flowData);
                    showToast('Funil importado com sucesso!');
                } catch (error) {
                    console.error("Erro ao ler o arquivo JSON:", error);
                    showToast('Erro ao importar o arquivo.');
                }
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        function loadFlow(flowData) {
            transformer.innerHTML = '';
            
            // Recriar o SVG de conexões
            const newSvg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            newSvg.id = 'connections-svg';
            newSvg.style.position = 'absolute';
            newSvg.style.top = '0';
            newSvg.style.left = '0';
            newSvg.style.width = '100%';
            newSvg.style.height = '100%';
            newSvg.style.pointerEvents = 'none';
            newSvg.style.zIndex = '1';
            newSvg.style.overflow = 'visible';
            newSvg.style.clipPath = 'none';
            
            newSvg.innerHTML = `
                <defs>
                    <filter id="glow">
                        <feGaussianBlur stdDeviation="3" result="coloredBlur"/>
                        <feMerge> 
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
            `;
            transformer.appendChild(newSvg);
            
            // Atualizar referência global
            connectionsSvg = newSvg;
            
            // Limpar conexões existentes
            connections.forEach(conn => conn.remove());
            connections = [];

            if (flowData.settings) {
                document.getElementById('chat-name-input').value = flowData.settings.chatName || 'ZaapFlow';
                document.getElementById('chat-photo-input').value = flowData.settings.profilePicUrl || 'https://i.ibb.co/fzj6mf9K/Chat-GPT-Image-1-de-jul-de-2025-16-45-48.png';
                document.getElementById('pixel-id-input').value = flowData.settings.pixelId || '';
                document.getElementById('custom-scripts-input').value = flowData.settings.customScripts || '';
                chatName = flowData.settings.chatName;
                profilePicUrl = flowData.settings.profilePicUrl;
            }

            if (flowData.components) {
                flowData.components.forEach(compData => {
                    createFlowComponent(compData.type, parseFloat(compData.left), parseFloat(compData.top), compData);
                });
            }

            if (flowData.connections) {
                flowData.connections.forEach(connData => {
                    const startEl = document.getElementById(connData.startId);
                    const endEl = document.getElementById(connData.endId);
                    if (startEl && endEl) {
                        const startConnector = connData.startIndex != null
                            ? startEl.querySelector(`.output[data-output-index="${connData.startIndex}"]`)
                            : startEl.querySelector('.output');
                        const endConnector = endEl.querySelector('.input');
                        if (startConnector && endConnector) {
                            createConnection(startConnector, endConnector);
                        }
                    }
                });
            }
            
            updatePreview();
            applyTransform();
        }

        function generateStandaloneHTML() {
            const flowData = getFlowData();
            const safeFlowDataJSON = JSON.stringify(flowData).replace(/<\/script>/g, '<\\/script>');
            
            const pixelId = flowData.settings.pixelId;
            let pixelScript = '';
            if (pixelId && pixelId.trim() !== '' && !flowData.settings.customScripts.includes('connect.facebook.net')) {
                pixelScript = `
    <script>
    !function(f,b,e,v,n,t,s)
    {if(f.fbq)return;n=f.fbq=function(){n.callMethod?
    n.callMethod.apply(n,arguments):n.queue.push(arguments)};
    if(!f._fbq)f._fbq=n;n.push=n;n.loaded=!0;n.version='2.0';
    n.queue=[];t=b.createElement(e);t.async=!0;
    t.src=v;s=b.getElementsByTagName(e)[0];
    s.parentNode.insertBefore(t,s)}(window, document,'script',
    'https://connect.facebook.net/en_US/fbevents.js');
    fbq('init', '${pixelId}');
    fbq('track', 'PageView');
    <\/script>
    <noscript><img height="1" width="1" style="display:none"
    src="https://www.facebook.com/tr?id=${pixelId}&ev=PageView&noscript=1"
    /></noscript>
    `;
            }

            const customScripts = flowData.settings.customScripts || '';
            
            return `
<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>${flowData.settings.chatName}</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    ${pixelScript}
    <style>
        html, body {
            margin: 0;
            padding: 0;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }
        #preview-chat-body::-webkit-scrollbar { width: 6px; }
        #preview-chat-body::-webkit-scrollbar-thumb { background-color: rgba(0,0,0,0.2); border-radius: 3px; }
        .audio-player-container { align-self: flex-start; max-width: 80%; background-color: #fff; padding: 8px; border-radius: 10px; border-top-left-radius: 0; box-shadow: 0 1px 1px rgba(0,0,0,0.1); color: #333; display: flex; align-items: center; gap: 8px; width: 290px; }
        .audio-player-container img { width: 40px; height: 40px; border-radius: 50%; }
        .audio-player-container .play-pause-btn { background: none; border: none; font-size: 1.5rem; color: #555; cursor: pointer; }
        .audio-player-container .progress-bar-container { flex-grow: 1; height: 4px; background-color: #ccc; border-radius: 2px; position: relative; cursor: pointer; }
        .audio-player-container .progress-bar { height: 100%; background-color: #666; border-radius: 2px; width: 0; position: relative; }
        .audio-player-container .progress-bar::after { content: ''; position: absolute; right: -6px; top: -4px; width: 12px; height: 12px; border-radius: 50%; background-color: #666; }
        .audio-player-container .time-info { display: flex; flex-direction: column; align-items: flex-end; font-size: 0.7em; color: #999; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        @keyframes mic-bounce { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
    </style>
    ${customScripts}
</head>
<body>
    <div id="preview-chat-container" style="display: flex; flex-direction: column; width: 100%; height: 100vh; overflow: hidden; background-color: #e5ddd5; background-image: url('https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png');"></div>
    
    <script id="flow-data" type="application/json">${safeFlowDataJSON}<\/script>

    <script>
        (function() {
            const flowData = JSON.parse(document.getElementById('flow-data').textContent);
            
            function getLiveVariables() { const now = new Date(); const hour = now.getHours(); const day = now.getDay(); const weekdays = ["domingo", "segunda-feira", "terça-feira", "quarta-feira", "quinta-feira", "sexta-feira", "sábado"]; let saudacao; if (hour >= 5 && hour < 12) { saudacao = "Bom dia"; } else if (hour >= 12 && hour < 18) { saudacao = "Boa tarde"; } else { saudacao = "Boa noite"; } return { saudacao: saudacao, dia_semana: weekdays[day] }; }
            function setupAudioPlayer(playerContainer) { const audio = playerContainer.querySelector('.hidden-audio'); const playBtn = playerContainer.querySelector('.play-pause-btn i'); const progressBar = playerContainer.querySelector('.progress-bar'); const currentTimeEl = playerContainer.querySelector('.current-time'); const totalTimeEl = playerContainer.querySelector('.total-time'); const formatTime = (time) => { const minutes = Math.floor(time / 60); const seconds = Math.floor(time % 60).toString().padStart(2, '0'); return \`\${minutes}:\${seconds}\`; }; audio.addEventListener('loadedmetadata', () => { if(totalTimeEl) totalTimeEl.textContent = formatTime(audio.duration); }); audio.addEventListener('timeupdate', () => { const progress = (audio.currentTime / audio.duration) * 100; progressBar.style.width = \`\${progress}%\`; currentTimeEl.textContent = formatTime(audio.currentTime); }); audio.addEventListener('ended', () => { playBtn.classList.remove('fa-pause'); playBtn.classList.add('fa-play'); progressBar.style.width = '0%'; }); playBtn.parentElement.addEventListener('click', () => { if (audio.paused) { audio.play(); playBtn.classList.remove('fa-play'); playBtn.classList.add('fa-pause'); } else { audio.pause(); playBtn.classList.remove('fa-pause'); playBtn.classList.add('fa-play'); } }); }
            function createPreviewComponent(element, variables = {}, profilePicUrl, flowData) { const type = element.type; const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }); const wrapper = document.createElement('div'); wrapper.style.cssText = "display: flex; flex-direction: column; align-items: flex-start; margin-bottom: 12px;"; let textContent = element.dataset.text || ''; for (const key in variables) { textContent = textContent.replace(new RegExp(\`{{\${key}}}\`, 'g'), variables[key]); } switch(type) { case 'delay': wrapper.innerHTML = \`<div style="align-self: flex-start; display: flex; align-items: center; padding: 10px 15px;"><span style="height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out;"></span><span style="height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out -1.1s;"></span><span style="height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out -0.9s;"></span></div><style>@keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }</style>\`; break; case 'audio-message': const audioUrl = element.dataset.url || 'data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA='; wrapper.innerHTML = \`<div class="audio-player-container"><img src="\${profilePicUrl}" onerror="this.src='https://placehold.co/40x40/777/FFFFFF?text=??'"><button class="play-pause-btn"><i class="fas fa-play"></i></button><div class="progress-bar-container"><div class="progress-bar"></div></div><div class="time-info"><span class="current-time">0:00</span><span class="timestamp">\${time}</span></div><audio class="hidden-audio" src="\${audioUrl}"></audio></div>\`; break; case 'video-message': const videoId = element.dataset.url.split('v=')[1]?.split('&')[0] || element.dataset.url.split('/').pop(); const videoFormat = element.dataset.format || 'landscape'; let videoHtml = ''; if (videoFormat === 'landscape') { videoHtml = \`<iframe style="width: 100%; aspect-ratio: 16/9; border-radius: 8px;" src="https://www.youtube.com/embed/\${videoId}" frameborder="0" allowfullscreen></iframe>\`; } else { videoHtml = \`<iframe style="width: 100%; aspect-ratio: 9/16; height: 300px; border-radius: 8px;" src="https://www.youtube.com/embed/\${videoId}" frameborder="0" allowfullscreen></iframe>\`; } wrapper.innerHTML = \`<div style="align-self: flex-start; max-width: 80%; background-color: transparent; padding: 5px; border-radius: 10px;">\${videoHtml}</div>\`; break; case 'direct-video-message': const directVideoFormat = element.dataset.format || 'landscape'; let directVideoHtml = ''; if (directVideoFormat === 'landscape') { directVideoHtml = \`<video controls style="width: 100%; aspect-ratio: 16/9; border-radius: 8px;"><source src="\${element.dataset.url}" type="video/mp4">Seu navegador não suporta vídeos.</video>\`; } else { directVideoHtml = \`<video controls style="width: 100%; aspect-ratio: 9/16; height: 300px; border-radius: 8px;"><source src="\${element.dataset.url}" type="video/mp4">Seu navegador não suporta vídeos.</video>\`; } wrapper.innerHTML = \`<div style="align-self: flex-start; max-width: 80%; background-color: transparent; padding: 5px; border-radius: 10px;">\${directVideoHtml}</div>\`; break; case 'image-message': wrapper.innerHTML = \`<div style="align-self: flex-start; max-width: 80%; background-color: #fff; padding: 5px; border-radius: 10px; border-top-left-radius: 0; box-shadow: 0 1px 1px rgba(0,0,0,0.1);"><img src="\${element.dataset.url}" style="width: 100%; border-radius: 8px;" alt="Imagem do fluxo" onerror="this.src='https://placehold.co/600x400/2A2A2A/EAEAEA?text=Erro!'"><span style="display: block; font-size: 0.7em; color: #999; text-align: right; padding: 0 5px 2px;">\${time}</span></div>\`; break; case 'cta-button': const color = element.dataset.color; const neon = element.dataset.neon === 'true' ? \`box-shadow: 0 0 10px \${color}, 0 0 20px \${color}80;\` : ''; wrapper.innerHTML = \`<div style="padding: 10px; align-self: center;"><a href="\${element.dataset.url}" target="_blank" class="cta-pixel-trigger" style="padding: 12px 24px; background-color: \${color}; color: #111; font-weight: bold; border-radius: 30px; text-decoration: none; \${neon}">\${textContent}</a></div>\`; wrapper.style.alignItems = 'center'; break; case 'user-input': wrapper.innerHTML = \`<div style="width: 100%; background-color: transparent; padding: 10px; display: flex; gap: 10px; margin-top: auto;"><input type="text" placeholder="\${element.dataset.placeholder}" class="preview-input" style="flex-grow: 1; border: none; padding: 12px 15px; border-radius: 20px; font-size: 1em; background-color: #fff; color: #000; box-shadow: 0 1px 2px rgba(0,0,0,0.1);"><button class="preview-send-btn" style="background-color: #075E54; color: white; border: none; border-radius: 50%; width: 45px; height: 45px; font-size: 1.2em; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"><i class="fa-solid fa-paper-plane"></i></button></div>\`; break; case 'sent-message': case 'ask-question': wrapper.style.alignItems = 'flex-start'; wrapper.innerHTML = \`<div style="max-width: 80%; background-color: #fff; padding: 10px 15px; border-radius: 10px; border-top-left-radius: 0; box-shadow: 0 1px 1px rgba(0,0,0,0.1); color: #333;">\${textContent}<span style="display: block; font-size: 0.7em; color: #999; text-align: right; margin-top: 5px;">\${time}</span></div>\`; if (type === 'ask-question') { const btnContainer = document.createElement('div'); btnContainer.style.cssText = "align-self: flex-start; display: flex; flex-wrap: wrap; gap: 10px; padding: 5px 0 10px 0;"; element.dataset.buttons.split(';').forEach((btnText, index) => { const button = document.createElement('button'); button.innerText = btnText; button.dataset.buttonIndex = index; button.style.cssText = "background-color: #fff; border: 1px solid #075E54; color: #075E54; padding: 8px 16px; border-radius: 20px; font-weight: bold; font-size: 0.9em; cursor: pointer; transition: background-color 0.2s;"; btnContainer.appendChild(button); }); wrapper.appendChild(btnContainer); } break; } return wrapper; }
            function createSentMessagePreview(text) { const time = new Date().toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }); const wrapper = document.createElement('div'); wrapper.style.cssText = "display: flex; flex-direction: column; align-items: flex-end; margin-bottom: 12px;"; wrapper.innerHTML = \`<div style="max-width: 80%; background-color: #dcf8c6; padding: 10px 15px; border-radius: 10px; border-top-right-radius: 0; box-shadow: 0 1px 1px rgba(0,0,0,0.1); color: #333;">\${text}<span style="display: block; font-size: 0.7em; color: #999; text-align: right; margin-top: 5px;">\${time}</span></div>\`; return wrapper; }
            async function runStandaloneFlow(flowData) { const chatContainer = document.getElementById('preview-chat-container'); chatContainer.innerHTML = \`<div style="background-color: #075E54; color: white; padding: 10px 15px; display: flex; align-items: center; gap: 15px; flex-shrink: 0;"><img src="\${flowData.settings.profilePicUrl}" alt="Foto" style="width: 45px; height: 45px; border-radius: 50%; border: 2px solid white; object-fit: cover;" onerror="this.src='https://placehold.co/45x45/075E54/FFFFFF?text=??'"><div><div style="font-weight: bold;">\${flowData.settings.chatName}</div><div style="font-size: 0.8em; color: #d1d1d1;">online</div></div></div><div id="preview-chat-body" style="flex-grow: 1; padding: 20px 10px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px;"></div>\`; const chatBody = document.getElementById('preview-chat-body'); const profilePicUrl = flowData.settings.profilePicUrl; const delay = ms => new Promise(res => setTimeout(res, ms)); const liveVariables = getLiveVariables(); const componentMap = new Map(flowData.components.map(c => [c.id, c])); const endNodeIds = new Set(flowData.connections.map(conn => conn.endId)); let startNodes = flowData.components.filter(c => !endNodeIds.has(c.id)); if (startNodes.length === 0 && flowData.components.length > 0) { startNodes.push(flowData.components[0]); } const askForName = async () => { return new Promise(resolve => { const questionHTML = \`<div style="max-width: 80%; background-color: #fff; padding: 10px 15px; border-radius: 10px; border-top-left-radius: 0; box-shadow: 0 1px 1px rgba(0,0,0,0.1); color: #333;">Qual é o seu nome?</div>\`; chatBody.innerHTML += questionHTML; const inputContainer = document.createElement('div'); inputContainer.innerHTML = \`<div style="width: 100%; background-color: transparent; padding: 10px; display: flex; gap: 10px; margin-top: auto;"><input type="text" placeholder="Digite seu nome..." class="preview-input" style="flex-grow: 1; border: none; padding: 12px 15px; border-radius: 20px; font-size: 1em; background-color: #fff; color: #000; box-shadow: 0 1px 2px rgba(0,0,0,0.1);"><button class="preview-send-btn" style="background-color: #075E54; color: white; border: none; border-radius: 50%; width: 45px; height: 45px; font-size: 1.2em; cursor: pointer; box-shadow: 0 1px 2px rgba(0,0,0,0.2);"><i class="fa-solid fa-paper-plane"></i></button></div>\`; chatBody.appendChild(inputContainer); const inputField = inputContainer.querySelector('.preview-input'); const sendButton = inputContainer.querySelector('.preview-send-btn'); inputField.focus(); const handleSend = () => { const userText = inputField.value || "Visitante"; inputContainer.remove(); chatBody.appendChild(createSentMessagePreview(userText)); chatBody.scrollTop = chatBody.scrollHeight; if (typeof fbq === 'function' && flowData.settings.pixelId) { fbq('track', 'Lead'); } resolve(userText); }; sendButton.onclick = handleSend; inputField.onkeypress = (e) => { if (e.key === 'Enter') handleSend(); }; }); }; const executeComponent = async (component) => { if (!component) return; const type = component.type; let nextComponentId = null; if ((component.dataset.text || '').includes('{{nome}}') && !liveVariables.nome) { liveVariables.nome = await askForName(); await delay(500); } if (type === 'delay') { const indicator = createPreviewComponent(component, liveVariables, profilePicUrl, flowData); chatBody.appendChild(indicator); chatBody.scrollTop = chatBody.scrollHeight; await delay(component.dataset.delay * 1000); indicator.remove(); } else { const indicator = createPreviewComponent({dataset: {componentType: 'delay'}}, liveVariables, profilePicUrl, flowData); chatBody.appendChild(indicator); chatBody.scrollTop = chatBody.scrollHeight; await delay(800); indicator.remove(); const previewElement = createPreviewComponent(component, liveVariables, profilePicUrl, flowData); chatBody.appendChild(previewElement); const ctaButton = previewElement.querySelector('.cta-pixel-trigger'); if (ctaButton) { ctaButton.addEventListener('click', () => { if (typeof fbq === 'function' && flowData.settings.pixelId) { fbq('track', 'Contact'); } }); } if(previewElement.querySelector('.audio-player-container')) setupAudioPlayer(previewElement); chatBody.scrollTop = chatBody.scrollHeight; await delay(500); } if (type === 'ask-question') { const chosenIndex = await new Promise(resolve => { const buttons = chatBody.querySelectorAll('button[data-button-index]'); buttons.forEach(button => { button.addEventListener('click', (e) => { chatBody.appendChild(createSentMessagePreview(e.target.innerText)); buttons.forEach(btn => { btn.disabled = true; btn.style.cursor = 'not-allowed'; }); if (typeof fbq === 'function' && flowData.settings.pixelId) { fbq('trackCustom', 'QuestionResponse', { question: component.dataset.text.substring(0, 100), response: e.target.innerText.substring(0, 100) }); } setTimeout(() => { chatBody.scrollTop = chatBody.scrollHeight; resolve(e.target.dataset.buttonIndex) }, 500); }, { once: true }); }); }); const connection = flowData.connections.find(c => c.startId === component.id && c.startIndex == chosenIndex); if (connection) nextComponentId = connection.endId; } else if (type === 'user-input') { await new Promise(resolve => { const inputContainer = chatBody.lastElementChild; const inputField = inputContainer.querySelector('.preview-input'); const sendButton = inputContainer.querySelector('.preview-send-btn'); inputField.disabled = false; inputField.focus(); const handleSend = () => { const userText = inputField.value || "Resposta simulada"; inputContainer.remove(); chatBody.appendChild(createSentMessagePreview(userText)); chatBody.scrollTop = chatBody.scrollHeight; if (typeof fbq === 'function' && flowData.settings.pixelId) { fbq('track', 'Lead'); } resolve(); }; sendButton.onclick = handleSend; inputField.onkeypress = (e) => { if (e.key === 'Enter') handleSend(); }; }); const connection = flowData.connections.find(c => c.startId === component.id); if (connection) nextComponentId = connection.endId; } else { const connection = flowData.connections.find(c => c.startId === component.id); if (connection) nextComponentId = connection.endId; } if (nextComponentId) { await executeComponent(componentMap.get(nextComponentId)); } }; for (const node of startNodes) { await executeComponent(node); } }
            
            function injectCustomScripts() {
                try {
                    const customScriptsData = document.getElementById('custom-scripts-data');
                    if (!customScriptsData) return;
                    const customScriptsContent = customScriptsData.textContent || "";
                    
                    if (customScriptsContent.trim()) {
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = customScriptsContent;
                        const scripts = Array.from(tempDiv.querySelectorAll('script'));
                        const fragment = document.createDocumentFragment();

                        scripts.forEach(script => {
                            const newScript = document.createElement('script');
                            for (let i = 0; i < script.attributes.length; i++) {
                                const attr = script.attributes[i];
                                newScript.setAttribute(attr.name, attr.value);
                            }
                            if (script.innerHTML) {
                                newScript.appendChild(document.createTextNode(script.innerHTML));
                            }
                            fragment.appendChild(newScript);
                        });
                        document.head.appendChild(fragment);
                    }
                } catch (e) {
                    console.error("Erro ao carregar script customizado:", e);
                }
            }

            document.addEventListener('DOMContentLoaded', () => {
                const flowData = JSON.parse(document.getElementById('flow-data').textContent);
                runStandaloneFlow(flowData);
                injectCustomScripts();
            });
        })();
    <\/script>
</body>
</html>`;
        }
        
        function exportHTML() {
            const htmlContent = generateStandaloneHTML();
            const blob = new Blob([htmlContent.trim()], { type: 'text/html' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'funil-zaapflow.html';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function copyHTML() {
            const htmlContent = generateStandaloneHTML();
            const textarea = document.createElement('textarea');
            textarea.value = htmlContent;
            document.body.appendChild(textarea);
            textarea.select();
            try {
                document.execCommand('copy');
                showToast('HTML copiado para a área de transferência!');
            } catch (err) {
                showToast('Erro ao copiar o HTML.');
                console.error('Falha ao copiar HTML: ', err);
            }
            document.body.removeChild(textarea);
        }

        function downloadForNetlify() {
            const htmlContent = generateStandaloneHTML();
            const zip = new JSZip();
            zip.file("index.html", htmlContent);
            zip.generateAsync({type:"blob"}).then(function(content) {
                const url = URL.createObjectURL(content);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'zaapflow-project.zip';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showToast('Projeto .zip pronto para Netlify!');
            });
        }

        document.getElementById('export-btn').addEventListener('click', exportFlow);
        document.getElementById('import-btn').addEventListener('click', triggerImport);
        document.getElementById('import-file-input').addEventListener('change', handleFileImport);
        document.getElementById('copy-html-btn').addEventListener('click', copyHTML);
        document.getElementById('download-zip-btn').addEventListener('click', downloadForNetlify);

        updatePreview();
    });
    </script>
</body>
</html>
