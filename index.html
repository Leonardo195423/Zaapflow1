<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZAPFLOW - Chat Interativo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --panel-color: #16213e;
            --canvas-color: #0f1524;
            --primary-accent: #e94560;
            --secondary-accent: #4fc3f7;
            --success-color: #25D366;
            --warning-color: #f7b731;
            --text-light: #e0e0e0;
            --border-color: #2c3e50;
            --shadow-color: rgba(0, 0, 0, 0.4);
            --connector-color: #6c757d; /* Default connector color */
            --button-hover-dark: #c33a50; /* Darker primary accent for hover */
            --button-hover-light: #6ad1fc; /* Lighter secondary accent for hover */
        }

        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh; /* Garante que o corpo ocupe toda a altura da viewport */
            display: flex;
        }

        .hidden { display: none !important; }

        /* --- TELA DE LOGIN --- */
        #login-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background-image: url('https://i.ibb.co/B5CH90Vp/Chat-GPT-Image-29-de-jun-de-2025-23-12-16.png');
            background-size: cover; background-position: center;
            z-index: 1000;
        }
        #login-box {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 40px; border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            width: 100%; max-width: 400px; text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #login-box h2 { font-size: 2.5rem; margin-bottom: 10px; color: #fff; }
        #login-box p { color: #ccc; margin-bottom: 30px; }
        .input-group { margin-bottom: 20px; text-align: left; }
        .input-group label { display: block; margin-bottom: 8px; color: #ccc; }
        .input-group input { width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: #fff; font-size: 1rem; }
        .input-group input:focus { outline: none; border-color: var(--primary-accent); }
        #login-button { width: 100%; padding: 15px; background: var(--primary-accent); border: none; border-radius: 8px; color: #fff; font-size: 1.2rem; font-weight: bold; cursor: pointer; transition: background-color 0.3s; }
        #login-button:hover { background-color: var(--button-hover-dark); }
        #login-error { color: #ff5555; margin-top: 15px; height: 20px; }

        /* --- LAYOUT PRINCIPAL DA APLICA√á√ÉO --- */
        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr 420px;
            width: 100%;
            height: 100%;
            gap: 10px;
            padding: 10px;
        }

        .panel {
            background-color: var(--panel-color);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 15px var(--shadow-color);
            z-index: 10;
        }
        .panel-header {
            font-size: 1.4em;
            font-weight: 700;
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            color: var(--primary-accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Impede que o cabe√ßalho encolha */
        }
        .panel-header i { margin-right: 10px; }
        #logout-button { background: none; border: none; color: var(--primary-accent); cursor: pointer; font-size: 1.2rem; }
        #logout-button:hover { color: var(--button-hover-dark); }
        
        /* --- PAINEL LATERAL DE BLOCOS --- */
        #side-panel {
            overflow-y: auto; /* Permite rolagem vertical */
        }
        #side-panel .node-template {
            background-color: var(--canvas-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: grab;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: 500;
            font-size: 0.95em;
        }
        #side-panel .node-template:hover {
            background-color: #2c3e50;
            transform: translateY(-2px);
        }
        #side-panel .node-template i {
            margin-right: 10px;
            color: var(--secondary-accent);
            width: 20px;
            text-align: center;
        }
        #side-panel .controls {
            margin-top: auto; /* Empurra os controles para o final do painel */
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            flex-shrink: 0; /* Impede que os controles encolham */
        }
        .control-btn {
            padding: 12px 10px;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            font-size: 0.9em;
        }
        .control-btn:hover { transform: translateY(-2px); }
        #run-flow-btn { background-color: var(--primary-accent); grid-column: 1 / -1; }
        #run-flow-btn:hover { background-color: var(--button-hover-dark); }
        #clear-flow-btn { background-color: #555; }
        #clear-flow-btn:hover { background-color: #777; }
        #download-html-btn { background-color: var(--success-color); }
        #download-html-btn:hover { background-color: #128C7E; }
        #import-flow-btn { background-color: var(--warning-color); }
        #import-flow-btn:hover { background-color: #f7a000; }
        #export-flow-btn { background-color: var(--secondary-accent); }
        #export-flow-btn:hover { background-color: var(--button-hover-light); }
        
        /* --- CANVAS CENTRAL --- */
        #canvas-container {
            position: relative;
            background-color: var(--canvas-color);
            background-image: radial-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 20px 20px;
            border-radius: 12px;
            overflow: hidden;
            cursor: grab;
        }
        #canvas-container:active { cursor: grabbing; }

        #flow-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            transform-origin: 0 0;
        }
        
        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* --- BLOCOS NO CANVAS --- */
        .flow-node {
            position: absolute;
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 240px;
            min-height: 80px;
            box-shadow: 0 4px 12px var(--shadow-color);
            cursor: move;
            transition: box-shadow 0.3s, border-color 0.3s;
            display: flex;
            flex-direction: column;
            z-index: 5; /* Ensure nodes are above SVG lines by default */
        }
        .flow-node.selected {
            border-color: var(--primary-accent);
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
            z-index: 6; /* Bring selected node to front */
        }
        .flow-node.dragging {
            z-index: 9999 !important; /* Extremely high z-index to ensure it's always on top */
        }

        .node-header {
            background-color: #2c3e50;
            color: var(--text-light);
            padding: 8px 10px;
            font-weight: bold;
            border-top-left-radius: 7px;
            border-top-right-radius: 7px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .node-header i { margin-right: 8px; }
        .delete-node-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 1em;
            cursor: pointer;
            margin-left: 10px;
            transition: color 0.2s;
        }
        .delete-node-btn:hover {
            color: var(--primary-accent);
        }

        .node-content {
            padding: 10px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .node-content textarea, .node-content input {
            width: 100%;
            background-color: var(--canvas-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-light);
            padding: 8px;
            resize: vertical;
        }
        .node-content textarea { min-height: 40px; }
        .node-content textarea:focus, .node-content input:focus {
            outline: none;
            border-color: var(--secondary-accent);
        }
        .node-content label {
            font-size: 0.8em;
            color: var(--text-light-muted, #aaa);
            margin-bottom: -4px;
        }
        /* Specific node type styles */
        .flow-node[data-type="start"] { border-color: var(--success-color); }
        .flow-node[data-type="start"] .node-header { background-color: #128C7E; }
        .flow-node[data-type="end"] { border-color: #f7b731; }
        .flow-node[data-type="end"] .node-header { background-color: #e09f25; }
        .flow-node[data-type="question"], .flow-node[data-type="multipleChoice"] { border-color: var(--secondary-accent); }
        .flow-node[data-type="question"] .node-header, .flow-node[data-type="multipleChoice"] .node-header { background-color: #3b5998; }
        
        .connector {
            width: 16px; height: 16px;
            background-color: #fff;
            border: 2px solid var(--connector-color);
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            transition: background-color 0.3s, border-color 0.3s;
            z-index: 10; /* Keep connectors on top of node content */
        }
        .connector:hover { 
            background-color: var(--primary-accent); 
            border-color: var(--primary-accent); /* Highlight border on hover */
        }
        .connector.highlight-target {
            background-color: var(--secondary-accent) !important;
            border-color: var(--primary-accent) !important;
            box-shadow: 0 0 8px rgba(233, 69, 96, 0.7);
        }
        .connector.output { right: -8px; }
        .connector.input { left: -8px; top: 50%; transform: translateY(-50%); }

        .button-option { display: flex; align-items: center; gap: 5px; }
        .button-option input { flex-grow: 1; }
        .remove-btn { cursor: pointer; color: #e94560; }
        .remove-btn:hover { color: var(--button-hover-dark); }
        .add-btn {
            background: none; border: 1px dashed var(--connector-color); color: var(--connector-color);
            padding: 5px; border-radius: 4px; cursor: pointer; margin-top: 5px;
        }
        .add-btn:hover { background-color: rgba(255,255,255,0.05); }

        /* --- PR√â-VISUALIZA√á√ÉO (CELULAR) --- */
        #preview-panel { align-items: center; justify-content: center; }
        .mobile-preview {
            width: 100%; max-width: 380px; height: 95%; background-color: #111;
            border-radius: 40px; border: 10px solid #000; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; overflow: hidden;
        }
        .chat-header {
            background-color: #075E54; color: white; padding: 10px 15px; display: flex;
            align-items: center; gap: 15px; flex-shrink: 0;
        }
        .chat-header img { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; }
        .chat-header .name { font-weight: bold; }
        .chat-header .status { font-size: 0.8em; color: #d1d1d1; }
        .chat-body {
            flex-grow: 1; padding: 15px 10px; overflow-y: auto; display: flex; flex-direction: column;
            gap: 12px; background-color: #e5ddd5;
            background-image: url('https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png');
        }
        .message { max-width: 80%; padding: 8px 12px; border-radius: 8px; line-height: 1.4; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .message.received { background-color: #ffffff; align-self: flex-start; color: black; /* Alterado para preto */ }
        .message.sent { background-color: #dcf8c6; align-self: flex-end; color: black; /* Alterado para preto */ }
        .message img { max-width: 100%; border-radius: 8px; margin-top: 5px; }
        .typing-indicator { align-self: flex-start; padding: 10px 15px; display: flex; align-items: center; justify-content: center; background-color: #ffffff; border-radius: 8px; max-width: 80px; }
        .typing-indicator span { height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out; }
        .typing-indicator span:nth-child(2) { animation-delay: 0.1s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.2s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        .choice-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; padding: 5px 10px; align-self: flex-end; }
        .choice-button { background-color: #fff; border: 1px solid #075E54; color: #075E54; padding: 8px 15px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: background-color 0.2s, color 0.2s; }
        .choice-button:hover { background-color: #075E54; color: white; }
        .cta-button-container { padding: 10px; align-self: stretch; }
        .cta-button { background: linear-gradient(45deg, #25D366, #128C7E); color: white; text-align: center; text-decoration: none; font-size: 1.1em; font-weight: bold; padding: 15px; border-radius: 30px; display: block; transition: transform 0.2s; }
        .cta-button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .user-input-container { display: flex; gap: 5px; margin-top: 10px; align-self: stretch; }
        .user-input-container input { flex-grow: 1; padding: 8px; border-radius: 20px; border: 1px solid #ccc; }
        .user-input-container button { padding: 8px 15px; border-radius: 20px; border: none; background-color: #075E54; color: white; cursor: pointer; }


        /* --- CUSTOM MODAL --- */
        .custom-modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000;
        }
        .custom-modal {
            background-color: var(--panel-color);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 20px var(--shadow-color);
            max-width: 450px;
            width: 90%;
            text-align: center;
            border: 1px solid var(--border-color);
        }
        .custom-modal h3 {
            color: var(--primary-accent);
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        .custom-modal p {
            color: var(--text-light);
            margin-bottom: 30px;
            line-height: 1.5;
        }
        .custom-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .custom-modal-buttons button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        .custom-modal-buttons .confirm-btn {
            background-color: var(--primary-accent);
            color: white;
        }
        .custom-modal-buttons .confirm-btn:hover {
            background-color: var(--button-hover-dark);
            transform: translateY(-2px);
        }
        .custom-modal-buttons .cancel-btn {
            background-color: #555;
            color: white;
        }
        .custom-modal-buttons .cancel-btn:hover {
            background-color: #777;
            transform: translateY(-2px);
        }

        /* New styles for Bot Settings */
        .bot-settings {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0; /* Impede que as configura√ß√µes do bot encolham */
        }
        .bot-settings .input-group {
            margin-bottom: 15px;
        }
    </style>
</head>
<body>

    <!-- TELA DE LOGIN -->
    <div id="login-screen">
        <div id="login-box">
            <h2>Bem-vindo ao ZAPFLOW</h2>
            <p>Fa√ßa login para aceder ao Flow Builder</p>
            <form id="login-form">
                <div class="input-group">
                    <label for="username">Utilizador</label>
                    <input type="text" id="username" value="admin" required>
                </div>
                <div class="input-group">
                    <label for="password">Senha</label>
                    <input type="password" id="password" value="admin123" required>
                </div>
                <div id="login-error"></div>
                <button type="submit" id="login-button">Entrar</button>
            </form>
        </div>
    </div>

    <!-- APLICA√á√ÉO PRINCIPAL (INICIALMENTE OCULTA) -->
    <div id="app-container" class="app-container hidden">
        <div id="side-panel" class="panel">
            <div class="panel-header">
                <span><i class="fas fa-sitemap"></i> Blocos do Fluxo</span>
                <button id="logout-button" title="Sair"><i class="fas fa-sign-out-alt"></i></button>
            </div>
            <!-- Novo: N√≥ de In√≠cio Arrast√°vel -->
            <div class="node-template" draggable="true" data-type="start">
                <i class="fas fa-flag-checkered"></i> In√≠cio do Fluxo
            </div>
            <div class="node-template" draggable="true" data-type="message">
                <i class="fas fa-comment-dots"></i> Mensagem do Bot
            </div>
            <div class="node-template" draggable="true" data-type="image">
                <i class="fas fa-image"></i> Imagem
            </div>
            <div class="node-template" draggable="true" data-type="question">
                <i class="fas fa-question-circle"></i> Pergunta (Sim/N√£o)
            </div>
            <div class="node-template" draggable="true" data-type="multipleChoice">
                <i class="fas fa-check-double"></i> M√∫ltiplas Escolhas
            </div>
            <div class="node-template" draggable="true" data-type="userInput">
                <i class="fas fa-keyboard"></i> Entrada do Utilizador
            </div>
            <div class="node-template" draggable="true" data-type="delay">
                <i class="fas fa-clock"></i> Atraso / Pausa
            </div>
            <div class="node-template" draggable="true" data-type="cta">
                <i class="fas fa-rocket"></i> Bot√£o Final (CTA)
            </div>
            <!-- Novo: N√≥ de Fim Arrast√°vel -->
            <div class="node-template" draggable="true" data-type="end">
                <i class="fas fa-stop-circle"></i> Fim do Fluxo
            </div>

            <!-- Bot Settings Section -->
            <div class="bot-settings">
                <div class="panel-header">
                    <span><i class="fas fa-robot"></i> Configura√ß√µes do Bot</span>
                </div>
                <div class="input-group">
                    <label for="bot-name-input">Nome do Bot</label>
                    <input type="text" id="bot-name-input" placeholder="Nome do Bot">
                </div>
                <div class="input-group">
                    <label for="bot-profile-pic-input">URL da Foto de Perfil</label>
                    <input type="text" id="bot-profile-pic-input" placeholder="https://exemplo.com/bot.png">
                </div>
            </div>

            <div class="controls">
                <button id="run-flow-btn" class="control-btn"><i class="fas fa-play"></i> Testar Fluxo</button>
                <button id="import-flow-btn" class="control-btn"><i class="fas fa-upload"></i> Importar Fluxo</button>
                <button id="export-flow-btn" class="control-btn"><i class="fas fa-download"></i> Exportar Fluxo</button>
                <button id="clear-flow-btn" class="control-btn"><i class="fas fa-trash-alt"></i> Limpar</button>
                <button id="download-html-btn" class="control-btn"><i class="fas fa-code"></i> Baixar HTML</button>
                <input type="file" id="import-file-input" style="display: none;" accept=".json">
            </div>
        </div>

        <div id="canvas-container">
            <div id="flow-canvas">
                <svg id="svg-layer">
                </svg>
            </div>
        </div>

        <div id="preview-panel" class="panel">
            <div class="panel-header"><i class="fas fa-mobile-alt"></i> Pr√©-visualiza√ß√£o</div>
            <div class="mobile-preview">
                <div class="chat-header">
                    <img id="preview-bot-avatar" src="https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png" alt="Atendente">
                    <div class="contact-info">
                        <div id="preview-bot-name" class="name">ZAPFLOW BOT</div>
                        <div class="status">online</div>
                    </div>
                </div>
                <div class="chat-body" id="preview-chat-body"></div>
            </div>
        </div>
    </div>

    <!-- CUSTOM MODAL HTML -->
    <div id="custom-modal-overlay" class="custom-modal-overlay hidden">
        <div class="custom-modal">
            <h3 id="modal-title"></h3>
            <p id="modal-message"></p>
            <div class="custom-modal-buttons">
                <button id="modal-confirm-btn" class="confirm-btn">Confirmar</button>
                <button id="modal-cancel-btn" class="cancel-btn">Cancelar</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- CUSTOM MODAL LOGIC ---
        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        let onConfirmCallback;
        let onCancelCallback;

        /**
         * Displays a custom confirmation modal.
         * @param {string} title - The modal title.
         * @param {string} message - The message to display in the modal.
         * @param {function} onConfirm - Callback function to execute if confirmed.
         * @param {function} [onCancel] - Optional callback function to execute if cancelled.
         */
        function showConfirmModal(title, message, onConfirm, onCancel) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            onConfirmCallback = onConfirm;
            onCancelCallback = onCancel;
            
            modalCancelBtn.classList.remove('hidden'); // Ensure cancel button is visible

            modalConfirmBtn.onclick = () => {
                modalOverlay.classList.add('hidden');
                if (onConfirmCallback) onConfirmCallback();
            };
            modalCancelBtn.onclick = () => {
                modalOverlay.classList.add('hidden');
                if (onCancelCallback) onCancelCallback();
            };

            modalOverlay.classList.remove('hidden');
        }

        /**
         * Displays a custom alert modal (only confirmation button).
         * @param {string} title - The modal title.
         * @param {string} message - The message to display in the modal.
         * @param {function} [onClose] - Optional callback function to execute when closed.
         */
        function showAlertModal(title, message, onClose) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalCancelBtn.classList.add('hidden'); // Hide cancel button for alerts
            
            onConfirmCallback = onClose; // Use confirm button to close alert
            modalConfirmBtn.onclick = () => {
                modalOverlay.classList.add('hidden');
                modalCancelBtn.classList.remove('hidden'); // Show cancel button for next use
                if (onConfirmCallback) onConfirmCallback();
            };

            modalOverlay.classList.remove('hidden');
        }


        // --- LOGIN LOGIC ---
        const loginScreen = document.getElementById('login-screen');
        const appContainer = document.getElementById('app-container');
        const loginForm = document.getElementById('login-form');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const loginError = document.getElementById('login-error');
        const logoutButton = document.getElementById('logout-button');

        loginForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const username = usernameInput.value;
            const password = passwordInput.value;

            if (username === 'admin' && password === 'admin123') {
                loginScreen.classList.add('hidden');
                appContainer.classList.remove('hidden');
                initFlowBuilder(); // Initialize builder ONLY after login
            } else {
                loginError.textContent = 'Utilizador ou senha inv√°lidos.';
                setTimeout(() => loginError.textContent = '', 3000);
            }
        });

        logoutButton.addEventListener('click', () => {
            showConfirmModal('Sair?', 'Tem a certeza que deseja sair?',
                () => {
                    loginScreen.classList.remove('hidden');
                    appContainer.classList.add('hidden');
                }
            );
        });
        
        // --- START OF FLOW BUILDER CODE ---
        function initFlowBuilder() {
            const sidePanel = document.getElementById('side-panel'),
                canvasContainer = document.getElementById('canvas-container'),
                flowCanvas = document.getElementById('flow-canvas'),
                svgLayer = document.getElementById('svg-layer'),
                runFlowBtn = document.getElementById('run-flow-btn'),
                clearFlowBtn = document.getElementById('clear-flow-btn'),
                downloadHtmlBtn = document.getElementById('download-html-btn'),
                previewChatBody = document.getElementById('preview-chat-body'),
                importFlowBtn = document.getElementById('import-flow-btn'),
                exportFlowBtn = document.getElementById('export-flow-btn'),
                importFileInput = document.getElementById('import-file-input');

            // New bot settings elements
            const botNameInput = document.getElementById('bot-name-input');
            const botProfilePicInput = document.getElementById('bot-profile-pic-input');
            const previewBotName = document.getElementById('preview-bot-name');
            const previewBotAvatar = document.getElementById('preview-bot-avatar');

            let nodes = {}, connections = [], nodeIdCounter = 0, selectedNodeId = null,
                isConnecting = false, connectionStart = {};
            let pan = { x: 0, y: 0, scale: 1, isPanning: false, startX: 0, startY: 0 };
            let currentTempLine = null;
            let hoveredInputConnector = null;

            // --- ZOOM AND PAN LOGIC ---
            canvasContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvasContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const oldScale = pan.scale;
                const newScale = oldScale * (e.deltaY > 0 ? 0.9 : 1.1);
                pan.scale = Math.max(0.2, Math.min(newScale, 2));

                // Adjust pan so zoom is centered on mouse pointer
                pan.x = mouseX - (mouseX - pan.x) * (pan.scale / oldScale);
                pan.y = mouseY - (mouseY - pan.y) * (pan.scale / oldScale);
                
                updateCanvasTransform();
            });

            canvasContainer.addEventListener('mousedown', (e) => {
                // If click is on a node or connector, do not start canvas pan.
                if (e.target.closest('.flow-node')) {
                    const clickedNode = e.target.closest('.flow-node');
                    // Only select the node if the click is not on an input/textarea/connector/delete button,
                    // otherwise, allow interaction with the child element.
                    if (e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'INPUT' && !e.target.classList.contains('connector') && !e.target.classList.contains('delete-node-btn')) {
                        selectNode(clickedNode.id);
                    }
                    return; // Allow makeNodeDraggable or handleConnectorClick to handle the event
                }
                
                selectNode(null); // Deselect any node when starting canvas pan
                pan.isPanning = true;
                pan.startX = e.clientX;
                pan.startY = e.clientY; 
            });

            canvasContainer.addEventListener('mousemove', (e) => {
                if (!pan.isPanning) return;
                pan.x += e.clientX - pan.startX;
                pan.y += e.clientY - pan.startY;
                pan.startX = e.clientX;
                pan.startY = e.clientY; 
                updateCanvasTransform();
            });

            canvasContainer.addEventListener('mouseup', () => pan.isPanning = false);
            canvasContainer.addEventListener('mouseleave', () => pan.isPanning = false);

            function updateCanvasTransform() {
                flowCanvas.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${pan.scale})`;
                redrawAllConnections(); 
            }

            // Converts screen coordinates to canvas coordinates (untransformed)
            function toCanvasCoords(e) {
                const rect = flowCanvas.getBoundingClientRect(); // Use flowCanvas rect as it's the transformed one
                const xOnCanvas = e.clientX - rect.left;
                const yOnCanvas = e.clientY - rect.top;
                return {
                    x: xOnCanvas / pan.scale, // Un-scale relative to flowCanvas's internal coords
                    y: yOnCanvas / pan.scale  // Un-scale relative to flowCanvas's internal coords
                };
            }

            // --- DRAG & DROP LOGIC ---
            // Add listener to drag node templates from side panel
            sidePanel.querySelectorAll('.node-template').forEach(template => {
                template.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', e.target.dataset.type);
                    e.dataTransfer.setDragImage(new Image(), 0, 0); // Hide the default drag image
                });
            });

            // Allow dropping on canvas
            canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
            canvasContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                const type = e.dataTransfer.getData('text/plain');
                if (!type) return; // If no type, it's not a template drag
                const coords = toCanvasCoords(e);
                createNode(type, coords.x, coords.y);
            });

            // --- BLOCK CREATION ---
            /**
             * Creates a new block (node) on the canvas.
             * @param {string} type - The type of the node (e.g., 'message', 'question').
             * @param {number} x - X position on canvas.
             * @param {number} y - Y position on canvas.
             * @param {string|null} id - Optional ID for the node (used when loading state).
             * @param {Array<string>} content - Initial node content.
             * @returns {HTMLElement} The created node element.
             */
            function createNode(type, x, y, id = null, content = []) {
                const nodeId = id || `node-${nodeIdCounter++}`;
                const nodeEl = document.createElement('div');
                nodeEl.className = 'flow-node';
                nodeEl.id = nodeId;
                nodeEl.dataset.type = type;
                nodeEl.style.left = `${x}px`;
                nodeEl.style.top = `${y}px`;

                let headerText = '', headerIcon = '', contentHtml = '';
                let hasInputConnector = true, hasOutputConnector = true;

                switch(type) {
                    case 'start':
                        headerText = 'In√≠cio';
                        headerIcon = 'fa-flag-checkered';
                        contentHtml = `<p style="text-align:center;">Ponto de partida do fluxo</p>`;
                        hasInputConnector = false; // No input
                        break;
                    case 'end': // New 'end' node type
                        headerText = 'Fim';
                        headerIcon = 'fa-stop-circle';
                        contentHtml = `<p style="text-align:center;">Ponto final do fluxo</p>`;
                        hasOutputConnector = false; // No output
                        break;
                    case 'message':
                        headerText = 'Mensagem';
                        headerIcon = 'fa-comment-dots';
                        contentHtml = `<label>Texto da Mensagem:</label><textarea placeholder="Digite a mensagem do bot">${content[0] || ''}</textarea>`;
                        break;
                    case 'image':
                        headerText = 'Imagem';
                        headerIcon = 'fa-image';
                        contentHtml = `<label>URL da Imagem:</label><textarea placeholder="https://exemplo.com/imagem.png">${content[0] || ''}</textarea>`;
                        break;
                    case 'question':
                        headerText = 'Pergunta (Sim/N√£o)';
                        headerIcon = 'fa-question-circle';
                        contentHtml = `<label>Texto da Pergunta:</label><textarea placeholder="Fa√ßa uma pergunta (Sim/N√£o)">${content[0] || ''}</textarea>`;
                        break;
                    case 'userInput':
                        headerText = 'Entrada do Utilizador';
                        headerIcon = 'fa-keyboard';
                        contentHtml = `
                            <label>Texto da Pergunta:</label>
                            <textarea placeholder="Pergunte algo ao utilizador">${content[0] || ''}</textarea>
                            <label>Vari√°vel para Salvar:</label>
                            <input type="text" placeholder="Nome da vari√°vel (ex: nome)" value="${content[1] || ''}">
                        `;
                        break;
                    case 'delay':
                        headerText = 'Atraso / Pausa';
                        headerIcon = 'fa-clock';
                        contentHtml = `<label>Dura√ß√£o do Atraso (ms):</label><input type="number" placeholder="1500" value="${content[0] || '1500'}">`;
                        break;
                    case 'cta':
                        headerText = 'Bot√£o Final (CTA)';
                        headerIcon = 'fa-rocket';
                        contentHtml = `
                            <label>Texto do Bot√£o:</label><textarea placeholder="Comprar Agora">${content[0] || 'Comprar Agora'}</textarea>
                            <label>URL do Link:</label><textarea placeholder="https://seusite.com">${content[1] || ''}</textarea>
                        `;
                        hasOutputConnector = false; // No output
                        break;
                    case 'multipleChoice':
                        headerText = 'M√∫ltiplas Escolhas';
                        headerIcon = 'fa-check-double';
                        let buttonsHtml = '';
                        // First content item is the question, rest are options
                        const options = content.length > 1 ? content.slice(1) : ['Op√ß√£o 1'];
                        buttonsHtml = options.map((text, i) =>
                            `<div class="button-option" data-index="${i}"><input type="text" value="${text}"><i class="fas fa-times remove-btn"></i></div>`
                        ).join('');
                        
                        contentHtml = `
                            <label>Texto da Pergunta:</label>
                            <textarea placeholder="Fa√ßa uma pergunta com op√ß√µes">${content[0] || ''}</textarea>
                            <label>Op√ß√µes:</label>
                            <div id="buttons-container">${buttonsHtml}</div>
                            <button class="add-btn"><i class="fas fa-plus"></i> Adicionar Op√ß√£o</button>
                        `;
                        break;
                    default:
                        headerText = 'Tipo Desconhecido';
                        headerIcon = 'fa-times-circle';
                        contentHtml = `<p>Tipo de n√≥ desconhecido: ${type}</p>`;
                        break;
                }

                nodeEl.innerHTML = `
                    <div class="node-header"><i class="fas ${headerIcon}"></i> ${headerText} <i class="fas fa-trash-alt delete-node-btn"></i></div>
                    <div class="node-content">${contentHtml}</div>
                `;
                
                // Add input connectors
                if (hasInputConnector) {
                    nodeEl.insertAdjacentHTML('beforeend', `<div class="connector input"></div>`);
                }
                
                // Add output connectors
                if (hasOutputConnector) {
                    if (type === 'question') {
                        // Specific connectors for Yes/No
                        nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" data-choice="yes" style="top: 35%;"></div>`);
                        nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" data-choice="no" style="top: 65%;"></div>`);
                    } else if (type === 'multipleChoice') {
                        // Connectors for multiple choice are added dynamically
                        // `updateMultipleChoiceConnectors` will be called right after node creation
                    } else {
                        // Standard output connector for other node types
                        nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" style="top: 50%; transform: translateY(-50%);"></div>`);
                    }
                }

                flowCanvas.appendChild(nodeEl); // Add the node directly to flowCanvas

                // Initialize or update node data
                nodes[nodeId] = {
                    id: nodeId,
                    el: nodeEl,
                    type: type,
                    x: x,
                    y: y,
                    // Ensure content is correctly initialized
                    content: content.length > 0 ? content : (type === 'multipleChoice' ? ['Nova Pergunta?', 'Op√ß√£o 1'] : [''])
                };
                // Update content for userInput and cta, which have multiple fields
                if (type === 'userInput') {
                    nodes[nodeId].content = [content[0] || '', content[1] || ''];
                } else if (type === 'cta') {
                    nodes[nodeId].content = [content[0] || 'Comprar Agora', content[1] || ''];
                } else if (type === 'delay') {
                    nodes[nodeId].content = [content[0] || '1500'];
                }


                // For multiple choice nodes, update connectors and content
                if (type === 'multipleChoice') {
                    // Ensure content[0] is the question and the rest are options
                    if (content.length === 0) {
                        nodes[nodeId].content = ['Nova Pergunta?', 'Op√ß√£o 1'];
                    } else if (content.length === 1) {
                        nodes[nodeId].content = [content[0], 'Op√ß√£o 1'];
                    }
                    updateMultipleChoiceConnectors(nodeEl, nodes[nodeId].content.length - 1);
                }

                makeNodeDraggable(nodeEl);
                setupNodeEventListeners(nodeEl);
                if (!id) saveState(); // Save state only if it's a new node
                return nodeEl;
            }

            /**
             * Updates output connectors for multiple choice nodes.
             * Recalculates their positions based on the number of options.
             * @param {HTMLElement} nodeEl - The node element.
             * @param {number} count - The number of options (and thus output connectors).
             */
            function updateMultipleChoiceConnectors(nodeEl, count) {
                // Remove existing output connectors to redraw
                nodeEl.querySelectorAll('.connector.output').forEach(c => c.remove());
                
                // Force a reflow to ensure offsetHeight is accurate
                nodeEl.offsetHeight; 

                const headerHeight = nodeEl.querySelector('.node-header').offsetHeight;
                const nodeContentEl = nodeEl.querySelector('.node-content');
                const contentPaddingTop = parseFloat(window.getComputedStyle(nodeContentEl).paddingTop);
                
                // Calculate position of connectors relative to the top of `node-content`
                let currentY = headerHeight + contentPaddingTop; // Starts after header and content top padding
                const questionTextarea = nodeEl.querySelector('.node-content > textarea');
                if (questionTextarea) {
                    currentY += questionTextarea.offsetHeight + 8; // Height of textarea + gap
                }
                
                nodeEl.querySelectorAll('.button-option').forEach((optionDiv, i) => {
                    const connector = document.createElement('div');
                    connector.className = 'connector output';
                    connector.dataset.choice = i; // Stores the option index
                    
                    // Vertical position of connector: center of the option div
                    connector.style.top = `${currentY + optionDiv.offsetHeight / 2}px`;
                    connector.style.transform = 'translateY(-50%)'; // Vertically center
                    nodeEl.appendChild(connector);

                    currentY += optionDiv.offsetHeight + 8; // Advance to the next item (+ gap)
                });

                setupNodeEventListeners(nodeEl); // Re-add listeners for new connectors
                redrawAllConnections(); // Redraw all connections to update lines
            }

            /**
             * Sets up event listeners for elements within a node (inputs, buttons, connectors).
             * @param {HTMLElement} nodeEl - The node element.
             */
            function setupNodeEventListeners(nodeEl) {
                const addBtn = nodeEl.querySelector('.add-btn');
                if (addBtn) {
                    addBtn.onclick = () => {
                        const node = nodes[nodeEl.id];
                        const newOptionText = `Op√ß√£o ${node.content.length}`;
                        node.content.push(newOptionText); // Add new option to content
                        const newIndex = node.content.length - 2; // Index of new option (after the question)
                        const container = nodeEl.querySelector('#buttons-container');
                        container.insertAdjacentHTML('beforeend', `<div class="button-option" data-index="${newIndex}"><input type="text" value="${newOptionText}"><i class="fas fa-times remove-btn"></i></div>`);
                        updateMultipleChoiceConnectors(nodeEl, node.content.length - 1); // Update connectors
                        setupNodeEventListeners(nodeEl); // Re-setup listeners for the new remove button
                        saveState();
                    };
                }
                // Add listeners to remove option buttons
                nodeEl.querySelectorAll('.remove-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation(); // Prevent node drag from starting
                        const node = nodes[nodeEl.id];
                        const optionDiv = btn.closest('.button-option');
                        const indexToRemove = parseInt(optionDiv.dataset.index, 10);
                        // Remove option from content array
                        node.content.splice(indexToRemove + 1, 1); // +1 because content[0] is the question
                        optionDiv.remove(); // Remove HTML element

                        // Update data-index for remaining buttons
                        nodeEl.querySelectorAll('.button-option').forEach((div, i) => div.dataset.index = i);
                        updateMultipleChoiceConnectors(nodeEl, node.content.length - 1);
                        setupNodeEventListeners(nodeEl); // Re-setup listeners
                        saveState();
                    };
                });
                // Add listeners to inputs and textareas to save node content
                nodeEl.querySelectorAll('textarea, input').forEach((input) => {
                    input.addEventListener('input', () => {
                        // Collect all node content. Order matters.
                        const newContent = [];
                        // First textarea is usually the main message/question
                        const mainTextarea = nodeEl.querySelector('textarea');
                        if (mainTextarea) newContent.push(mainTextarea.value);

                        if (nodeEl.dataset.type === 'multipleChoice') {
                            // For multiple choice, collect values from option inputs
                            nodeEl.querySelectorAll('#buttons-container input').forEach(optInput => {
                                newContent.push(optInput.value);
                            });
                        } else if (nodeEl.dataset.type === 'userInput' || nodeEl.dataset.type === 'cta') {
                            // For userInput and cta, collect the second input/textarea
                            const inputs = nodeEl.querySelectorAll('textarea, input[type="text"]');
                            if (inputs.length > 0) newContent.push(inputs[0].value);
                            if (inputs.length > 1) newContent.push(inputs[1].value);
                        } else if (nodeEl.dataset.type === 'delay') {
                            const delayInput = nodeEl.querySelector('input[type="number"]');
                            if (delayInput) newContent[0] = delayInput.value;
                        }
                        nodes[nodeEl.id].content = newContent;
                        saveState();
                    });
                    // Stop propagation for click events on inputs/textareas to prevent node drag
                    input.addEventListener('mousedown', (e) => e.stopPropagation());
                });

                // Add listener for node delete button
                const deleteBtn = nodeEl.querySelector('.delete-node-btn');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevents node selection/drag from starting
                        showConfirmModal(
                            'Excluir Bloco?',
                            `Tem certeza que deseja excluir o bloco "${nodes[nodeEl.id].el.querySelector('.node-header').textContent.trim().replace('üóëÔ∏è', '').trim()}"?`,
                            () => deleteNode(nodeEl.id)
                        );
                    });
                }


                // Add listeners for connectors
                nodeEl.querySelectorAll('.connector').forEach(c => {
                    c.addEventListener('mousedown', (e) => {
                        e.stopPropagation(); // Prevents node drag or canvas pan
                        handleConnectorClick(nodeEl.id, c, e); // Pass event to function
                    });
                    // Add 'mouseover' listener to highlight input connector
                    c.addEventListener('mouseover', () => {
                        if (isConnecting && c.classList.contains('input') && connectionStart.nodeId !== nodeEl.id) {
                            c.classList.add('highlight-target');
                            hoveredInputConnector = c;
                        }
                    });
                    // Remove highlight on mouseout from connector
                    c.addEventListener('mouseout', () => {
                        if (hoveredInputConnector) {
                            hoveredInputConnector.classList.remove('highlight-target');
                            hoveredInputConnector = null;
                        }
                    });
                });
            }
            
            /**
             * Makes a node draggable.
             * @param {HTMLElement} nodeEl - The node element to be dragged.
             */
            function makeNodeDraggable(nodeEl) {
                let dragOffsetX, dragOffsetY;
                let isDraggingNode = false;

                const onMouseMove = (e) => {
                    if (!isDraggingNode) return;
                    e.preventDefault(); 
                    // Calculate new node position adjusting for canvas pan and zoom
                    const newX = (e.clientX - flowCanvas.getBoundingClientRect().left) / pan.scale - dragOffsetX;
                    const newY = (e.clientY - flowCanvas.getBoundingClientRect().top) / pan.scale - dragOffsetY;
                    nodeEl.style.left = `${newX}px`;
                    nodeEl.style.top = `${newY}px`;
                    nodes[nodeEl.id].x = newX;
                    nodes[nodeEl.id].y = newY;
                    updateConnectionsForNode(nodeEl.id); // Update lines connected to this node
                };

                const onMouseUp = () => {
                    isDraggingNode = false;
                    nodeEl.classList.remove('dragging'); // Remove dragging class
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    saveState(); // Save state after drag
                };

                nodeEl.addEventListener('mousedown', (e) => {
                    // Check if click was on an input, textarea, connector or delete button.
                    // If so, allow native interaction and do not start node drag.
                    if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.classList.contains('connector') || e.target.classList.contains('delete-node-btn')) {
                        e.stopPropagation(); // Prevent event from bubbling to parent node or canvas (to not start pan)
                        return; // Exit function, do not start node drag
                    }
                    
                    e.preventDefault(); // Prevents native browser ghosting
                                        // This preventDefault is only called if it's a node drag (not input/connector/delete button)

                    selectNode(nodeEl.id); // Select clicked node
                    isDraggingNode = true;
                    nodeEl.classList.add('dragging'); // Add dragging class for elevated z-index

                    // Calculate click offset within the node for smooth dragging
                    // Offsets are calculated in flowCanvas coordinate system.
                    dragOffsetX = (e.clientX - flowCanvas.getBoundingClientRect().left) / pan.scale - nodes[nodeEl.id].x;
                    dragOffsetY = (e.clientY - flowCanvas.getBoundingClientRect().top) / pan.scale - nodes[nodeEl.id].y;
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
            }
            
            /**
             * Gets the absolute position of a connector on the canvas (relative to flowCanvas).
             * @param {HTMLElement} connectorEl - The connector element.
             * @returns {{x: number, y: number}} X and Y coordinates.
             */
            function getConnectorPosition(connectorEl) {
                const nodeEl = connectorEl.closest('.flow-node');
                // Coordinates are already relative to flowCanvas, as svgLayer is also a child.
                return {
                    x: nodeEl.offsetLeft + connectorEl.offsetLeft + connectorEl.offsetWidth / 2,
                    y: nodeEl.offsetTop + connectorEl.offsetTop + connectorEl.offsetHeight / 2
                };
            }
            
            /**
             * Selects a node by its ID, adding the 'selected' class.
             * Deselects the previously selected node.
             * @param {string|null} nodeId - The ID of the node to be selected, or null to deselect all.
             */
            function selectNode(nodeId) {
                if (selectedNodeId && nodes[selectedNodeId] && nodes[selectedNodeId].el) {
                    nodes[selectedNodeId].el.classList.remove('selected');
                }
                selectedNodeId = nodeId;
                if (selectedNodeId && nodes[selectedNodeId] && nodes[selectedNodeId].el) {
                    nodes[selectedNodeId].el.classList.add('selected');
                }
            }

            /**
             * Deletes a node and its connections.
             * @param {string} nodeId - The ID of the node to be deleted.
             */
            function deleteNode(nodeId) {
                // Remove connections involving the node to be deleted
                connections = connections.filter(conn => conn.from !== nodeId && conn.to !== nodeId);
                // Remove HTML element of the node
                if (nodes[nodeId] && nodes[nodeId].el) {
                    nodes[nodeId].el.remove();
                }
                // Remove node from 'nodes' object
                delete nodes[nodeId];
                selectedNodeId = null; // Deselect node
                redrawAllConnections(); // Redraw all lines to reflect removal
                saveState(); // Save current state
            }

            // Add listener for 'Delete' or 'Backspace' key to delete selected node
            document.addEventListener('keydown', (e) => {
                if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNodeId) {
                    // Prevent default behavior if on an input/textarea inside the node
                    if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                        return;
                    }
                    showConfirmModal(
                        'Excluir Bloco?',
                        `Tem certeza que deseja excluir o bloco "${nodes[selectedNodeId].el.querySelector('.node-header').textContent.trim().replace('üóëÔ∏è', '').trim()}"?`,
                        () => deleteNode(selectedNodeId)
                    );
                }
            });

            // Global mouseup handler for connection logic
            function handleGlobalMouseUp(e) {
                if (!isConnecting) return; // Only proceed if a connection attempt is active
                console.log("Global mouseup detected. isConnecting:", isConnecting);

                const targetConnector = e.target.closest('.connector.input'); // Find closest input connector
                
                if (targetConnector && targetConnector.closest('.flow-node').id !== connectionStart.nodeId) { // Ensure not connecting to itself
                    console.log("MouseUp on a valid and different input connector. Attempting to finalize connection.");
                    
                    const targetNodeId = targetConnector.closest('.flow-node').id;

                    // Prevent connecting to 'start' node
                    if (nodes[targetNodeId].type === 'start') {
                        showAlertModal('Erro de Conex√£o', 'N√≥s do tipo "In√≠cio" n√£o podem ter entradas.');
                        resetConnectionState();
                        return;
                    }

                    // Remove any existing connection that starts from the same source output/choice
                    connections = connections.filter(c => !(c.from === connectionStart.nodeId && c.choice === connectionStart.choice));

                    // Remove any existing connection that points to the target input
                    connections = connections.filter(c => !(c.to === targetNodeId));
                    
                    createConnection(connectionStart.nodeId, targetNodeId, connectionStart.choice);
                } else {
                    console.log("MouseUp not on a valid target connector or self-connecting. Resetting state.");
                }
                resetConnectionState(); // Always reset the state after a mouseup, regardless if a connection was made or not
            }


            /**
             * Handles click on a connector to start or finalize a connection.
             * @param {string} nodeId - The ID of the node the connector belongs to.
             * @param {HTMLElement} connector - The clicked connector element.
             * @param {MouseEvent} e - The mouse event.
             */
            function handleConnectorClick(nodeId, connector, e) {
                e.preventDefault(); 
                e.stopPropagation(); 

                // If a connection is already in progress, clicking another connector should reset it
                if (isConnecting) {
                    console.log("Attempted to start new connection while one was already active. Resetting existing attempt.");
                    resetConnectionState();
                    // If the click was on an output connector, we can proceed to start a new connection
                    if (connector.classList.contains('output')) {
                        startNewConnection(nodeId, connector);
                    }
                    return;
                }

                // Start a new connection (only from output connectors)
                if (connector.classList.contains('output')) {
                    // Prevent connecting from 'end' node
                    if (nodes[nodeId].type === 'end') {
                        showAlertModal('Erro de Conex√£o', 'N√≥s do tipo "Fim" n√£o podem ter sa√≠das.');
                        return;
                    }
                    startNewConnection(nodeId, connector);
                }
            }

            /**
             * Starts the process of drawing a new connection line.
             * @param {string} nodeId - The ID of the starting node.
             * @param {HTMLElement} connector - The output connector element.
             */
            function startNewConnection(nodeId, connector) {
                console.log(`Starting connection from node ${nodeId}, choice: ${connector.dataset.choice || 'default'}`);
                isConnecting = true;
                connectionStart = {
                    nodeId: nodeId,
                    choice: connector.dataset.choice !== undefined ? connector.dataset.choice : null
                };
                currentTempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path'); // Use path for bezier
                currentTempLine.setAttribute('stroke', '#e94560'); // Neon red
                currentTempLine.setAttribute('stroke-width', '2'); // Thin line
                currentTempLine.setAttribute('fill', 'none'); // No fill for lines
                svgLayer.appendChild(currentTempLine);
                const startPos = getConnectorPosition(connector);
                currentTempLine.setAttribute('d', `M ${startPos.x} ${startPos.y} L ${startPos.x} ${startPos.y}`); // Initial straight line
                
                document.addEventListener('mousemove', onDrawingConnection);
                document.addEventListener('mouseup', handleGlobalMouseUp); // Attach without {once:true}
            }


            /**
             * Calculates the SVG path for a B√©zier curve between two points.
             * @param {number} x1 - Initial X.
             * @param {number} y1 - Initial Y.
             * @param {number} x2 - Final X.
             * @param {number} y2 - Final Y.
             * @returns {string} The 'd' attribute for the SVG path.
             */
            function getBezierPath(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1) * 0.5; // Adjustment to control "curviness"
                let cp1x = x1 + dx;
                let cp1y = y1;
                let cp2x = x2 - dx;
                let cp2y = y2;

                // Adjust control points for smoother curves when moving backwards (x1 > x2)
                if (x1 > x2) {
                    cp1x = x1 + 50; // Force bend outwards
                    cp2x = x2 - 50; // Force bend outwards
                }

                return `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
            }

            /**
             * Updates the position of the temporary line during connection drag and highlights target.
             * @param {MouseEvent} e - The mouse event.
             * @returns {void}
             */
            function onDrawingConnection(e) {
                if (!currentTempLine) return; // Ensure temporary line exists
                const coords = toCanvasCoords(e); // Convert to canvas coordinates (untransformed)
                const startX = parseFloat(currentTempLine.getAttribute('d').split(' ')[1]);
                const startY = parseFloat(currentTempLine.getAttribute('d').split(' ')[2]);
                currentTempLine.setAttribute('d', getBezierPath(startX, startY, coords.x, coords.y));

                // Input connector highlight logic
                if (hoveredInputConnector) {
                    hoveredInputConnector.classList.remove('highlight-target');
                    hoveredInputConnector = null;
                }

                // Check if mouse is over a valid input connector (not the original output connector)
                const targetElement = document.elementFromPoint(e.clientX, e.clientY);
                if (targetElement && targetElement.classList.contains('connector') && targetElement.classList.contains('input')) {
                    const targetNode = targetElement.closest('.flow-node');
                    if (targetNode) {
                        const targetNodeId = targetNode.id;
                        // Ensure we are not over the source node of the connection AND not trying to connect to 'start' or 'end' input
                        if (targetNodeId !== connectionStart.nodeId && nodes[targetNodeId].type !== 'start' && nodes[targetNodeId].type !== 'end') {  
                            hoveredInputConnector = targetElement;
                            hoveredInputConnector.classList.add('highlight-target');
                        }
                    }
                }
            }

            /**
             * Resets the connection state (removes temporary line, flags).
             */
            function resetConnectionState() { 
                console.log("Resetting connection state.");
                isConnecting = false;
                connectionStart = {};
                if (currentTempLine) {
                    currentTempLine.remove();
                    currentTempLine = null;
                }
                if (hoveredInputConnector) {
                    hoveredInputConnector.classList.remove('highlight-target');
                    hoveredInputConnector = null;
                }
                document.removeEventListener('mousemove', onDrawingConnection);
                document.removeEventListener('mouseup', handleGlobalMouseUp); // Explicitly remove
            }

            /**
             * Creates a connection between two nodes.
             * Removes any existing connection from the same output.
             * @param {string} fromId - Source node ID.
             * @param {string} toId - Target node ID.
             * @param {string|null} choice - Output choice (for question/multiple choice nodes).
             */
            function createConnection(fromId, toId, choice = null) {
                console.log(`Creating connection: from ${fromId}, to ${toId}, choice: ${choice}`);
                const newConnection = { from: fromId, to: toId, choice, lineEl: null }; // lineEl will be defined in redraw
                connections.push(newConnection);
                redrawAllConnections(); // Redraw all lines to include the new one
                saveState(); // Save state
            }

            /**
             * Updates the position of a single SVG connection line.
             * @param {object} conn - The connection object containing source/target IDs and line element.
             */
            function updateConnectionLine(conn) {
                const fromNode = nodes[conn.from];
                const toNode = nodes[conn.to];
                if (!fromNode || !toNode || !conn.lineEl) {
                    // If nodes or line no longer exist, remove the line to prevent orphans
                    if (conn.lineEl) conn.lineEl.remove();
                    return;
                }

                let fromConnector;
                if (conn.choice !== null) {
                    // For choice connectors (Yes/No, Multiple Choice)
                    fromConnector = fromNode.el.querySelector(`.connector.output[data-choice="${conn.choice}"]`);
                } else {
                    // For standard output connectors
                    fromConnector = fromNode.el.querySelector('.connector.output:not([data-choice])');
                }
                const toConnector = toNode.el.querySelector('.connector.input');

                if (!fromConnector || !toConnector) {
                    // If connectors are not found (node changed, etc.), remove the line
                    if (conn.lineEl) conn.lineEl.remove();
                    return;
                }

                const startPos = getConnectorPosition(fromConnector);
                const endPos = getConnectorPosition(toConnector);

                conn.lineEl.setAttribute('d', getBezierPath(startPos.x, startPos.y, endPos.x, endPos.y));
            }

            /**
             * Updates connection lines for a specific node (when it's moved).
             * @param {string} nodeId - The ID of the node that was moved.
             */
            function updateConnectionsForNode(nodeId) {
                connections.forEach(conn => {
                    if (conn.from === nodeId || conn.to === nodeId) {
                        updateConnectionLine(conn);
                    }
                });
            }

            /**
             * Clears and redraws all SVG connection lines.
             */
            function redrawAllConnections() {
                // Filter out any connections that refer to non-existent nodes first.
                // This ensures we only attempt to draw valid connections and clean up old ones.
                connections = connections.filter(conn => nodes[conn.from] && nodes[conn.to]);

                // Clear only lines, keeping <defs> if any.
                Array.from(svgLayer.children).forEach(child => {
                    if (child.tagName === 'path') { // Lines are paths now
                        child.remove();
                    }
                });

                connections.forEach(conn => {
                    // At this point, we are sure nodes[conn.from] and nodes[conn.to] exist due to the filter above.
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path'); // Create a path element
                    line.setAttribute('stroke', '#e94560'); // Neon red
                    line.setAttribute('stroke-width', '2'); // Thin line
                    line.setAttribute('fill', 'none'); // No fill for lines
                    conn.lineEl = line; // Store reference to the line element
                    svgLayer.appendChild(line);
                    updateConnectionLine(conn); // Update position of the new line
                });
                console.log("Connections after redraw:", connections);
            }
            
            // --- IMPORT / EXPORT / CLEAR LOGIC ---
            exportFlowBtn.addEventListener('click', () => {
                const dataToExport = {
                    nodes: Object.values(nodes).map(n => ({
                        id: n.id,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                        content: n.content
                    })),
                    connections: connections.map(c => ({
                        from: c.from,
                        to: c.to,
                        choice: c.choice
                    })),
                    nodeIdCounter,
                    pan,
                    botSettings: {
                        name: botNameInput.value,
                        profilePic: botProfilePicInput.value
                    }
                };
                const dataStr = JSON.stringify(dataToExport, null, 2);
                const blob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'zapflow_flow.json';
                a.click();
                URL.revokeObjectURL(url);
                showAlertModal('Sucesso!', 'Fluxo exportado com sucesso como "zapflow_flow.json".');
            });

            importFlowBtn.addEventListener('click', () => importFileInput.click());
            importFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        showConfirmModal(
                            'Importar Fluxo?',
                            'Isto ir√° substituir o fluxo atual. Tem a certeza?',
                            () => loadState(data),
                            () => showAlertModal('Importa√ß√£o Cancelada', 'A importa√ß√£o do fluxo foi cancelada.')
                        );
                    } catch (err) {
                        showAlertModal('Erro', 'Erro ao ler o ficheiro JSON. Verifique se √© um arquivo de fluxo v√°lido.');
                        console.error("Erro ao importar fluxo:", err);
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // Clear file input
            });

            /**
             * Resets the canvas, removing all nodes and connections.
             */
            function resetCanvas() {
                nodes = {};
                connections = [];
                selectedNodeId = null;
                // Clear all elements inside flowCanvas, except svg-layer
                Array.from(flowCanvas.children).forEach(child => {
                    if (child.id !== 'svg-layer') {
                        child.remove();
                    }
                });
                // Clear SVG (all lines)
                svgLayer.innerHTML = '';
                console.log("Canvas reset.");
            }

            /**
             * Saves the current flow state to localStorage.
             */
            function saveState() {
                const state = {
                    nodes: Object.values(nodes).map(n => ({
                        id: n.id,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                        content: n.content
                    })),
                    connections: connections.map(c => ({
                        from: c.from,
                        to: c.to,
                        choice: c.choice
                    })),
                    nodeIdCounter,
                    pan,
                    botSettings: {
                        name: botNameInput.value,
                        profilePic: botProfilePicInput.value
                    }
                };
                localStorage.setItem('zapflowBuilderState', JSON.stringify(state));
                console.log("State saved:", state);
            }

            /**
             * Loads flow state from localStorage or provided data.
             * @param {object|null} data - Optional data to load (for import).
             */
            function loadState(data = null) {
                const state = data || JSON.parse(localStorage.getItem('zapflowBuilderState'));
                if (!state) {
                    console.log("No saved state found.");
                    // Set default bot settings if no state is found
                    botNameInput.value = 'ZAPFLOW BOT';
                    botProfilePicInput.value = 'https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png';
                    updateBotPreview();
                    return;
                }
                console.log("Loading state:", state);

                resetCanvas(); // Clear canvas before loading
                nodeIdCounter = state.nodeIdCounter || 0;
                pan = state.pan || {x:0, y:0, scale:1};
                updateCanvasTransform();

                if (state.nodes) {
                    // First create all nodes
                    state.nodes.forEach(n => createNode(n.type, n.x, n.y, n.id, n.content));
                }
                // Then restore connections
                connections = state.connections || [];
                redrawAllConnections(); // Redraw all lines

                // Load bot settings
                if (state.botSettings) {
                    botNameInput.value = state.botSettings.name || 'ZAPFLOW BOT';
                    botProfilePicInput.value = state.botSettings.profilePic || 'https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png';
                } else {
                    botNameInput.value = 'ZAPFLOW BOT';
                    botProfilePicInput.value = 'https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png';
                }
                updateBotPreview();
            }

            clearFlowBtn.addEventListener('click', () => {
                showConfirmModal('Limpar Fluxo?', 'Tem certeza que deseja limpar todo o fluxo? Esta a√ß√£o n√£o pode ser desfeita.',
                    () => {
                        resetCanvas();
                        nodeIdCounter = 0;
                        // No default start node created here. User must drag it.
                        saveState();
                        showAlertModal('Fluxo Limpo', 'O canvas foi limpo. Arraste um n√≥ de "In√≠cio" para come√ßar.');
                    },
                    () => showAlertModal('A√ß√£o Cancelada', 'A limpeza do fluxo foi cancelada.')
                );
            });

            // --- BOT SETTINGS LOGIC ---
            function updateBotPreview() {
                previewBotName.textContent = botNameInput.value || 'ZAPFLOW BOT';
                previewBotAvatar.src = botProfilePicInput.value || 'https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png';
                // Add error handling for broken image
                previewBotAvatar.onerror = function() {
                    this.onerror=null; // Avoid infinite loop
                    this.src='https://placehold.co/45x45/CCCCCC/000000?text=Bot'; // Placeholder for broken image
                };
            }

            botNameInput.addEventListener('input', () => {
                updateBotPreview();
                saveState();
            });

            botProfilePicInput.addEventListener('input', () => {
                updateBotPreview();
                saveState();
            });
            
            // --- FLOW SIMULATION LOGIC ---
            let flowVariables = {}; // Stores user variables during simulation
            let simulationMessages = []; // Stores messages for static HTML export

            /**
             * Adds a message to the preview chat body.
             * @param {string} text - The message text.
             * @param {string} type - 'received' for bot messages, 'sent' for user messages.
             * @param {string} [imageUrl] - Image URL if it's an image message.
             */
            function addMessage(text, type, imageUrl = null) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                if (imageUrl) {
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    // Add fallback for broken image
                    img.onerror = function() {
                        this.onerror=null; // Avoid infinite loop
                        this.src='https://placehold.co/150x100/CCCCCC/000000?text=Imagem+N%C3%A3o+Encontrada';
                    };
                    messageDiv.appendChild(img);
                }
                messageDiv.innerHTML += `<span>${text.replace(/\n/g, '<br>')}</span>`; // Add text and line breaks
                previewChatBody.appendChild(messageDiv);
                scrollToBottom();

                // Store for static HTML export
                simulationMessages.push({ text: text, type: type, imageUrl: imageUrl });
            }

            /**
             * Adds a typing indicator to the preview chat.
             * @returns {HTMLElement} The indicator element.
             */
            function addTypingIndicator() {
                const indicator = document.createElement('div');
                indicator.className = 'typing-indicator';
                indicator.innerHTML = '<span></span><span></span><span></span>';
                previewChatBody.appendChild(indicator);
                scrollToBottom();
                return indicator;
            }

            /**
             * Removes a typing indicator from the chat.
             * @param {HTMLElement} indicatorEl - The indicator element to be removed.
             */
            function removeTypingIndicator(indicatorEl) {
                if (indicatorEl) {
                    indicatorEl.remove();
                }
            }

            /**
             * Auto-scrolls the chat to the bottom.
             */
            function scrollToBottom() {
                previewChatBody.scrollTop = previewChatBody.scrollHeight;
            }

            /**
             * Waits for user choice via buttons.
             * @param {Array<string>} choices - Array of option texts.
             * @returns {Promise<number>} A promise that resolves with the index of the selected choice.
             */
            function waitForUserChoice(choices) {
                return new Promise(resolve => {
                    const choiceContainer = document.createElement('div');
                    choiceContainer.className = 'choice-container';
                    choices.forEach((choiceText, index) => {
                        const button = document.createElement('button');
                        button.className = 'choice-button';
                        // Replace flowVariables in choiceText
                        let processedChoiceText = choiceText;
                        for (const key in flowVariables) {
                            processedChoiceText = processedChoiceText.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), flowVariables[key]);
                        }
                        button.textContent = processedChoiceText;
                        button.onclick = () => {
                            choiceContainer.remove(); // Remove buttons after choice
                            resolve(index); // Resolve with choice index
                        };
                        choiceContainer.appendChild(button);
                    });
                    previewChatBody.appendChild(choiceContainer);
                    scrollToBottom();
                });
            }

            /**
             * Waits for user text input.
             * @param {string} promptText - The question text for the user.
             * @returns {Promise<string>} A promise that resolves with the text entered by the user.
             */
            function waitForUserInput(promptText) {
                return new Promise(resolve => {
                    // Replace flowVariables in promptText
                    let processedPromptText = promptText;
                    for (const key in flowVariables) {
                        processedPromptText = processedPromptText.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), flowVariables[key]);
                    }
                    addMessage(processedPromptText, "received"); // Show bot's question

                    const inputContainer = document.createElement('div');
                    inputContainer.className = 'user-input-container';
                    const inputField = document.createElement('input');
                    inputField.type = 'text';
                    inputField.placeholder = 'Digite sua resposta...';
                    const sendButton = document.createElement('button');
                    sendButton.textContent = 'Enviar';

                    sendButton.onclick = () => {
                        const userText = inputField.value.trim();
                        if (userText) {
                            inputContainer.remove(); // Remove input field and button
                            resolve(userText);
                        }
                    };
                    // Allow sending with Enter
                    inputField.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            sendButton.click();
                        }
                    });

                    inputContainer.appendChild(inputField);
                    inputContainer.appendChild(sendButton);
                    previewChatBody.appendChild(inputContainer);
                    scrollToBottom();
                    inputField.focus(); // Focus on input field
                });
            }


            /**
             * Simulates chat flow in the preview.
             * @param {string} currentNodeId - The ID of the current node to be processed.
             */
            async function simulateFlow(currentNodeId) {
                const currentNode = nodes[currentNodeId];
                if (!currentNode) {
                    addMessage("Fluxo terminado ou n√≥ inv√°lido alcan√ßado.", "received");
                    return;
                }
                console.log(`Simulating node: ${currentNodeId}, Type: ${currentNode.type}`);

                try {
                    // Replace variables in node content before processing
                    let processedContent = currentNode.content.map(c => {
                        let text = c;
                        for (const key in flowVariables) {
                            text = text.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), flowVariables[key]);
                        }
                        return text;
                    });

                    switch (currentNode.type) {
                        case 'start':
                            const startConnection = connections.find(c => c.from === currentNode.id);
                            console.log("Start node connections found:", connections.filter(c => c.from === currentNode.id));
                            if (startConnection) {
                                console.log(`Found start connection to: ${startConnection.to}`);
                                await simulateFlow(startConnection.to); // Continue to next node
                            } else {
                                console.log("No connection found for start node. Flow terminated.", connections);
                                addMessage("N√≥ 'In√≠cio' n√£o conectado a nenhum outro n√≥. Fluxo terminou.", "received");
                            }
                            break;

                        case 'end': // New 'end' node behavior
                            addMessage("Fluxo finalizado.", "received");
                            console.log("End node reached. Flow terminated.");
                            return; // Stop simulation here

                        case 'message':
                            addMessage(processedContent[0], "received");
                            await new Promise(r => setTimeout(r, 500)); // Small delay for "reading"
                            // Find next connection and continue
                            const msgConnection = connections.find(c => c.from === currentNode.id);
                            console.log(`Message node (${currentNode.id}) connections found:`, connections.filter(c => c.from === currentNode.id));
                            if (msgConnection) {
                                console.log(`Found message connection to: ${msgConnection.to}`);
                                await simulateFlow(msgConnection.to);
                            }
                            else {
                                console.log("No connection found for message node. Flow terminated.");
                                addMessage("N√≥ 'Mensagem' n√£o conectado. Fluxo terminou.", "received");
                            }
                            break;

                        case 'image':
                            addMessage("Enviando imagem...", "received", processedContent[0]);
                            await new Promise(r => setTimeout(r, 1000)); // Small delay for "loading"
                            const imgConnection = connections.find(c => c.from === currentNode.id);
                            console.log(`Image node (${currentNode.id}) connections found:`, connections.filter(c => c.from === currentNode.id));
                            if (imgConnection) {
                                console.log(`Found image connection to: ${imgConnection.to}`);
                                await simulateFlow(imgConnection.to);
                            }
                            else {
                                console.log("No connection found for image node. Flow terminated.");
                                addMessage("N√≥ 'Imagem' n√£o conectado. Fluxo terminou.", "received");
                            }
                            break;

                        case 'question':
                            const questionText = processedContent[0];
                            const choiceSelected = await waitForUserChoice(['Sim', 'N√£o']);
                            addMessage(choiceSelected === 0 ? 'Sim' : 'N√£o', 'sent'); // User's answer

                            // Find next connection based on choice
                            const questionChoice = (choiceSelected === 0) ? 'yes' : 'no';
                            const questionConnection = connections.find(c => c.from === currentNode.id && c.choice === questionChoice);
                            console.log(`Question node (${currentNode.id}) connections for choice '${questionChoice}':`, connections.filter(c => c.from === currentNode.id && c.choice === questionChoice));
                            if (questionConnection) {
                                console.log(`Found question connection to: ${questionConnection.to}`);
                                await simulateFlow(questionConnection.to);
                            }
                            else {
                                console.log(`No connection found for question node choice '${questionChoice}'. Flow terminated.`);
                                showAlertModal('Aviso', `Nenhuma conex√£o definida para a op√ß√£o "${questionChoice === 'yes' ? 'Sim' : 'N√£o'}". Fluxo terminou.`);
                            }
                            break;

                        case 'multipleChoice':
                            const mcQuestionText = processedContent[0];
                            const mcOptions = processedContent.slice(1);
                            
                            addMessage(mcQuestionText, "received");
                            const mcChoiceIndex = await waitForUserChoice(mcOptions);
                            addMessage(mcOptions[mcChoiceIndex], 'sent'); // User's answer

                            // Find next connection based on choice index
                            const mcConnection = connections.find(c => c.from === currentNode.id && parseInt(c.choice) === mcChoiceIndex);
                            console.log(`Multiple Choice node (${currentNode.id}) connections for choice index '${mcChoiceIndex}':`, connections.filter(c => c.from === currentNode.id && parseInt(c.choice) === mcChoiceIndex));
                            if (mcConnection) {
                                console.log(`Found multiple choice connection to: ${mcConnection.to}`);
                                await simulateFlow(mcConnection.to);
                            }
                            else {
                                console.log(`No connection found for multiple choice node choice index '${mcChoiceIndex}'. Flow terminated.`);
                                showAlertModal('Aviso', `Nenhuma conex√£o definida para a op√ß√£o "${mcOptions[mcChoiceIndex]}". Fluxo terminou.`);
                            }
                            break;

                        case 'userInput':
                            const inputPrompt = processedContent[0];
                            const variableName = processedContent[1] || 'user_input'; // Default variable name
                            const userInput = await waitForUserInput(inputPrompt);
                            addMessage(userInput, 'sent'); // Show user input
                            flowVariables[variableName] = userInput; // Store input
                            console.log(`User input for variable '${variableName}': ${userInput}`);
                            
                            const userInputConnection = connections.find(c => c.from === currentNode.id);
                            console.log(`User Input node (${currentNode.id}) connections found:`, connections.filter(c => c.from === currentNode.id));
                            if (userInputConnection) {
                                console.log(`Found user input connection to: ${userInputConnection.to}`);
                                await simulateFlow(userInputConnection.to);
                            }
                            else {
                                console.log("No connection found for user input node. Flow terminated.");
                                addMessage("N√≥ 'Entrada do Utilizador' n√£o conectado. Fluxo terminou.", "received");
                            }
                            break;

                        case 'delay':
                            const delayMs = parseInt(processedContent[0] || '1500', 10);
                            const indicator = addTypingIndicator();
                            console.log(`Delaying for ${delayMs}ms...`);
                            await new Promise(r => setTimeout(r, delayMs));
                            removeTypingIndicator(indicator);
                            
                            const delayConnection = connections.find(c => c.from === currentNode.id);
                            console.log(`Delay node (${currentNode.id}) connections found:`, connections.filter(c => c.from === currentNode.id));
                            if (delayConnection) {
                                console.log(`Found delay connection to: ${delayConnection.to}`);
                                await simulateFlow(delayConnection.to);
                            }
                            else {
                                console.log("No connection found for delay node. Flow terminated.");
                                addMessage("N√≥ 'Atraso' n√£o conectado. Fluxo terminou.", "received");
                            }
                            break;

                        case 'cta':
                            const ctaText = processedContent[0] || 'Visitar Link';
                            const ctaUrl = processedContent[1] || '#';
                            const ctaContainer = document.createElement('div');
                            ctaContainer.className = 'cta-button-container';
                            const ctaButton = document.createElement('a');
                            ctaButton.className = 'cta-button';
                            ctaButton.href = ctaUrl;
                            ctaButton.textContent = ctaText;
                            ctaButton.target = '_blank'; // Open in new tab
                            ctaContainer.appendChild(ctaButton);
                            previewChatBody.appendChild(ctaContainer);
                            scrollToBottom();
                            addMessage("Fluxo conclu√≠do! Clique no bot√£o final.", "received");
                            console.log("CTA node reached. Flow finished.");
                            break;

                        default:
                            addMessage(`Tipo de n√≥ desconhecido: ${currentNode.type}. Fluxo terminado.`, "received");
                            console.log(`Unknown node type: ${currentNode.type}. Flow terminated.`);
                            break;
                    }
                } catch (error) {
                    console.error("Erro durante a simula√ß√£o do fluxo:", error);
                    showAlertModal('Erro de Simula√ß√£o', 'Ocorreu um erro durante a simula√ß√£o do fluxo. Verifique suas conex√µes e conte√∫dos.');
                }
            }

            // Start flow simulation
            runFlowBtn.addEventListener('click', async () => {
                previewChatBody.innerHTML = ''; // Clear preview chat
                simulationMessages = []; // Clear messages for static HTML export
                flowVariables = {}; // Reset flow variables
                
                // Find start node
                const startNode = Object.values(nodes).find(node => node.type === 'start');
                if (!startNode) {
                    showAlertModal('Erro', 'Nenhum n√≥ de "In√≠cio" encontrado no fluxo. Por favor, arraste um do painel lateral.');
                    return;
                }
                
                addMessage("Simula√ß√£o do fluxo iniciada.", "received");
                await new Promise(r => setTimeout(r, 1000)); // Small delay before starting actual flow
                console.log("Starting flow. Initial connections:", connections);
                simulateFlow(startNode.id); // Start simulation from start node
            });

            // --- NEW: GENERATE AND DOWNLOAD CHAT HTML ---
            downloadHtmlBtn.addEventListener('click', async () => {
                // First, run a simulation to capture messages for the static HTML
                previewChatBody.innerHTML = ''; // Clear preview chat
                simulationMessages = []; // Reset messages for export
                flowVariables = {}; // Reset variables for export simulation

                const startNode = Object.values(nodes).find(node => node.type === 'start');
                if (!startNode) {
                    showAlertModal('Erro', 'Nenhum n√≥ de "In√≠cio" encontrado no fluxo para gerar HTML.');
                    return;
                }

                // Run a headless simulation to collect messages
                await simulateFlowForHtmlExport(startNode.id);

                const chatHtml = generateChatHtmlContent(simulationMessages, botNameInput.value, botProfilePicInput.value);
                const blob = new Blob([chatHtml], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'zapflow_chat_preview.html';
                a.click();
                URL.revokeObjectURL(url);
                showAlertModal('Sucesso!', 'Pr√©-visualiza√ß√£o do chat exportada como "zapflow_chat_preview.html".');
            });

            /**
             * Simulates the flow to collect messages for HTML export.
             * This version does not interact with the DOM, only collects data.
             * It makes assumptions for user input and multiple choices to create a linear path.
             * @param {string} currentNodeId - The ID of the current node to be processed.
             * @param {object} currentFlowVariables - Current state of flow variables.
             * @returns {Promise<void>}
             */
            async function simulateFlowForHtmlExport(currentNodeId, currentFlowVariables = {}, messages = []) {
                const currentNode = nodes[currentNodeId];
                if (!currentNode) {
                    messages.push({ text: "Fluxo terminado ou n√≥ inv√°lido alcan√ßado.", type: "received" });
                    return;
                }

                // Replace variables in node content before processing
                let processedContent = currentNode.content.map(c => {
                    let text = c;
                    for (const key in currentFlowVariables) {
                        text = text.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), currentFlowVariables[key]);
                    }
                    return text;
                });

                switch (currentNode.type) {
                    case 'start':
                        const startConnection = connections.find(c => c.from === currentNode.id);
                        if (startConnection) {
                            await simulateFlowForHtmlExport(startConnection.to, currentFlowVariables, messages);
                        } else {
                            messages.push({ text: "N√≥ 'In√≠cio' n√£o conectado a nenhum outro n√≥. Fluxo terminou.", type: "received" });
                        }
                        break;

                    case 'end':
                        messages.push({ text: "Fluxo finalizado.", type: "received" });
                        return;

                    case 'message':
                        messages.push({ text: processedContent[0], type: "received" });
                        const msgConnection = connections.find(c => c.from === currentNode.id);
                        if (msgConnection) {
                            await simulateFlowForHtmlExport(msgConnection.to, currentFlowVariables, messages);
                        } else {
                            messages.push({ text: "N√≥ 'Mensagem' n√£o conectado. Fluxo terminou.", type: "received" });
                        }
                        break;

                    case 'image':
                        messages.push({ text: "Enviando imagem...", type: "received", imageUrl: processedContent[0] });
                        const imgConnection = connections.find(c => c.from === currentNode.id);
                        if (imgConnection) {
                            await simulateFlowForHtmlExport(imgConnection.to, currentFlowVariables, messages);
                        } else {
                            messages.push({ text: "N√≥ 'Imagem' n√£o conectado. Fluxo terminou.", type: "received" });
                        }
                        break;

                    case 'question':
                        const questionText = processedContent[0];
                        messages.push({ text: questionText, type: "received" });
                        // For static export, assume "Sim" (choice 0)
                        const assumedQuestionChoice = 'yes';
                        messages.push({ text: 'Sim', type: 'sent' });

                        const questionConnection = connections.find(c => c.from === currentNode.id && c.choice === assumedQuestionChoice);
                        if (questionConnection) {
                            await simulateFlowForHtmlExport(questionConnection.to, currentFlowVariables, messages);
                        } else {
                            messages.push({ text: `Nenhuma conex√£o definida para a op√ß√£o "Sim". Fluxo terminou.`, type: "received" });
                        }
                        break;

                    case 'multipleChoice':
                        const mcQuestionText = processedContent[0];
                        const mcOptions = processedContent.slice(1);
                        messages.push({ text: mcQuestionText, type: "received" });
                        // For static export, assume the first option (choice 0)
                        const assumedMcChoiceIndex = 0;
                        if (mcOptions[assumedMcChoiceIndex]) {
                            messages.push({ text: mcOptions[assumedMcChoiceIndex], type: 'sent' });
                        } else {
                            messages.push({ text: 'Nenhuma op√ß√£o dispon√≠vel.', type: 'sent' });
                        }

                        const mcConnection = connections.find(c => c.from === currentNode.id && parseInt(c.choice) === assumedMcChoiceIndex);
                        if (mcConnection) {
                            await simulateFlowForHtmlExport(mcConnection.to, currentFlowVariables, messages);
                        } else {
                            messages.push({ text: `Nenhuma conex√£o definida para a primeira op√ß√£o. Fluxo terminou.`, type: "received" });
                        }
                        break;

                    case 'userInput':
                        const inputPrompt = processedContent[0];
                        const variableName = processedContent[1] || 'user_input';
                        messages.push({ text: inputPrompt, type: "received" });
                        const assumedUserInput = `[Resposta do Usu√°rio para ${variableName}]`; // Placeholder for static export
                        messages.push({ text: assumedUserInput, type: 'sent' });
                        currentFlowVariables[variableName] = assumedUserInput; // Update variables for subsequent nodes

                        const userInputConnection = connections.find(c => c.from === currentNode.id);
                        if (userInputConnection) {
                            await simulateFlowForHtmlExport(userInputConnection.to, currentFlowVariables, messages);
                        } else {
                            messages.push({ text: "N√≥ 'Entrada do Utilizador' n√£o conectado. Fluxo terminou.", type: "received" });
                        }
                        break;

                    case 'delay':
                        // Delays are skipped for static HTML export, but we can add a message
                        messages.push({ text: `[Pausa de ${processedContent[0] || '1500'}ms]`, type: "received" });
                        const delayConnection = connections.find(c => c.from === currentNode.id);
                        if (delayConnection) {
                            await simulateFlowForHtmlExport(delayConnection.to, currentFlowVariables, messages);
                        } else {
                            messages.push({ text: "N√≥ 'Atraso' n√£o conectado. Fluxo terminou.", type: "received" });
                        }
                        break;

                    case 'cta':
                        const ctaText = processedContent[0] || 'Visitar Link';
                        const ctaUrl = processedContent[1] || '#';
                        messages.push({ text: "Fluxo conclu√≠do! Clique no bot√£o final.", type: "received" });
                        messages.push({ cta: { text: ctaText, url: ctaUrl }, type: "cta" }); // Special type for CTA
                        break;

                    default:
                        messages.push({ text: `Tipo de n√≥ desconhecido: ${currentNode.type}. Fluxo terminado.`, type: "received" });
                        break;
                }
                // The `messages` array is modified by reference, so no return needed.
            }

            /**
             * Generates the full HTML content for the chat preview.
             * @param {Array<object>} messages - Array of message objects (from simulateFlowForHtmlExport).
             * @param {string} botName - The bot's name.
             * @param {string} botAvatar - The bot's avatar URL.
             * @returns {string} The complete HTML string.
             */
            function generateChatHtmlContent(messages, botName, botAvatar) {
                const chatMessagesHtml = messages.map(msg => {
                    if (msg.type === 'cta') {
                        return `
                            <div class="cta-button-container">
                                <a class="cta-button" href="${msg.cta.url}" target="_blank">${msg.cta.text}</a>
                            </div>
                        `;
                    }
                    const imgHtml = msg.imageUrl ? `<img src="${msg.imageUrl}" onerror="this.onerror=null;this.src='https://placehold.co/150x100/CCCCCC/000000?text=Imagem+N%C3%A3o+Encontrada';">` : '';
                    return `
                        <div class="message ${msg.type}">
                            ${imgHtml}<span>${msg.text.replace(/\n/g, '<br>')}</span>
                        </div>
                    `;
                }).join('');

                // Extract the relevant CSS for the chat preview
                const chatCss = `
                    body {
                        font-family: 'Roboto', sans-serif;
                        background-color: #f0f0f0; /* Lighter background for standalone chat */
                        display: flex;
                        justify-content: center;
                        align-items: center;
                        min-height: 100vh;
                        margin: 0;
                    }
                    .mobile-preview {
                        width: 100%; max-width: 380px; height: 90vh; background-color: #111;
                        border-radius: 40px; border: 10px solid #000; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                        display: flex; flex-direction: column; overflow: hidden;
                    }
                    .chat-header {
                        background-color: #075E54; color: white; padding: 10px 15px; display: flex;
                        align-items: center; gap: 15px; flex-shrink: 0;
                    }
                    .chat-header img { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; }
                    .chat-header .name { font-weight: bold; }
                    .chat-header .status { font-size: 0.8em; color: #d1d1d1; }
                    .chat-body {
                        flex-grow: 1; padding: 15px 10px; overflow-y: auto; display: flex; flex-direction: column;
                        gap: 12px; background-color: #e5ddd5;
                        background-image: url('https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png');
                    }
                    .message { max-width: 80%; padding: 8px 12px; border-radius: 8px; line-height: 1.4; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
                    .message.received { background-color: #ffffff; align-self: flex-start; color: black; }
                    .message.sent { background-color: #dcf8c6; align-self: flex-end; color: black; }
                    .message img { max-width: 100%; border-radius: 8px; margin-top: 5px; }
                    .choice-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; padding: 5px 10px; align-self: flex-end; }
                    .choice-button { background-color: #fff; border: 1px solid #075E54; color: #075E54; padding: 8px 15px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: background-color 0.2s, color 0.2s; }
                    .choice-button:hover { background-color: #075E54; color: white; }
                    .cta-button-container { padding: 10px; align-self: stretch; }
                    .cta-button { background: linear-gradient(45deg, #25D366, #128C7E); color: white; text-align: center; text-decoration: none; font-size: 1.1em; font-weight: bold; padding: 15px; border-radius: 30px; display: block; transition: transform 0.2s; }
                    .cta-button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
                    .user-input-container { display: flex; gap: 5px; margin-top: 10px; align-self: stretch; }
                    .user-input-container input { flex-grow: 1; padding: 8px; border-radius: 20px; border: 1px solid #ccc; }
                    .user-input-container button { padding: 8px 15px; border-radius: 20px; border: none; background-color: #075E54; color: white; cursor: pointer; }
                `;

                return `
                    <!DOCTYPE html>
                    <html lang="pt-BR">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>ZAPFLOW Chat Preview</title>
                        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
                        <style>
                            ${chatCss}
                        </style>
                    </head>
                    <body>
                        <div class="mobile-preview">
                            <div class="chat-header">
                                <img src="${botAvatar}" alt="Atendente" onerror="this.onerror=null;this.src='https://placehold.co/45x45/CCCCCC/000000?text=Bot';">
                                <div class="contact-info">
                                    <div class="name">${botName}</div>
                                    <div class="status">online</div>
                                </div>
                            </div>
                            <div class="chat-body">
                                ${chatMessagesHtml}
                            </div>
                        </div>
                    </body>
                    </html>
                `;
            }


            // --- INITIALIZATION ---
            function init() {
                loadState(); // Try to load saved state
                // If no nodes, do not create a default start node. User must drag it.
                if (Object.keys(nodes).length === 0) {
                   console.log("No nodes loaded. Canvas is empty.");
                }
                console.log("Flow builder initialized.");
            }
            init(); // Call initialization function
        }
    });
    </script>
</body>
</html>
