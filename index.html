<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flow Builder PRO - Chat Interativo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* --- ESTILOS GERAIS E SETUP --- */
        :root {
            --bg-color: #1a1a2e;
            --panel-color: #16213e;
            --canvas-color: #0f1524;
            --primary-accent: #e94560;
            --secondary-accent: #4fc3f7;
            --success-color: #25D366;
            --warning-color: #f7b731;
            --text-light: #e0e0e0;
            --border-color: #2c3e50;
            --shadow-color: rgba(0, 0, 0, 0.4);
            --connector-color: #6c757d;
        }

        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            display: flex;
        }

        /* --- LAYOUT PRINCIPAL DA APLICAÇÃO --- */
        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr 420px;
            width: 100%;
            height: 100%;
            gap: 10px;
            padding: 10px;
        }

        .panel {
            background-color: var(--panel-color);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 15px var(--shadow-color);
            z-index: 10;
        }
        .panel-header {
            font-size: 1.4em;
            font-weight: 700;
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            color: var(--primary-accent);
        }
        .panel-header i { margin-right: 10px; }
        
        /* --- PAINEL LATERAL DE BLOCOS --- */
        #side-panel .node-template {
            background-color: var(--canvas-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: grab;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: 500;
            font-size: 0.95em;
        }
        #side-panel .node-template:hover {
            background-color: #2c3e50;
            transform: translateY(-2px);
        }
        #side-panel .node-template i {
            margin-right: 10px;
            color: var(--secondary-accent);
            width: 20px;
            text-align: center;
        }
        #side-panel .controls {
            margin-top: auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .control-btn {
            padding: 12px 10px;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            font-size: 0.9em;
        }
        .control-btn:hover { transform: translateY(-2px); }
        #run-flow-btn { background-color: var(--primary-accent); grid-column: 1 / -1; }
        #run-flow-btn:hover { background-color: #c33a50; }
        #clear-flow-btn { background-color: #555; }
        #clear-flow-btn:hover { background-color: #777; }
        #download-html-btn { background-color: var(--success-color); }
        #download-html-btn:hover { background-color: #128C7E; }
        #import-flow-btn { background-color: var(--warning-color); grid-column: 1 / -1;}
        #export-flow-btn { background-color: var(--secondary-accent); grid-column: 1 / -1; margin-top:-2px;}
        
        /* --- CANVAS CENTRAL --- */
        #canvas-container {
            position: relative;
            background-color: var(--canvas-color);
            background-image: radial-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 20px 20px;
            border-radius: 12px;
            overflow: hidden;
            cursor: grab;
        }
        #canvas-container:active { cursor: grabbing; }

        #flow-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            transform-origin: 0 0;
        }
        
        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* --- BLOCOS NO CANVAS --- */
        .flow-node {
            position: absolute;
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 240px;
            min-height: 80px;
            box-shadow: 0 4px 12px var(--shadow-color);
            cursor: move;
            transition: box-shadow 0.3s, border-color 0.3s;
            display: flex;
            flex-direction: column;
        }
        .flow-node.selected {
            border-color: var(--primary-accent);
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
        }
        .node-header {
            background-color: #2c3e50;
            color: var(--text-light);
            padding: 8px 10px;
            font-weight: bold;
            border-top-left-radius: 7px;
            border-top-right-radius: 7px;
        }
        .node-header i { margin-right: 8px; }
        .node-content {
            padding: 10px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .node-content textarea, .node-content input {
            width: 100%;
            background-color: var(--canvas-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-light);
            padding: 8px;
            resize: vertical;
        }
        .node-content textarea { min-height: 40px; }
        .node-content textarea:focus, .node-content input:focus {
            outline: none;
            border-color: var(--secondary-accent);
        }
        .node-content label {
            font-size: 0.8em;
            color: var(--text-light-muted, #aaa);
            margin-bottom: -4px;
        }
        .flow-node[data-type="start"] { border-color: var(--success-color); }
        .flow-node[data-type="start"] .node-header { background-color: #128C7E; }
        .flow-node[data-type="question"], .flow-node[data-type="multipleChoice"] { border-color: var(--secondary-accent); }
        .flow-node[data-type="question"] .node-header, .flow-node[data-type="multipleChoice"] .node-header { background-color: #3b5998; }
        
        .connector {
            width: 16px; height: 16px;
            background-color: #fff;
            border: 2px solid var(--connector-color);
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            transition: background-color 0.3s;
            z-index: 10;
        }
        .connector:hover { background-color: var(--primary-accent); }
        .connector.output { right: -8px; }
        .connector.input { left: -8px; top: 50%; transform: translateY(-50%); }

        .button-option { display: flex; align-items: center; gap: 5px; }
        .button-option input { flex-grow: 1; }
        .remove-btn { cursor: pointer; color: #e94560; }
        .add-btn {
            background: none; border: 1px dashed var(--connector-color); color: var(--connector-color);
            padding: 5px; border-radius: 4px; cursor: pointer; margin-top: 5px;
        }

        /* --- PRÉ-VISUALIZAÇÃO (CELULAR) --- */
        #preview-panel { align-items: center; justify-content: center; }
        .mobile-preview {
            width: 100%; max-width: 380px; height: 95%; background-color: #111;
            border-radius: 40px; border: 10px solid #000; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; overflow: hidden;
        }
        .chat-header {
            background-color: #075E54; color: white; padding: 10px 15px; display: flex;
            align-items: center; gap: 15px; flex-shrink: 0;
        }
        .chat-header img { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; }
        .chat-header .name { font-weight: bold; }
        .chat-header .status { font-size: 0.8em; color: #d1d1d1; }
        .chat-body {
            flex-grow: 1; padding: 15px 10px; overflow-y: auto; display: flex; flex-direction: column;
            gap: 12px; background-color: #e5ddd5;
            background-image: url('https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png');
        }
        .message { max-width: 80%; padding: 8px 12px; border-radius: 8px; line-height: 1.4; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .message.received { background-color: #ffffff; align-self: flex-start; }
        .message.sent { background-color: #dcf8c6; align-self: flex-end; }
        .message img { max-width: 100%; border-radius: 8px; margin-top: 5px; }
        .typing-indicator { align-self: flex-start; padding: 10px 15px; }
        .typing-indicator span { height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        .choice-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; padding: 5px 10px; align-self: flex-end; }
        .choice-button { background-color: #fff; border: 1px solid #075E54; color: #075E54; padding: 8px 15px; border-radius: 20px; cursor: pointer; font-weight: bold; }
        .cta-button-container { padding: 10px; align-self: stretch; }
        .cta-button { background: linear-gradient(45deg, #25D366, #128C7E); color: white; text-align: center; text-decoration: none; font-size: 1.1em; font-weight: bold; padding: 15px; border-radius: 30px; display: block; }
    </style>
</head>
<body>

    <div class="app-container">
        <div id="side-panel" class="panel">
            <div class="panel-header"><i class="fas fa-sitemap"></i> Blocos do Fluxo</div>
            <div class="node-template" draggable="true" data-type="message">
                <i class="fas fa-comment-dots"></i> Mensagem do Bot
            </div>
             <div class="node-template" draggable="true" data-type="image">
                <i class="fas fa-image"></i> Imagem
            </div>
            <div class="node-template" draggable="true" data-type="question">
                <i class="fas fa-question-circle"></i> Pergunta (Sim/Não)
            </div>
            <div class="node-template" draggable="true" data-type="multipleChoice">
                <i class="fas fa-check-double"></i> Múltiplas Escolhas
            </div>
            <div class="node-template" draggable="true" data-type="userInput">
                <i class="fas fa-keyboard"></i> Entrada do Utilizador
            </div>
            <div class="node-template" draggable="true" data-type="delay">
                <i class="fas fa-clock"></i> Atraso / Pausa
            </div>
            <div class="node-template" draggable="true" data-type="cta">
                <i class="fas fa-rocket"></i> Botão Final (CTA)
            </div>

            <div class="controls">
                <button id="run-flow-btn" class="control-btn"><i class="fas fa-play"></i> Testar Fluxo</button>
                <button id="import-flow-btn" class="control-btn"><i class="fas fa-upload"></i> Importar Fluxo</button>
                <button id="export-flow-btn" class="control-btn"><i class="fas fa-download"></i> Exportar Fluxo</button>
                <button id="clear-flow-btn" class="control-btn"><i class="fas fa-trash-alt"></i> Limpar</button>
                <button id="download-html-btn" class="control-btn"><i class="fas fa-code"></i> Baixar HTML</button>
                <input type="file" id="import-file-input" style="display: none;" accept=".json">
            </div>
        </div>

        <div id="canvas-container">
            <div id="flow-canvas">
                <svg id="svg-layer"></svg>
            </div>
        </div>

        <div id="preview-panel" class="panel">
             <div class="panel-header"><i class="fas fa-mobile-alt"></i> Pré-visualização</div>
            <div class="mobile-preview">
                <div class="chat-header">
                    <img src="https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png" alt="Atendente">
                    <div class="contact-info">
                        <div class="name">TOP FLIX</div>
                        <div class="status">online</div>
                    </div>
                </div>
                <div class="chat-body" id="preview-chat-body"></div>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const sidePanel = document.getElementById('side-panel'), canvasContainer = document.getElementById('canvas-container'),
              flowCanvas = document.getElementById('flow-canvas'), svgLayer = document.getElementById('svg-layer'),
              runFlowBtn = document.getElementById('run-flow-btn'), clearFlowBtn = document.getElementById('clear-flow-btn'),
              downloadHtmlBtn = document.getElementById('download-html-btn'), previewChatBody = document.getElementById('preview-chat-body'),
              importFlowBtn = document.getElementById('import-flow-btn'), exportFlowBtn = document.getElementById('export-flow-btn'),
              importFileInput = document.getElementById('import-file-input');

        let nodes = {}, connections = [], nodeIdCounter = 0, selectedNodeId = null, isConnecting = false, connectionStart = {};
        let pan = { x: 0, y: 0, scale: 1, isPanning: false, startX: 0, startY: 0 };
        
        // --- LÓGICA DE ZOOM E PANORÂMICA ---
        canvasContainer.addEventListener('wheel', (e) => {
            e.preventDefault();
            const rect = canvasContainer.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            const oldScale = pan.scale;
            const newScale = oldScale * (e.deltaY > 0 ? 0.9 : 1.1);
            pan.scale = Math.max(0.2, Math.min(newScale, 2));

            pan.x = mouseX - (mouseX - pan.x) * (pan.scale / oldScale);
            pan.y = mouseY - (mouseY - pan.y) * (pan.scale / oldScale);
            
            updateCanvasTransform();
        });

        canvasContainer.addEventListener('mousedown', (e) => {
            if (e.target !== canvasContainer) return;
            pan.isPanning = true;
            pan.startX = e.clientX;
            pan.startY = e.clientY;
        });

        canvasContainer.addEventListener('mousemove', (e) => {
            if (!pan.isPanning) return;
            pan.x += e.clientX - pan.startX;
            pan.y += e.clientY - pan.startY;
            pan.startX = e.clientX;
            pan.startY = e.clientY;
            updateCanvasTransform();
        });

        canvasContainer.addEventListener('mouseup', () => pan.isPanning = false);
        canvasContainer.addEventListener('mouseleave', () => pan.isPanning = false);

        function updateCanvasTransform() {
            flowCanvas.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${pan.scale})`;
        }

        function toCanvasCoords(e) {
            const rect = canvasContainer.getBoundingClientRect();
            return {
                x: (e.clientX - rect.left - pan.x) / pan.scale,
                y: (e.clientY - rect.top - pan.y) / pan.scale
            };
        }

        // --- LÓGICA DRAG & DROP ---
        sidePanel.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', e.target.dataset.type));
        canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            const type = e.dataTransfer.getData('text/plain');
            if (!type) return;
            const coords = toCanvasCoords(e);
            createNode(type, coords.x, coords.y);
        });

        // --- CRIAÇÃO DE BLOCOS ---
        function createNode(type, x, y, id = null, content = []) {
            const nodeId = id || `node-${nodeIdCounter++}`;
            const nodeEl = document.createElement('div');
            nodeEl.className = 'flow-node';
            nodeEl.id = nodeId;
            nodeEl.dataset.type = type;
            nodeEl.style.left = `${x}px`;
            nodeEl.style.top = `${y}px`;

            let headerText = '', headerIcon = '', contentHtml = '';
            let hasInput = true, hasOutput = true;

            switch(type) {
                case 'start': headerText = 'Início'; headerIcon = 'fa-flag-checkered'; contentHtml = `<p style="text-align:center;">Ponto de partida</p>`; hasInput = false; break;
                case 'message': headerText = 'Mensagem'; headerIcon = 'fa-comment-dots'; contentHtml = `<textarea placeholder="Texto da mensagem">${content[0] || ''}</textarea>`; break;
                case 'image': headerText = 'Imagem'; headerIcon = 'fa-image'; contentHtml = `<textarea placeholder="URL da Imagem">${content[0] || ''}</textarea>`; break;
                case 'question': headerText = 'Pergunta (Sim/Não)'; headerIcon = 'fa-question-circle'; contentHtml = `<textarea placeholder="Texto da pergunta">${content[0] || ''}</textarea>`; break;
                case 'userInput': headerText = 'Entrada do Utilizador'; headerIcon = 'fa-keyboard'; contentHtml = `<textarea placeholder="Texto da pergunta">${content[0] || ''}</textarea><input type="text" placeholder="Variável (ex: nome)" value="${content[1] || ''}">`; break;
                case 'delay': headerText = 'Atraso'; headerIcon = 'fa-clock'; contentHtml = `<input type="number" placeholder="ms" value="${content[0] || '1500'}">`; break;
                case 'cta': headerText = 'Botão Final'; headerIcon = 'fa-rocket'; contentHtml = `<textarea>${content[0] || 'Comprar Agora'}</textarea><textarea placeholder="URL do Link">${content[1] || ''}</textarea>`; hasOutput = false; break;
                case 'multipleChoice':
                    headerText = 'Múltiplas Escolhas'; headerIcon = 'fa-check-double';
                    let buttonsHtml = (content.slice(1).length > 0 ? content.slice(1) : ['Opção 1']).map((text, i) =>
                        `<div class="button-option" data-index="${i}"><input type="text" value="${text}"><i class="fas fa-times remove-btn"></i></div>`
                    ).join('');
                    contentHtml = `<textarea placeholder="Texto da pergunta">${content[0] || ''}</textarea><div id="buttons-container">${buttonsHtml}</div><button class="add-btn"><i class="fas fa-plus"></i> Adicionar Opção</button>`;
                    break;
            }

            nodeEl.innerHTML = `<div class="node-header"><i class="fas ${headerIcon}"></i> ${headerText}</div><div class="node-content">${contentHtml}</div>`;
            if (hasInput) nodeEl.insertAdjacentHTML('beforeend', `<div class="connector input"></div>`);
            
            if (hasOutput) {
                if (type === 'question') {
                    nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" data-choice="yes" style="top: 35%;"></div>`);
                    nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" data-choice="no" style="top: 65%;"></div>`);
                } else if (type === 'multipleChoice') {
                    // Os conectores são adicionados dinamicamente
                } else {
                    nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" style="top: 50%; transform: translateY(-50%);"></div>`);
                }
            }
            flowCanvas.appendChild(nodeEl);
            nodes[nodeId] = { id: nodeId, el: nodeEl, type, x, y, content: content.length > 0 ? content : (type === 'multipleChoice' ? ['Pergunta?', 'Opção 1'] : ['', '']) };
            
            if (type === 'multipleChoice') updateMultipleChoiceConnectors(nodeEl, nodes[nodeId].content.length - 1);

            makeNodeDraggable(nodeEl);
            setupNodeEventListeners(nodeEl);
            if(!id) saveState();
            return nodeEl;
        }

        function updateMultipleChoiceConnectors(nodeEl, count) {
            nodeEl.querySelectorAll('.connector.output').forEach(c => c.remove());
            const totalHeight = nodeEl.offsetHeight;
            const spacing = totalHeight / (count + 1);
            for (let i = 0; i < count; i++) {
                const connector = document.createElement('div');
                connector.className = 'connector output';
                connector.dataset.choice = i;
                connector.style.top = `${spacing * (i + 1)}px`;
                connector.style.transform = 'translateY(-50%)';
                nodeEl.appendChild(connector);
            }
            setupNodeEventListeners(nodeEl); // Re-attach listeners to new connectors
        }

        function setupNodeEventListeners(nodeEl) {
            const addBtn = nodeEl.querySelector('.add-btn');
            if (addBtn) {
                addBtn.onclick = () => { // Use onclick to prevent multiple bindings
                    const node = nodes[nodeEl.id];
                    const newOptionText = `Opção ${node.content.length}`;
                    node.content.push(newOptionText);
                    const newIndex = node.content.length - 2;
                    const container = nodeEl.querySelector('#buttons-container');
                    container.insertAdjacentHTML('beforeend', `<div class="button-option" data-index="${newIndex}"><input type="text" value="${newOptionText}"><i class="fas fa-times remove-btn"></i></div>`);
                    updateMultipleChoiceConnectors(nodeEl, node.content.length - 1);
                    setupNodeEventListeners(nodeEl);
                    saveState();
                };
            }
            nodeEl.querySelectorAll('.remove-btn').forEach(btn => {
                btn.onclick = () => {
                    const node = nodes[nodeEl.id];
                    const optionDiv = btn.closest('.button-option');
                    const indexToRemove = parseInt(optionDiv.dataset.index, 10);
                    node.content.splice(indexToRemove + 1, 1);
                    optionDiv.remove();
                    // Re-index remaining options
                    nodeEl.querySelectorAll('.button-option').forEach((div, i) => div.dataset.index = i);
                    updateMultipleChoiceConnectors(nodeEl, node.content.length - 1);
                    saveState();
                };
            });
             const inputs = nodeEl.querySelectorAll('textarea, input');
            inputs.forEach((input) => {
                 input.addEventListener('input', () => {
                     nodes[nodeEl.id].content = Array.from(nodeEl.querySelectorAll('textarea, #buttons-container input, input[type=number]')).map(i => i.value);
                    saveState();
                });
            });
             nodeEl.querySelectorAll('.connector').forEach(c => c.addEventListener('mousedown', (e) => { e.stopPropagation(); handleConnectorClick(nodeEl.id, c); }));
        }

        function makeNodeDraggable(nodeEl) {
            let offsetX, offsetY;
            const onMouseMove = (e) => {
                const newCoords = toCanvasCoords({clientX: e.clientX - offsetX, clientY: e.clientY - offsetY});
                nodeEl.style.left = `${newCoords.x}px`;
                nodeEl.style.top = `${newCoords.y}px`;
                nodes[nodeEl.id].x = newCoords.x;
                nodes[nodeEl.id].y = newCoords.y;
                updateConnectionsForNode(nodeEl.id);
            };
            const onMouseUp = () => {
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                saveState();
            };
            nodeEl.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.classList.contains('connector')) return;
                selectNode(nodeEl.id);
                const startCoords = toCanvasCoords(e);
                offsetX = startCoords.x - nodes[nodeEl.id].x;
                offsetY = startCoords.y - nodes[nodeEl.id].y;
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            });
        }
        function selectNode(nodeId) { if (selectedNodeId && nodes[selectedNodeId]) nodes[selectedNodeId].el.classList.remove('selected'); selectedNodeId = nodeId; if (nodes[selectedNodeId]) nodes[selectedNodeId].el.classList.add('selected');}
        function deleteNode(nodeId) { connections = connections.filter(conn => conn.from !== nodeId && conn.to !== nodeId); nodes[nodeId].el.remove(); delete nodes[nodeId]; selectedNodeId = null; redrawAllConnections(); saveState(); }
        function handleConnectorClick(nodeId, connector) { if (isConnecting) { if (connector.classList.contains('input') && connectionStart.nodeId !== nodeId) { createConnection(connectionStart.nodeId, nodeId, connectionStart.choice); } resetConnectionState(); } else { if (connector.classList.contains('output')) { isConnecting = true; connectionStart = { nodeId, choice: connector.dataset.choice || null }; tempLine = document.createElementNS('http://www.w3.org/2000/svg', 'line'); tempLine.setAttribute('stroke', 'var(--primary-accent)'); tempLine.setAttribute('stroke-width', '3'); tempLine.setAttribute('stroke-dasharray', '5,5'); svgLayer.appendChild(tempLine); const startPos = getConnectorPosition(connector); tempLine.setAttribute('x1', startPos.x); tempLine.setAttribute('y1', startPos.y); document.addEventListener('mousemove', onDrawingConnection); document.addEventListener('mouseup', () => resetConnectionState(), { once: true }); } } }
        function onDrawingConnection(e) { if(!tempLine) return; const coords = toCanvasCoords(e); tempLine.setAttribute('x2', coords.x); tempLine.setAttribute('y2', coords.y); }
        function resetConnectionState() { isConnecting = false; connectionStart = {}; if (tempLine) tempLine.remove(); tempLine = null; document.removeEventListener('mousemove', onDrawingConnection); }
        function createConnection(fromId, toId, choice = null) { const existing = connections.findIndex(c => c.from === fromId && c.choice === choice); if (existing !== -1) connections.splice(existing, 1); connections.push({ from: fromId, to: toId, choice }); redrawAllConnections(); saveState(); }
        function getConnectorPosition(connectorEl) { const nodeRect = connectorEl.closest('.flow-node').getBoundingClientRect(); const canvasRect = canvasContainer.getBoundingClientRect(); const connectorRect = connectorEl.getBoundingClientRect(); return { x: (nodeRect.left - canvasRect.left - pan.x) / pan.scale + connectorEl.offsetLeft + connectorEl.offsetWidth / 2, y: (nodeRect.top - canvasRect.top - pan.y) / pan.scale + connectorEl.offsetTop + connectorEl.offsetHeight / 2 }; }
        function updateConnectionsForNode(nodeId) { connections.forEach(conn => { if (conn.from === nodeId || conn.to === nodeId) { const fromNode = nodes[conn.from], toNode = nodes[conn.to]; if (!fromNode || !toNode) return; const fromConnector = conn.choice !== null ? fromNode.el.querySelector(`.connector.output[data-choice="\${conn.choice}"]`) : fromNode.el.querySelector('.connector.output'); const toConnector = toNode.el.querySelector('.connector.input'); if (!fromConnector || !toConnector) return; const startPos = getConnectorPosition(fromConnector); const endPos = getConnectorPosition(toConnector); if(conn.lineEl) { conn.lineEl.setAttribute('x1', startPos.x); conn.lineEl.setAttribute('y1', startPos.y); conn.lineEl.setAttribute('x2', endPos.x); conn.lineEl.setAttribute('y2', endPos.y); } } }); }
        function redrawAllConnections() { svgLayer.innerHTML = ''; connections.forEach(conn => { if (nodes[conn.from] && nodes[conn.to]) { const line = document.createElementNS('http://www.w3.org/2000/svg', 'line'); line.setAttribute('stroke', 'var(--connector-color)'); line.setAttribute('stroke-width', '3'); conn.lineEl = line; svgLayer.appendChild(line); updateConnectionsForNode(conn.from); } }); }
        
        // LÓGICA DE IMPORTAR / EXPORTAR / LIMPAR
        exportFlowBtn.addEventListener('click', () => { const dataStr = JSON.stringify({ nodes: Object.values(nodes).map(n => ({id:n.id, type:n.type, x:n.x, y:n.y, content: n.content})), connections, nodeIdCounter, pan }, null, 2); const blob = new Blob([dataStr], {type: 'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = 'flow.json'; a.click(); URL.revokeObjectURL(url); });
        importFlowBtn.addEventListener('click', () => importFileInput.click());
        importFileInput.addEventListener('change', (e) => { const file = e.target.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = (event) => { try { const data = JSON.parse(event.target.result); if (confirm('Isto irá substituir o fluxo atual. Tem a certeza?')) { loadState(data); } } catch (err) { alert('Erro ao ler o ficheiro.'); } }; reader.readAsText(file); e.target.value = ''; });
        function resetCanvas() { nodes = {}; connections = []; selectedNodeId = null; flowCanvas.innerHTML = '<svg id="svg-layer"></svg>';}
        function saveState() { const state = { nodes: Object.values(nodes).map(n=>({id:n.id, type:n.type, x:n.x, y:n.y, content:n.content})), connections, nodeIdCounter, pan }; localStorage.setItem('chatFlowBuilderState', JSON.stringify(state));}
        function loadState(data = null) { const state = data || JSON.parse(localStorage.getItem('chatFlowBuilderState')); if (!state) return; resetCanvas(); nodeIdCounter = state.nodeIdCounter; pan = state.pan || {x:0, y:0, scale:1, isPanning:false, startX:0, startY:0}; updateCanvasTransform(); if (state.nodes) state.nodes.forEach(n => createNode(n.type, n.x, n.y, n.id, n.content)); connections = state.connections || []; redrawAllConnections(); }
        clearFlowBtn.addEventListener('click', () => { if (confirm('Tem a certeza?')) { resetCanvas(); nodeIdCounter = 0; createNode('start', 50, 150, 'node-0'); saveState(); } });
        
        function init() { loadState(); if (Object.keys(nodes).length === 0) createNode('start', 50, 150, 'node-0'); }
        init();
    });
    </script>
</body>
</html>
