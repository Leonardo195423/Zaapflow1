<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZAPFLOW - Chat Interativo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --panel-color: #16213e;
            --canvas-color: #0f1524;
            --primary-accent: #e94560;
            --secondary-accent: #4fc3f7;
            --success-color: #25D366;
            --warning-color: #f7b731;
            --text-light: #e0e0e0;
            --border-color: #2c3e50;
            --shadow-color: rgba(0, 0, 0, 0.4);
            --connector-color: #6c757d; /* Default connector color */
            --button-hover-dark: #c33a50; /* Darker primary accent for hover */
            --button-hover-light: #6ad1fc; /* Lighter secondary accent for hover */
        }

        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh;
            display: flex;
        }

        .hidden { display: none !important; }

        /* --- TELA DE LOGIN --- */
        #login-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background-image: url('https://i.ibb.co/B5CH90Vp/Chat-GPT-Image-29-de-jun-de-2025-23-12-16.png');
            background-size: cover; background-position: center;
            z-index: 1000;
        }
        #login-box {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 40px; border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            width: 100%; max-width: 400px; text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #login-box h2 { font-size: 2.5rem; margin-bottom: 10px; color: #fff; }
        #login-box p { color: #ccc; margin-bottom: 30px; }
        .input-group { margin-bottom: 20px; text-align: left; }
        .input-group label { display: block; margin-bottom: 8px; color: #ccc; }
        .input-group input { width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: #fff; font-size: 1rem; }
        .input-group input:focus { outline: none; border-color: var(--primary-accent); }
        #login-button { width: 100%; padding: 15px; background: var(--primary-accent); border: none; border-radius: 8px; color: #fff; font-size: 1.2rem; font-weight: bold; cursor: pointer; transition: background-color 0.3s; }
        #login-button:hover { background-color: var(--button-hover-dark); }
        #login-error { color: #ff5555; margin-top: 15px; height: 20px; }

        /* --- LAYOUT PRINCIPAL DA APLICA√á√ÉO --- */
        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr 420px;
            width: 100%;
            height: 100%;
            gap: 10px;
            padding: 10px;
        }

        .panel {
            background-color: var(--panel-color);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 15px var(--shadow-color);
            z-index: 10;
        }
        .panel-header {
            font-size: 1.4em;
            font-weight: 700;
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            color: var(--primary-accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .panel-header i { margin-right: 10px; }
        #logout-button { background: none; border: none; color: var(--primary-accent); cursor: pointer; font-size: 1.2rem; }
        #logout-button:hover { color: var(--button-hover-dark); }
        
        /* --- PAINEL LATERAL DE BLOCOS --- */
        #side-panel .node-template {
            background-color: var(--canvas-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: grab;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: 500;
            font-size: 0.95em;
        }
        #side-panel .node-template:hover {
            background-color: #2c3e50;
            transform: translateY(-2px);
        }
        #side-panel .node-template i {
            margin-right: 10px;
            color: var(--secondary-accent);
            width: 20px;
            text-align: center;
        }
        #side-panel .controls {
            margin-top: auto;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        .control-btn {
            padding: 12px 10px;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            font-size: 0.9em;
        }
        .control-btn:hover { transform: translateY(-2px); }
        #run-flow-btn { background-color: var(--primary-accent); grid-column: 1 / -1; }
        #run-flow-btn:hover { background-color: var(--button-hover-dark); }
        #clear-flow-btn { background-color: #555; }
        #clear-flow-btn:hover { background-color: #777; }
        #download-html-btn { background-color: var(--success-color); }
        #download-html-btn:hover { background-color: #128C7E; }
        #import-flow-btn { background-color: var(--warning-color); }
        #import-flow-btn:hover { background-color: #f7a000; }
        #export-flow-btn { background-color: var(--secondary-accent); }
        #export-flow-btn:hover { background-color: var(--button-hover-light); }
        
        /* --- CANVAS CENTRAL --- */
        #canvas-container {
            position: relative;
            background-color: var(--canvas-color);
            background-image: radial-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 20px 20px;
            border-radius: 12px;
            overflow: hidden;
            cursor: grab;
        }
        #canvas-container:active { cursor: grabbing; }

        #flow-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            transform-origin: 0 0;
        }
        
        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Remove pointer-events: none; so that clicks on SVG lines can be detected for deletion */
            /* We will manage click throughs directly in JS if needed */
        }

        /* --- BLOCOS NO CANVAS --- */
        .flow-node {
            position: absolute;
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 240px;
            min-height: 80px;
            box-shadow: 0 4px 12px var(--shadow-color);
            cursor: move;
            transition: box-shadow 0.3s, border-color 0.3s;
            display: flex;
            flex-direction: column;
            z-index: 5; /* Ensure nodes are above SVG lines by default */
        }
        .flow-node.selected {
            border-color: var(--primary-accent);
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
            z-index: 6; /* Bring selected node to front */
        }
        .flow-node.dragging {
            z-index: 9999 !important; /* Extremely high z-index to ensure it's always on top */
        }

        .node-header {
            background-color: #2c3e50;
            color: var(--text-light);
            padding: 8px 10px;
            font-weight: bold;
            border-top-left-radius: 7px;
            border-top-right-radius: 7px;
            display: flex; /* Added for delete button alignment */
            justify-content: space-between; /* Added for delete button alignment */
            align-items: center; /* Added for delete button alignment */
        }
        .node-header i { margin-right: 8px; }
        /* Style for the delete button */
        .delete-node-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 1em;
            cursor: pointer;
            margin-left: 10px;
            transition: color 0.2s;
        }
        .delete-node-btn:hover {
            color: var(--primary-accent);
        }

        .node-content {
            padding: 10px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .node-content textarea, .node-content input {
            width: 100%;
            background-color: var(--canvas-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-light);
            padding: 8px;
            resize: vertical;
        }
        .node-content textarea { min-height: 40px; }
        .node-content textarea:focus, .node-content input:focus {
            outline: none;
            border-color: var(--secondary-accent);
        }
        .node-content label {
            font-size: 0.8em;
            color: var(--text-light-muted, #aaa);
            margin-bottom: -4px;
        }
        .flow-node[data-type="start"] { border-color: var(--success-color); }
        .flow-node[data-type="start"] .node-header { background-color: #128C7E; }
        .flow-node[data-type="question"], .flow-node[data-type="multipleChoice"] { border-color: var(--secondary-accent); }
        .flow-node[data-type="question"] .node-header, .flow-node[data-type="multipleChoice"] .node-header { background-color: #3b5998; }
        
        .connector {
            width: 16px; height: 16px;
            background-color: #fff;
            border: 2px solid var(--connector-color);
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            transition: background-color 0.3s, border-color 0.3s;
            z-index: 10; /* Keep connectors on top of node content */
        }
        .connector:hover { 
            background-color: var(--primary-accent); 
            border-color: var(--primary-accent); /* Highlight border on hover */
        }
        /* Style for highlighted input connector during connection attempt */
        .connector.highlight-target {
            background-color: var(--secondary-accent) !important; /* Override with highlight color */
            border-color: var(--primary-accent) !important; /* Stronger border */
            box-shadow: 0 0 8px rgba(233, 69, 96, 0.7); /* Subtle glow */
        }
        .connector.output { right: -8px; }
        .connector.input { left: -8px; top: 50%; transform: translateY(-50%); }

        .button-option { display: flex; align-items: center; gap: 5px; }
        .button-option input { flex-grow: 1; }
        .remove-btn { cursor: pointer; color: #e94560; }
        .remove-btn:hover { color: var(--button-hover-dark); }
        .add-btn {
            background: none; border: 1px dashed var(--connector-color); color: var(--connector-color);
            padding: 5px; border-radius: 4px; cursor: pointer; margin-top: 5px;
        }
        .add-btn:hover { background-color: rgba(255,255,255,0.05); }

        /* --- PR√â-VISUALIZA√á√ÉO (CELULAR) --- */
        #preview-panel { align-items: center; justify-content: center; }
        .mobile-preview {
            width: 100%; max-width: 380px; height: 95%; background-color: #111;
            border-radius: 40px; border: 10px solid #000; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; overflow: hidden;
        }
        .chat-header {
            background-color: #075E54; color: white; padding: 10px 15px; display: flex;
            align-items: center; gap: 15px; flex-shrink: 0;
        }
        .chat-header img { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; }
        .chat-header .name { font-weight: bold; }
        .chat-header .status { font-size: 0.8em; color: #d1d1d1; }
        .chat-body {
            flex-grow: 1; padding: 15px 10px; overflow-y: auto; display: flex; flex-direction: column;
            gap: 12px; background-color: #e5ddd5;
            background-image: url('https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png');
        }
        .message { max-width: 80%; padding: 8px 12px; border-radius: 8px; line-height: 1.4; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .message.received { background-color: #ffffff; align-self: flex-start; }
        .message.sent { background-color: #dcf8c6; align-self: flex-end; }
        .message img { max-width: 100%; border-radius: 8px; margin-top: 5px; }
        .typing-indicator { align-self: flex-start; padding: 10px 15px; display: flex; align-items: center; justify-content: center; background-color: #ffffff; border-radius: 8px; max-width: 80px; }
        .typing-indicator span { height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out; }
        .typing-indicator span:nth-child(2) { animation-delay: 0.1s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.2s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        .choice-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; padding: 5px 10px; align-self: flex-end; }
        .choice-button { background-color: #fff; border: 1px solid #075E54; color: #075E54; padding: 8px 15px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: background-color 0.2s, color 0.2s; }
        .choice-button:hover { background-color: #075E54; color: white; }
        .cta-button-container { padding: 10px; align-self: stretch; }
        .cta-button { background: linear-gradient(45deg, #25D366, #128C7E); color: white; text-align: center; text-decoration: none; font-size: 1.1em; font-weight: bold; padding: 15px; border-radius: 30px; display: block; transition: transform 0.2s; }
        .cta-button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .user-input-container { display: flex; gap: 5px; margin-top: 10px; align-self: stretch; }
        .user-input-container input { flex-grow: 1; padding: 8px; border-radius: 20px; border: 1px solid #ccc; }
        .user-input-container button { padding: 8px 15px; border-radius: 20px; border: none; background-color: #075E54; color: white; cursor: pointer; }


        /* --- CUSTOM MODAL --- */
        .custom-modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000;
        }
        .custom-modal {
            background-color: var(--panel-color);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 20px var(--shadow-color);
            max-width: 450px;
            width: 90%;
            text-align: center;
            border: 1px solid var(--border-color);
        }
        .custom-modal h3 {
            color: var(--primary-accent);
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        .custom-modal p {
            color: var(--text-light);
            margin-bottom: 30px;
            line-height: 1.5;
        }
        .custom-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .custom-modal-buttons button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        .custom-modal-buttons .confirm-btn {
            background-color: var(--primary-accent);
            color: white;
        }
        .custom-modal-buttons .confirm-btn:hover {
            background-color: var(--button-hover-dark);
            transform: translateY(-2px);
        }
        .custom-modal-buttons .cancel-btn {
            background-color: #555;
            color: white;
        }
        .custom-modal-buttons .cancel-btn:hover {
            background-color: #777;
            transform: translateY(-2px);
        }
    </style>
</head>
<body>

    <!-- TELA DE LOGIN -->
    <div id="login-screen">
        <div id="login-box">
            <h2>Bem-vindo ao ZAPFLOW</h2>
            <p>Fa√ßa login para aceder ao Flow Builder</p>
            <form id="login-form">
                <div class="input-group">
                    <label for="username">Utilizador</label>
                    <input type="text" id="username" value="admin" required>
                </div>
                <div class="input-group">
                    <label for="password">Senha</label>
                    <input type="password" id="password" value="admin123" required>
                </div>
                <div id="login-error"></div>
                <button type="submit" id="login-button">Entrar</button>
            </form>
        </div>
    </div>

    <!-- APLICA√á√ÉO PRINCIPAL (INICIALMENTE OCULTA) -->
    <div id="app-container" class="app-container hidden">
        <div id="side-panel" class="panel">
            <div class="panel-header">
                <span><i class="fas fa-sitemap"></i> Blocos do Fluxo</span>
                <button id="logout-button" title="Sair"><i class="fas fa-sign-out-alt"></i></button>
            </div>
            <div class="node-template" draggable="true" data-type="message">
                <i class="fas fa-comment-dots"></i> Mensagem do Bot
            </div>
            <div class="node-template" draggable="true" data-type="image">
                <i class="fas fa-image"></i> Imagem
            </div>
            <div class="node-template" draggable="true" data-type="question">
                <i class="fas fa-question-circle"></i> Pergunta (Sim/N√£o)
            </div>
            <div class="node-template" draggable="true" data-type="multipleChoice">
                <i class="fas fa-check-double"></i> M√∫ltiplas Escolhas
            </div>
            <div class="node-template" draggable="true" data-type="userInput">
                <i class="fas fa-keyboard"></i> Entrada do Utilizador
            </div>
            <div class="node-template" draggable="true" data-type="delay">
                <i class="fas fa-clock"></i> Atraso / Pausa
            </div>
            <div class="node-template" draggable="true" data-type="cta">
                <i class="fas fa-rocket"></i> Bot√£o Final (CTA)
            </div>

            <div class="controls">
                <button id="run-flow-btn" class="control-btn"><i class="fas fa-play"></i> Testar Fluxo</button>
                <button id="import-flow-btn" class="control-btn"><i class="fas fa-upload"></i> Importar Fluxo</button>
                <button id="export-flow-btn" class="control-btn"><i class="fas fa-download"></i> Exportar Fluxo</button>
                <button id="clear-flow-btn" class="control-btn"><i class="fas fa-trash-alt"></i> Limpar</button>
                <button id="download-html-btn" class="control-btn"><i class="fas fa-code"></i> Baixar HTML</button>
                <input type="file" id="import-file-input" style="display: none;" accept=".json">
            </div>
        </div>

        <div id="canvas-container">
            <div id="flow-canvas">
                <!-- A camada SVG agora est√° DENTRO do flow-canvas para herdar transforma√ß√µes -->
                <svg id="svg-layer">
                    <!-- Defini√ß√£o da ponta de seta foi removida conforme solicitado -->
                </svg>
                <!-- Os n√≥s ser√£o adicionados aqui como filhos diretos do flow-canvas -->
            </div>
        </div>

        <div id="preview-panel" class="panel">
            <div class="panel-header"><i class="fas fa-mobile-alt"></i> Pr√©-visualiza√ß√£o</div>
            <div class="mobile-preview">
                <div class="chat-header">
                    <img src="https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png" alt="Atendente">
                    <div class="contact-info">
                        <div class="name">ZAPFLOW BOT</div>
                        <div class="status">online</div>
                    </div>
                </div>
                <div class="chat-body" id="preview-chat-body"></div>
            </div>
        </div>
    </div>

    <!-- CUSTOM MODAL HTML -->
    <div id="custom-modal-overlay" class="custom-modal-overlay hidden">
        <div class="custom-modal">
            <h3 id="modal-title"></h3>
            <p id="modal-message"></p>
            <div class="custom-modal-buttons">
                <button id="modal-confirm-btn" class="confirm-btn">Confirmar</button>
                <button id="modal-cancel-btn" class="cancel-btn">Cancelar</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- L√ìGICA DO MODAL CUSTOMIZADO ---
        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        let onConfirmCallback;
        let onCancelCallback;

        /**
         * Exibe um modal de confirma√ß√£o customizado.
         * @param {string} title - O t√≠tulo do modal.
         * @param {string} message - A mensagem a ser exibida no modal.
         * @param {function} onConfirm - Fun√ß√£o de callback a ser executada se confirmado.
         * @param {function} [onCancel] - Fun√ß√£o de callback opcional a ser executada se cancelado.
         */
        function showConfirmModal(title, message, onConfirm, onCancel) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            onConfirmCallback = onConfirm;
            onCancelCallback = onCancel;
            
            modalCancelBtn.classList.remove('hidden'); // Certifica-se de que o bot√£o de cancelar est√° vis√≠vel

            modalConfirmBtn.onclick = () => {
                modalOverlay.classList.add('hidden');
                if (onConfirmCallback) onConfirmCallback();
            };
            modalCancelBtn.onclick = () => {
                modalOverlay.classList.add('hidden');
                if (onCancelCallback) onCancelCallback();
            };

            modalOverlay.classList.remove('hidden');
        }

        /**
         * Exibe um modal de alerta customizado (apenas bot√£o de confirma√ß√£o).
         * @param {string} title - O t√≠tulo do modal.
         * @param {string} message - A mensagem a ser exibida no modal.
         * @param {function} [onClose] - Fun√ß√£o de callback opcional a ser executada quando fechado.
         */
        function showAlertModal(title, message, onClose) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalCancelBtn.classList.add('hidden'); // Oculta o bot√£o de cancelar para alertas
            
            onConfirmCallback = onClose; // Usa o bot√£o de confirma√ß√£o para fechar o alerta
            modalConfirmBtn.onclick = () => {
                modalOverlay.classList.add('hidden');
                modalCancelBtn.classList.remove('hidden'); // Mostra o bot√£o de cancelar para o pr√≥ximo uso
                if (onConfirmCallback) onConfirmCallback();
            };

            modalOverlay.classList.remove('hidden');
        }


        // --- L√ìGICA DE LOGIN ---
        const loginScreen = document.getElementById('login-screen');
        const appContainer = document.getElementById('app-container');
        const loginForm = document.getElementById('login-form');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const loginError = document.getElementById('login-error');
        const logoutButton = document.getElementById('logout-button');

        loginForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const username = usernameInput.value;
            const password = passwordInput.value;

            if (username === 'admin' && password === 'admin123') {
                loginScreen.classList.add('hidden');
                appContainer.classList.remove('hidden');
                initFlowBuilder(); // Inicia o builder S√ì depois do login
            } else {
                loginError.textContent = 'Utilizador ou senha inv√°lidos.';
                setTimeout(() => loginError.textContent = '', 3000);
            }
        });

        logoutButton.addEventListener('click', () => {
            showConfirmModal('Sair?', 'Tem a certeza que deseja sair?',
                () => {
                    loginScreen.classList.remove('hidden');
                    appContainer.classList.add('hidden');
                }
            );
        });
        
        // --- IN√çCIO DO C√ìDIGO DO FLOW BUILDER ---
        function initFlowBuilder() {
            const sidePanel = document.getElementById('side-panel'),
                canvasContainer = document.getElementById('canvas-container'),
                flowCanvas = document.getElementById('flow-canvas'),
                svgLayer = document.getElementById('svg-layer'), // svgLayer agora √© filho de flowCanvas
                runFlowBtn = document.getElementById('run-flow-btn'),
                clearFlowBtn = document.getElementById('clear-flow-btn'),
                downloadHtmlBtn = document.getElementById('download-html-btn'),
                previewChatBody = document.getElementById('preview-chat-body'),
                importFlowBtn = document.getElementById('import-flow-btn'),
                exportFlowBtn = document.getElementById('export-flow-btn'),
                importFileInput = document.getElementById('import-file-input');

            let nodes = {}, connections = [], nodeIdCounter = 0, selectedNodeId = null,
                isConnecting = false, connectionStart = {};
            let pan = { x: 0, y: 0, scale: 1, isPanning: false, startX: 0, startY: 0 };
            let currentTempLine = null; // Usado para desenhar a linha de conex√£o tempor√°ria
            let hoveredInputConnector = null; // Track currently highlighted input connector

            // --- L√ìGICA DE ZOOM E PANOR√ÇMICA ---
            canvasContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvasContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const oldScale = pan.scale;
                const newScale = oldScale * (e.deltaY > 0 ? 0.9 : 1.1);
                pan.scale = Math.max(0.2, Math.min(newScale, 2));

                // Ajusta o pan para que o zoom seja no ponto do mouse
                pan.x = mouseX - (mouseX - pan.x) * (pan.scale / oldScale);
                pan.y = mouseY - (mouseY - pan.y) * (pan.scale / oldScale);
                
                updateCanvasTransform();
            });

            canvasContainer.addEventListener('mousedown', (e) => {
                // Se o clique for em um n√≥ ou em um conector, n√£o inicie o pan do canvas.
                if (e.target.closest('.flow-node')) {
                    const clickedNode = e.target.closest('.flow-node');
                    // Somente seleciona o n√≥ se o clique n√£o for em um input/textarea/conector,
                    // caso contr√°rio, permite a intera√ß√£o com o elemento filho.
                    if (e.target.tagName !== 'TEXTAREA' && e.target.tagName !== 'INPUT' && !e.target.classList.contains('connector') && !e.target.classList.contains('delete-node-btn')) {
                        selectNode(clickedNode.id);
                    }
                    return; // Permite que o makeNodeDraggable ou handleConnectorClick lidem com o evento
                }
                
                selectNode(null); // Desseleciona qualquer n√≥ ao iniciar a panor√¢mica do canvas
                pan.isPanning = true;
                pan.startX = e.clientX;
                pan.startY = e.clientY;
            });

            canvasContainer.addEventListener('mousemove', (e) => {
                if (!pan.isPanning) return;
                pan.x += e.clientX - pan.startX;
                pan.y += e.clientY - pan.startY;
                pan.startX = e.clientX;
                pan.startY = e.clientY; 
                updateCanvasTransform();
            });

            canvasContainer.addEventListener('mouseup', () => pan.isPanning = false);
            canvasContainer.addEventListener('mouseleave', () => pan.isPanning = false);

            function updateCanvasTransform() {
                flowCanvas.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${pan.scale})`;
                redrawAllConnections(); 
            }

            // Converte coordenadas da tela para coordenadas do canvas (n√£o transformado)
            function toCanvasCoords(e) {
                const rect = flowCanvas.getBoundingClientRect(); // Use flowCanvas rect as it's the transformed one
                const xOnCanvas = e.clientX - rect.left;
                const yOnCanvas = e.clientY - rect.top;
                return {
                    x: xOnCanvas / pan.scale, // Un-scale relative to flowCanvas's internal coords
                    y: yOnCanvas / pan.scale  // Un-scale relative to flowCanvas's internal coords
                };
            }

            // --- L√ìGICA DRAG & DROP ---
            // Adiciona listener para arrastar de templates de n√≥ do painel lateral
            sidePanel.querySelectorAll('.node-template').forEach(template => {
                template.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', e.target.dataset.type);
                    e.dataTransfer.setDragImage(new Image(), 0, 0); // Hide the default drag image
                });
            });

            // Permite soltar no canvas
            canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
            canvasContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                const type = e.dataTransfer.getData('text/plain');
                if (!type) return; // Se n√£o houver tipo, n√£o √© um arraste de template
                const coords = toCanvasCoords(e);
                createNode(type, coords.x, coords.y);
            });

            // --- CRIA√á√ÉO DE BLOCOS ---
            /**
             * Cria um novo bloco (n√≥) no canvas.
             * @param {string} type - O tipo do n√≥ (e.g., 'message', 'question').
             * @param {number} x - Posi√ß√£o X no canvas.
             * @param {number} y - Posi√ß√£o Y no canvas.
             * @param {string|null} id - ID opcional para o n√≥ (usado ao carregar estado).
             * @param {Array<string>} content - Conte√∫do inicial do n√≥.
             * @returns {HTMLElement} O elemento do n√≥ criado.
             */
            function createNode(type, x, y, id = null, content = []) {
                const nodeId = id || `node-${nodeIdCounter++}`;
                const nodeEl = document.createElement('div');
                nodeEl.className = 'flow-node';
                nodeEl.id = nodeId;
                nodeEl.dataset.type = type;
                nodeEl.style.left = `${x}px`;
                nodeEl.style.top = `${y}px`;

                let headerText = '', headerIcon = '', contentHtml = '';
                let hasInputConnector = true, hasOutputConnector = true;

                switch(type) {
                    case 'start':
                        headerText = 'In√≠cio';
                        headerIcon = 'fa-flag-checkered';
                        contentHtml = `<p style="text-align:center;">Ponto de partida do fluxo</p>`;
                        hasInputConnector = false; // N√£o tem entrada
                        break;
                    case 'message':
                        headerText = 'Mensagem';
                        headerIcon = 'fa-comment-dots';
                        contentHtml = `<label>Texto da Mensagem:</label><textarea placeholder="Digite a mensagem do bot">${content[0] || ''}</textarea>`;
                        break;
                    case 'image':
                        headerText = 'Imagem';
                        headerIcon = 'fa-image';
                        contentHtml = `<label>URL da Imagem:</label><textarea placeholder="https://exemplo.com/imagem.png">${content[0] || ''}</textarea>`;
                        break;
                    case 'question':
                        headerText = 'Pergunta (Sim/N√£o)';
                        headerIcon = 'fa-question-circle';
                        contentHtml = `<label>Texto da Pergunta:</label><textarea placeholder="Fa√ßa uma pergunta (Sim/N√£o)">${content[0] || ''}</textarea>`;
                        break;
                    case 'userInput':
                        headerText = 'Entrada do Utilizador';
                        headerIcon = 'fa-keyboard';
                        contentHtml = `
                            <label>Texto da Pergunta:</label>
                            <textarea placeholder="Pergunte algo ao utilizador">${content[0] || ''}</textarea>
                            <label>Vari√°vel para Salvar:</label>
                            <input type="text" placeholder="Nome da vari√°vel (ex: nome)" value="${content[1] || ''}">
                        `;
                        break;
                    case 'delay':
                        headerText = 'Atraso / Pausa';
                        headerIcon = 'fa-clock';
                        contentHtml = `<label>Dura√ß√£o do Atraso (ms):</label><input type="number" placeholder="1500" value="${content[0] || '1500'}">`;
                        break;
                    case 'cta':
                        headerText = 'Bot√£o Final (CTA)';
                        headerIcon = 'fa-rocket';
                        contentHtml = `
                            <label>Texto do Bot√£o:</label><textarea placeholder="Comprar Agora">${content[0] || 'Comprar Agora'}</textarea>
                            <label>URL do Link:</label><textarea placeholder="https://seusite.com">${content[1] || ''}</textarea>
                        `;
                        hasOutputConnector = false; // N√£o tem sa√≠da
                        break;
                    case 'multipleChoice':
                        headerText = 'M√∫ltiplas Escolhas';
                        headerIcon = 'fa-check-double';
                        let buttonsHtml = '';
                        // O primeiro item do content √© a pergunta, os restantes s√£o as op√ß√µes
                        const options = content.length > 1 ? content.slice(1) : ['Op√ß√£o 1'];
                        buttonsHtml = options.map((text, i) =>
                            `<div class="button-option" data-index="${i}"><input type="text" value="${text}"><i class="fas fa-times remove-btn"></i></div>`
                        ).join('');
                        
                        contentHtml = `
                            <label>Texto da Pergunta:</label>
                            <textarea placeholder="Fa√ßa uma pergunta com op√ß√µes">${content[0] || ''}</textarea>
                            <label>Op√ß√µes:</label>
                            <div id="buttons-container">${buttonsHtml}</div>
                            <button class="add-btn"><i class="fas fa-plus"></i> Adicionar Op√ß√£o</button>
                        `;
                        break;
                    default:
                        headerText = 'Tipo Desconhecido';
                        headerIcon = 'fa-times-circle';
                        contentHtml = `<p>Tipo de n√≥ desconhecido: ${type}</p>`;
                        break;
                }

                nodeEl.innerHTML = `
                    <div class="node-header"><i class="fas ${headerIcon}"></i> ${headerText} <i class="fas fa-trash-alt delete-node-btn"></i></div>
                    <div class="node-content">${contentHtml}</div>
                `;
                
                // Adiciona conectores de entrada
                if (hasInputConnector) {
                    nodeEl.insertAdjacentHTML('beforeend', `<div class="connector input"></div>`);
                }
                
                // Adiciona conectores de sa√≠da
                if (hasOutputConnector) {
                    if (type === 'question') {
                        // Conectores espec√≠ficos para Sim/N√£o
                        nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" data-choice="yes" style="top: 35%;"></div>`);
                        nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" data-choice="no" style="top: 65%;"></div>`);
                    } else if (type === 'multipleChoice') {
                        // Conectores para m√∫ltiplas escolhas s√£o adicionados dinamicamente
                        // `updateMultipleChoiceConnectors` ser√° chamado logo ap√≥s a cria√ß√£o do n√≥
                    } else {
                        // Conector de sa√≠da padr√£o para outros tipos de n√≥s
                        nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" style="top: 50%; transform: translateY(-50%);"></div>`);
                    }
                }

                flowCanvas.appendChild(nodeEl); // Adiciona o n√≥ diretamente ao flowCanvas

                // Inicializa ou atualiza os dados do n√≥
                nodes[nodeId] = {
                    id: nodeId,
                    el: nodeEl,
                    type: type,
                    x: x,
                    y: y,
                    // Garante que o content seja inicializado corretamente
                    content: content.length > 0 ? content : (type === 'multipleChoice' ? ['Nova Pergunta?', 'Op√ß√£o 1'] : [''])
                };
                // Atualiza o content para userInput e cta, que t√™m m√∫ltiplos campos
                if (type === 'userInput') {
                    nodes[nodeId].content = [content[0] || '', content[1] || ''];
                } else if (type === 'cta') {
                    nodes[nodeId].content = [content[0] || 'Comprar Agora', content[1] || ''];
                } else if (type === 'delay') {
                    nodes[nodeId].content = [content[0] || '1500'];
                }


                // Para n√≥s de m√∫ltipla escolha, atualiza os conectores e o content
                if (type === 'multipleChoice') {
                    // Certifica que content[0] √© a pergunta e o resto s√£o as op√ß√µes
                    if (content.length === 0) {
                        nodes[nodeId].content = ['Nova Pergunta?', 'Op√ß√£o 1'];
                    } else if (content.length === 1) {
                        nodes[nodeId].content = [content[0], 'Op√ß√£o 1'];
                    }
                    updateMultipleChoiceConnectors(nodeEl, nodes[nodeId].content.length - 1);
                }

                makeNodeDraggable(nodeEl);
                setupNodeEventListeners(nodeEl);
                if (!id) saveState(); // Salva o estado apenas se for um novo n√≥
                return nodeEl;
            }

            /**
             * Atualiza os conectores de sa√≠da para n√≥s de m√∫ltipla escolha.
             * Recalcula suas posi√ß√µes baseadas no n√∫mero de op√ß√µes.
             * @param {HTMLElement} nodeEl - O elemento do n√≥.
             * @param {number} count - O n√∫mero de op√ß√µes (e, portanto, de conectores de sa√≠da).
             */
            function updateMultipleChoiceConnectors(nodeEl, count) {
                // Remove conectores de sa√≠da existentes para redesenhar
                nodeEl.querySelectorAll('.connector.output').forEach(c => c.remove());
                
                // For√ßa um reflow para garantir que offsetHeight seja preciso
                nodeEl.offsetHeight; 

                const headerHeight = nodeEl.querySelector('.node-header').offsetHeight;
                const nodeContentEl = nodeEl.querySelector('.node-content');
                const contentPaddingTop = parseFloat(window.getComputedStyle(nodeContentEl).paddingTop);
                const contentPaddingBottom = parseFloat(window.getComputedStyle(nodeContentEl).paddingBottom);
                const buttonsContainerHeight = nodeEl.querySelector('#buttons-container').offsetHeight;
                const addBtnHeight = nodeEl.querySelector('.add-btn') ? nodeEl.querySelector('.add-btn').offsetHeight : 0;
                const addBtnMarginTop = nodeEl.querySelector('.add-btn') ? parseFloat(window.getComputedStyle(nodeEl.querySelector('.add-btn')).marginTop) : 0;
                
                // Calcula a altura da √°rea de conte√∫do (texto da pergunta + op√ß√µes + bot√£o adicionar)
                // Subtrai 8px para o gap entre os elementos
                const contentAreaHeight = nodeEl.querySelector('textarea').offsetHeight + buttonsContainerHeight + addBtnHeight + addBtnMarginTop + 8;


                // A altura total dispon√≠vel para os conectores √© a altura do n√≥ menos a altura do cabe√ßalho
                // E tamb√©m menos o padding superior e inferior do node-content, e talvez a altura da textarea
                // O objetivo √© distribuir os conectores pelas op√ß√µes.

                // Vamos calcular a posi√ß√£o dos conectores relativos ao topo do `node-content`
                // A altura de cada op√ß√£o div √© din√¢mica. Precisamos somar as alturas das op√ß√µes.
                let currentY = headerHeight + contentPaddingTop; // Come√ßa ap√≥s o cabe√ßalho e o padding superior do conte√∫do
                const questionTextarea = nodeEl.querySelector('.node-content > textarea');
                if (questionTextarea) {
                    currentY += questionTextarea.offsetHeight + 8; // Altura da textarea + gap
                }
                
                nodeEl.querySelectorAll('.button-option').forEach((optionDiv, i) => {
                    const connector = document.createElement('div');
                    connector.className = 'connector output';
                    connector.dataset.choice = i; // Armazena o √≠ndice da op√ß√£o
                    
                    // Posi√ß√£o vertical do conector: centro da div da op√ß√£o
                    // currentY √© o topo da div da op√ß√£o. Add half of optionDiv.offsetHeight to center it.
                    connector.style.top = `${currentY + optionDiv.offsetHeight / 2}px`;
                    connector.style.transform = 'translateY(-50%)'; // Centraliza verticalmente
                    nodeEl.appendChild(connector);

                    currentY += optionDiv.offsetHeight + 8; // Avan√ßa para o pr√≥ximo item (+ gap)
                });

                setupNodeEventListeners(nodeEl); // Re-adiciona listeners para os novos conectores
                redrawAllConnections(); // Redesenha todas as conex√µes para atualizar as linhas
            }

            /**
             * Configura os event listeners para os elementos dentro de um n√≥ (inputs, bot√µes, conectores).
             * @param {HTMLElement} nodeEl - O elemento do n√≥.
             */
            function setupNodeEventListeners(nodeEl) {
                const addBtn = nodeEl.querySelector('.add-btn');
                if (addBtn) {
                    addBtn.onclick = () => {
                        const node = nodes[nodeEl.id];
                        const newOptionText = `Op√ß√£o ${node.content.length}`;
                        node.content.push(newOptionText); // Adiciona nova op√ß√£o ao conte√∫do
                        const newIndex = node.content.length - 2; // √çndice da nova op√ß√£o (ap√≥s a pergunta)
                        const container = nodeEl.querySelector('#buttons-container');
                        container.insertAdjacentHTML('beforeend', `<div class="button-option" data-index="${newIndex}"><input type="text" value="${newOptionText}"><i class="fas fa-times remove-btn"></i></div>`);
                        updateMultipleChoiceConnectors(nodeEl, node.content.length - 1); // Atualiza conectores
                        setupNodeEventListeners(nodeEl); // Re-setup listeners para o novo bot√£o de remover
                        saveState();
                    };
                }
                // Adiciona listeners para remover bot√µes de op√ß√£o
                nodeEl.querySelectorAll('.remove-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation(); // Prevent node drag from starting
                        const node = nodes[nodeEl.id];
                        const optionDiv = btn.closest('.button-option');
                        const indexToRemove = parseInt(optionDiv.dataset.index, 10);
                        // Remove a op√ß√£o do array de conte√∫do
                        node.content.splice(indexToRemove + 1, 1); // +1 porque content[0] √© a pergunta
                        optionDiv.remove(); // Remove o elemento HTML

                        // Atualiza os data-index dos bot√µes restantes
                        nodeEl.querySelectorAll('.button-option').forEach((div, i) => div.dataset.index = i);
                        updateMultipleChoiceConnectors(nodeEl, node.content.length - 1);
                        setupNodeEventListeners(nodeEl); // Re-setup listeners
                        saveState();
                    };
                });
                // Adiciona listeners para inputs e textareas para salvar o conte√∫do do n√≥
                nodeEl.querySelectorAll('textarea, input').forEach((input) => {
                    input.addEventListener('input', () => {
                        // Coleta todo o conte√∫do do n√≥. A ordem importa.
                        const newContent = [];
                        // Primeiro textarea √© geralmente a mensagem/pergunta principal
                        const mainTextarea = nodeEl.querySelector('textarea');
                        if (mainTextarea) newContent.push(mainTextarea.value);

                        if (nodeEl.dataset.type === 'multipleChoice') {
                            // Para m√∫ltiplas escolhas, coleta os valores dos inputs das op√ß√µes
                            nodeEl.querySelectorAll('#buttons-container input').forEach(optInput => {
                                newContent.push(optInput.value);
                            });
                        } else if (nodeEl.dataset.type === 'userInput' || nodeEl.dataset.type === 'cta') {
                            // Para userInput e cta, coleta o segundo input/textarea
                            const inputs = nodeEl.querySelectorAll('textarea, input[type="text"]');
                            if (inputs.length > 0) newContent.push(inputs[0].value);
                            if (inputs.length > 1) newContent.push(inputs[1].value);
                        } else if (nodeEl.dataset.type === 'delay') {
                            const delayInput = nodeEl.querySelector('input[type="number"]');
                            if (delayInput) newContent[0] = delayInput.value;
                        }
                        nodes[nodeEl.id].content = newContent;
                        saveState();
                    });
                    // Stop propagation for click events on inputs/textareas to prevent node drag
                    input.addEventListener('mousedown', (e) => e.stopPropagation());
                });

                // Adiciona listener para o bot√£o de deletar n√≥
                const deleteBtn = nodeEl.querySelector('.delete-node-btn');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevents node selection/drag from starting
                        showConfirmModal(
                            'Excluir Bloco?',
                            `Tem certeza que deseja excluir o bloco "${nodes[nodeEl.id].el.querySelector('.node-header').textContent.trim().replace('üóëÔ∏è', '').trim()}"?`,
                            () => deleteNode(nodeEl.id)
                        );
                    });
                }


                // Adiciona listeners para os conectores
                nodeEl.querySelectorAll('.connector').forEach(c => {
                    c.addEventListener('mousedown', (e) => {
                        e.stopPropagation(); // Previne o drag do n√≥ ou o pan do canvas
                        handleConnectorClick(nodeEl.id, c, e); // Passa o evento para a fun√ß√£o
                    });
                    // Adiciona listener para 'mouseover' para destacar o conector de entrada
                    c.addEventListener('mouseover', () => {
                        if (isConnecting && c.classList.contains('input') && connectionStart.nodeId !== nodeEl.id) {
                            c.classList.add('highlight-target');
                            hoveredInputConnector = c;
                        }
                    });
                    // Remove destaque ao sair do conector
                    c.addEventListener('mouseout', () => {
                        if (hoveredInputConnector) {
                            hoveredInputConnector.classList.remove('highlight-target');
                            hoveredInputConnector = null;
                        }
                    });
                });
            }
            
            /**
             * Torna um n√≥ arrast√°vel.
             * @param {HTMLElement} nodeEl - O elemento do n√≥ a ser arrastado.
             */
            function makeNodeDraggable(nodeEl) {
                let dragOffsetX, dragOffsetY;
                let isDraggingNode = false;

                const onMouseMove = (e) => {
                    if (!isDraggingNode) return;
                    e.preventDefault(); 
                    // Calcula a nova posi√ß√£o do n√≥ ajustando para o pan e zoom do canvas
                    const newX = (e.clientX - flowCanvas.getBoundingClientRect().left) / pan.scale - dragOffsetX;
                    const newY = (e.clientY - flowCanvas.getBoundingClientRect().top) / pan.scale - dragOffsetY;
                    nodeEl.style.left = `${newX}px`;
                    nodeEl.style.top = `${newY}px`;
                    nodes[nodeEl.id].x = newX;
                    nodes[nodeEl.id].y = newY;
                    updateConnectionsForNode(nodeEl.id); // Atualiza as linhas conectadas a este n√≥
                };

                const onMouseUp = () => {
                    isDraggingNode = false;
                    nodeEl.classList.remove('dragging'); // Remove a classe dragging
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    saveState(); // Salva o estado ap√≥s o arraste
                };

                nodeEl.addEventListener('mousedown', (e) => {
                    // Verifica se o clique foi em um input, textarea ou conector ou bot√£o de deletar.
                    // Se sim, permite a intera√ß√£o nativa e n√£o inicia o arraste do n√≥.
                    if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.classList.contains('connector') || e.target.classList.contains('delete-node-btn')) {
                        e.stopPropagation(); // Impede que o evento propague para o n√≥ e para o canvas (para n√£o iniciar pan)
                        return; // Sai da fun√ß√£o, n√£o inicia o arraste do n√≥
                    }
                    
                    e.preventDefault(); // Agora, este preventDefault s√≥ √© chamado se for um arraste do n√≥ (n√£o input/connector/delete button)
                                        // Isso previne o "ghosting" nativo do navegador.

                    selectNode(nodeEl.id); // Seleciona o n√≥ clicado
                    isDraggingNode = true;
                    nodeEl.classList.add('dragging'); // Adiciona a classe dragging para z-index elevado

                    // Calcula o offset do clique dentro do n√≥ para um arraste suave
                    // Os offsets s√£o calculados no sistema de coordenadas do flowCanvas.
                    dragOffsetX = (e.clientX - flowCanvas.getBoundingClientRect().left) / pan.scale - nodes[nodeEl.id].x;
                    dragOffsetY = (e.clientY - flowCanvas.getBoundingClientRect().top) / pan.scale - nodes[nodeEl.id].y;
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
            }
            
            /**
             * Obt√©m a posi√ß√£o absoluta de um conector no canvas (relativa ao flowCanvas).
             * @param {HTMLElement} connectorEl - O elemento do conector.
             * @returns {{x: number, y: number}} As coordenadas X e Y.
             */
            function getConnectorPosition(connectorEl) {
                const nodeEl = connectorEl.closest('.flow-node');
                // As coordenadas j√° s√£o relativas ao flowCanvas, pois svgLayer tamb√©m √© filho.
                return {
                    x: nodeEl.offsetLeft + connectorEl.offsetLeft + connectorEl.offsetWidth / 2,
                    y: nodeEl.offsetTop + connectorEl.offsetTop + connectorEl.offsetHeight / 2
                };
            }
            
            /**
             * Seleciona um n√≥ pelo seu ID, adicionando a classe 'selected'.
             * Deseleciona o n√≥ anteriormente selecionado.
             * @param {string|null} nodeId - O ID do n√≥ a ser selecionado, ou null para deselecionar tudo.
             */
            function selectNode(nodeId) {
                if (selectedNodeId && nodes[selectedNodeId] && nodes[selectedNodeId].el) {
                    nodes[selectedNodeId].el.classList.remove('selected');
                }
                selectedNodeId = nodeId;
                if (selectedNodeId && nodes[selectedNodeId] && nodes[selectedNodeId].el) {
                    nodes[selectedNodeId].el.classList.add('selected');
                }
            }

            /**
             * Exclui um n√≥ e suas conex√µes.
             * @param {string} nodeId - O ID do n√≥ a ser exclu√≠do.
             */
            function deleteNode(nodeId) {
                // Remove as conex√µes que envolvem o n√≥ a ser exclu√≠do
                connections = connections.filter(conn => conn.from !== nodeId && conn.to !== nodeId);
                // Remove o elemento HTML do n√≥
                if (nodes[nodeId] && nodes[nodeId].el) {
                    nodes[nodeId].el.remove();
                }
                // Remove o n√≥ do objeto 'nodes'
                delete nodes[nodeId];
                selectedNodeId = null; // Desseleciona o n√≥
                redrawAllConnections(); // Redesenha todas as linhas para refletir a remo√ß√£o
                saveState(); // Salva o estado atual
            }

            // Adiciona listener para a tecla 'Delete' ou 'Backspace' para excluir o n√≥ selecionado
            document.addEventListener('keydown', (e) => {
                if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNodeId) {
                    // Prevent default behavior if on an input/textarea inside the node
                    if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT') {
                        return;
                    }
                    showConfirmModal(
                        'Excluir Bloco?',
                        `Tem certeza que deseja excluir o bloco "${nodes[selectedNodeId].el.querySelector('.node-header').textContent.trim().replace('üóëÔ∏è', '').trim()}"?`,
                        () => deleteNode(selectedNodeId)
                    );
                }
            });

            /**
             * Lida com o clique em um conector para iniciar ou finalizar uma conex√£o.
             * @param {string} nodeId - O ID do n√≥ ao qual o conector pertence.
             * @param {HTMLElement} connector - O elemento do conector clicado.
             * @param {MouseEvent} e - O evento do mouse.
             */
            function handleConnectorClick(nodeId, connector, e) {
                e.preventDefault(); 
                e.stopPropagation(); 

                if (isConnecting) {
                    // Se j√° estiver conectando, tenta finalizar a conex√£o
                    // Apenas conecta se o alvo for um conector de entrada v√°lido e de um n√≥ diferente
                    if (connector.classList.contains('input') && connectionStart.nodeId !== nodeId) {
                        // Remove qualquer conex√£o existente que saia da mesma origem/escolha e aponte para qualquer lugar
                        connections = connections.filter(c => !(c.from === connectionStart.nodeId && c.choice === connectionStart.choice));

                        // Remove qualquer conex√£o existente que aponte para o mesmo destino de entrada
                        connections = connections.filter(c => !(c.to === nodeId));

                        createConnection(connectionStart.nodeId, nodeId, connectionStart.choice);
                    }
                    resetConnectionState(); // Sempre reseta o estado da conex√£o ap√≥s uma tentativa (bem-sucedida ou n√£o)
                } else {
                    // Inicia uma nova conex√£o (apenas de conectores de sa√≠da)
                    if (connector.classList.contains('output')) {
                        isConnecting = true;
                        connectionStart = {
                            nodeId: nodeId,
                            choice: connector.dataset.choice !== undefined ? connector.dataset.choice : null
                        };
                        currentTempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path'); // Use path for bezier
                        currentTempLine.setAttribute('stroke', '#e94560'); // Neon red
                        currentTempLine.setAttribute('stroke-width', '2'); // Thin line
                        currentTempLine.setAttribute('fill', 'none'); // No fill for lines
                        svgLayer.appendChild(currentTempLine);
                        const startPos = getConnectorPosition(connector);
                        currentTempLine.setAttribute('d', `M ${startPos.x} ${startPos.y} L ${startPos.x} ${startPos.y}`); // Initial straight line
                        
                        // Adiciona listeners globais para arrastar a linha tempor√°ria
                        document.addEventListener('mousemove', onDrawingConnection);
                        document.addEventListener('mouseup', resetConnectionState); // Listener global para soltar em qualquer lugar
                    }
                }
            }

            /**
             * Calcula o caminho SVG para uma curva de B√©zier entre dois pontos.
             * @param {number} x1 - X inicial.
             * @param {number} y1 - Y inicial.
             * @param {number} x2 - X final.
             * @param {number} y2 - Y final.
             * @returns {string} O atributo 'd' para o caminho SVG.
             */
            function getBezierPath(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1) * 0.5; // Ajuste para controlar a "curvatura"
                let cp1x = x1 + dx;
                let cp1y = y1;
                let cp2x = x2 - dx;
                let cp2y = y2;

                // Adjust control points for smoother curves when moving backwards (x1 > x2)
                if (x1 > x2) {
                    cp1x = x1 + 50; // Force bend outwards
                    cp2x = x2 - 50; // Force bend outwards
                }

                return `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
            }

            /**
             * Atualiza a posi√ß√£o da linha tempor√°ria durante o arraste de conex√£o e destaca o alvo.
             * @param {MouseEvent} e - O evento do mouse.
             */
            function onDrawingConnection(e) {
                if (!currentTempLine) return; // Garante que a linha tempor√°ria existe
                const coords = toCanvasCoords(e); // Converte para coordenadas do canvas (n√£o transformado)
                const startX = parseFloat(currentTempLine.getAttribute('d').split(' ')[1]);
                const startY = parseFloat(currentTempLine.getAttribute('d').split(' ')[2]);
                currentTempLine.setAttribute('d', getBezierPath(startX, startY, coords.x, coords.y));

                // L√≥gica de destaque do conector de entrada alvo
                if (hoveredInputConnector) {
                    hoveredInputConnector.classList.remove('highlight-target');
                    hoveredInputConnector = null;
                }

                // Verifica se o mouse est√° sobre um conector de entrada v√°lido (n√£o o conector de sa√≠da original)
                const targetElement = document.elementFromPoint(e.clientX, e.clientY);
                if (targetElement && targetElement.classList.contains('connector') && targetElement.classList.contains('input')) {
                    const targetNodeId = targetElement.closest('.flow-node').id;
                    // Certifica-se de que n√£o estamos sobre o n√≥ de origem da conex√£o
                    if (targetNodeId !== connectionStart.nodeId) {  
                        hoveredInputConnector = targetElement;
                        hoveredInputConnector.classList.add('highlight-target');
                    }
                }
            }

            /**
             * Reseta o estado da conex√£o (remove linha tempor√°ria, flags).
             */
            function resetConnectionState() {
                isConnecting = false;
                connectionStart = {};
                if (currentTempLine) {
                    currentTempLine.remove();
                    currentTempLine = null;
                }
                if (hoveredInputConnector) {
                    hoveredInputConnector.classList.remove('highlight-target');
                    hoveredInputConnector = null;
                }
                document.removeEventListener('mousemove', onDrawingConnection);
                document.removeEventListener('mouseup', resetConnectionState);
            }

            /**
             * Cria uma conex√£o entre dois n√≥s.
             * Remove qualquer conex√£o existente da mesma sa√≠da.
             * @param {string} fromId - ID do n√≥ de origem.
             * @param {string} toId - ID do n√≥ de destino.
             * @param {string|null} choice - Escolha da sa√≠da (para n√≥s de pergunta/m√∫ltipla escolha).
             */
            function createConnection(fromId, toId, choice = null) {
                const newConnection = { from: fromId, to: toId, choice, lineEl: null }; // lineEl ser√° definido em redraw
                connections.push(newConnection);
                redrawAllConnections(); // Redesenha todas as linhas para incluir a nova
                saveState(); // Salva o estado
            }

            /**
             * Atualiza a posi√ß√£o de uma √∫nica linha de conex√£o SVG.
             * @param {object} conn - O objeto de conex√£o contendo IDs de origem/destino e o elemento da linha.
             */
            function updateConnectionLine(conn) {
                const fromNode = nodes[conn.from];
                const toNode = nodes[conn.to];
                if (!fromNode || !toNode || !conn.lineEl) {
                    // Se os n√≥s ou a linha n√£o existirem mais, remove a linha para evitar √≥rf√£os
                    if (conn.lineEl) conn.lineEl.remove();
                    return;
                }

                let fromConnector;
                if (conn.choice !== null) {
                    // Para conectores de escolha (Sim/N√£o, M√∫ltipla Escolha)
                    fromConnector = fromNode.el.querySelector(`.connector.output[data-choice="${conn.choice}"]`);
                } else {
                    // Para conectores de sa√≠da padr√£o
                    fromConnector = fromNode.el.querySelector('.connector.output:not([data-choice])');
                }
                const toConnector = toNode.el.querySelector('.connector.input');

                if (!fromConnector || !toConnector) {
                    // Se os conectores n√£o forem encontrados (n√≥ alterado, etc.), remove a linha
                    if (conn.lineEl) conn.lineEl.remove();
                    return;
                }

                const startPos = getConnectorPosition(fromConnector);
                const endPos = getConnectorPosition(toConnector);

                conn.lineEl.setAttribute('d', getBezierPath(startPos.x, startPos.y, endPos.x, endPos.y));
            }

            /**
             * Atualiza as linhas de conex√£o para um n√≥ espec√≠fico (quando ele √© movido).
             * @param {string} nodeId - O ID do n√≥ que foi movido.
             */
            function updateConnectionsForNode(nodeId) {
                connections.forEach(conn => {
                    if (conn.from === nodeId || conn.to === nodeId) {
                        updateConnectionLine(conn);
                    }
                });
            }

            /**
             * Limpa e redesenha todas as linhas de conex√£o SVG.
             */
            function redrawAllConnections() {
                // Filter out any connections that refer to non-existent nodes first.
                // This ensures we only attempt to draw valid connections and clean up old ones.
                connections = connections.filter(conn => nodes[conn.from] && nodes[conn.to]);

                // Limpa apenas as linhas, mantendo o <defs> se houver.
                // No nosso caso, removemos o <defs> de marcador de seta, ent√£o apenas removemos paths.
                Array.from(svgLayer.children).forEach(child => {
                    if (child.tagName === 'path') { // Linhas s√£o paths agora
                        child.remove();
                    }
                });

                connections.forEach(conn => {
                    // At this point, we are sure nodes[conn.from] and nodes[conn.to] exist due to the filter above.
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path'); // Create a path element
                    line.setAttribute('stroke', '#e94560'); // Neon red
                    line.setAttribute('stroke-width', '2'); // Thin line
                    line.setAttribute('fill', 'none'); // No fill for lines
                    conn.lineEl = line; // Armazena a refer√™ncia ao elemento da linha
                    svgLayer.appendChild(line);
                    updateConnectionLine(conn); // Atualiza a posi√ß√£o da nova linha
                });
            }
            
            // --- L√ìGICA DE IMPORTAR / EXPORTAR / LIMPAR ---
            exportFlowBtn.addEventListener('click', () => {
                const dataToExport = {
                    nodes: Object.values(nodes).map(n => ({
                        id: n.id,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                        content: n.content // Exporta o conte√∫do
                    })),
                    connections: connections.map(c => ({
                        from: c.from,
                        to: c.to,
                        choice: c.choice // Exporta a escolha
                    })),
                    nodeIdCounter,
                    pan
                };
                const dataStr = JSON.stringify(dataToExport, null, 2);
                const blob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'zapflow_flow.json';
                a.click();
                URL.revokeObjectURL(url); // Libera o URL do objeto
                showAlertModal('Sucesso!', 'Fluxo exportado com sucesso como "zapflow_flow.json".');
            });

            importFlowBtn.addEventListener('click', () => importFileInput.click());
            importFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        showConfirmModal(
                            'Importar Fluxo?',
                            'Isto ir√° substituir o fluxo atual. Tem a certeza?',
                            () => loadState(data),
                            () => showAlertModal('Importa√ß√£o Cancelada', 'A importa√ß√£o do fluxo foi cancelada.')
                        );
                    } catch (err) {
                        showAlertModal('Erro', 'Erro ao ler o ficheiro JSON. Verifique se √© um arquivo de fluxo v√°lido.');
                        console.error("Erro ao importar fluxo:", err);
                    }
                };
                reader.readAsText(file);
                e.target.value = ''; // Limpa o input de arquivo
            });

            /**
             * Reseta o canvas, removendo todos os n√≥s e conex√µes.
             */
            function resetCanvas() {
                nodes = {};
                connections = [];
                selectedNodeId = null;
                // Limpa todos os elementos dentro de flowCanvas, exceto o svg-layer
                Array.from(flowCanvas.children).forEach(child => {
                    if (child.id !== 'svg-layer') {
                        child.remove();
                    }
                });
                // Limpa o SVG (todas as linhas)
                svgLayer.innerHTML = '';
            }

            /**
             * Salva o estado atual do fluxo no localStorage.
             */
            function saveState() {
                const state = {
                    nodes: Object.values(nodes).map(n => ({
                        id: n.id,
                        type: n.type,
                        x: n.x,
                        y: n.y,
                        content: n.content
                    })),
                    connections: connections.map(c => ({
                        from: c.from,
                        to: c.to,
                        choice: c.choice
                    })),
                    nodeIdCounter,
                    pan
                };
                localStorage.setItem('zapflowBuilderState', JSON.stringify(state));
            }

            /**
             * Carrega o estado do fluxo do localStorage ou de dados fornecidos.
             * @param {object|null} data - Dados opcionais para carregar (para importa√ß√£o).
             */
            function loadState(data = null) {
                const state = data || JSON.parse(localStorage.getItem('zapflowBuilderState'));
                if (!state) return;

                resetCanvas(); // Limpa o canvas antes de carregar
                nodeIdCounter = state.nodeIdCounter || 0;
                pan = state.pan || {x:0, y:0, scale:1};
                updateCanvasTransform();

                if (state.nodes) {
                    // Primeiro cria todos os n√≥s
                    state.nodes.forEach(n => createNode(n.type, n.x, n.y, n.id, n.content));
                }
                // Em seguida, restaura as conex√µes
                connections = state.connections || [];
                redrawAllConnections(); // Redesenha todas as linhas
            }

            clearFlowBtn.addEventListener('click', () => {
                showConfirmModal('Limpar Fluxo?', 'Tem certeza que deseja limpar todo o fluxo? Esta a√ß√£o n√£o pode ser desfeita.',
                    () => {
                        resetCanvas();
                        nodeIdCounter = 0;
                        createNode('start', 50, 150, 'node-0'); // Cria um n√≥ inicial padr√£o
                        saveState();
                        showAlertModal('Fluxo Limpo', 'O canvas foi limpo e um novo n√≥ de In√≠cio foi adicionado.');
                    },
                    () => showAlertModal('A√ß√£o Cancelada', 'A limpeza do fluxo foi cancelada.')
                );
            });
            
            // --- L√ìGICA DE SIMULA√á√ÉO DE FLUXO ---
            let flowVariables = {}; // Armazena vari√°veis de utilizador durante a simula√ß√£o

            /**
             * Adiciona uma mensagem ao corpo do chat de pr√©-visualiza√ß√£o.
             * @param {string} text - O texto da mensagem.
             * @param {string} type - 'received' para mensagens do bot, 'sent' para mensagens do utilizador.
             * @param {string} [imageUrl] - URL da imagem se for uma mensagem de imagem.
             */
            function addMessage(text, type, imageUrl = null) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                if (imageUrl) {
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    // Adiciona um fallback para imagem quebrada
                    img.onerror = function() {
                        this.onerror=null; // Evita loop infinito
                        this.src='https://placehold.co/150x100/CCCCCC/000000?text=Imagem+N%C3%A3o+Encontrada';
                    };
                    messageDiv.appendChild(img);
                }
                messageDiv.innerHTML += `<span>${text.replace(/\n/g, '<br>')}</span>`; // Adiciona texto e quebras de linha
                previewChatBody.appendChild(messageDiv);
                scrollToBottom();
            }

            /**
             * Adiciona um indicador de digita√ß√£o ao chat de pr√©-visualiza√ß√£o.
             * @returns {HTMLElement} O elemento do indicador.
             */
            function addTypingIndicator() {
                const indicator = document.createElement('div');
                indicator.className = 'typing-indicator';
                indicator.innerHTML = '<span></span><span></span><span></span>';
                previewChatBody.appendChild(indicator);
                scrollToBottom();
                return indicator;
            }

            /**
             * Remove um indicador de digita√ß√£o do chat.
             * @param {HTMLElement} indicatorEl - O elemento do indicador a ser removido.
             */
            function removeTypingIndicator(indicatorEl) {
                if (indicatorEl) {
                    indicatorEl.remove();
                }
            }

            /**
             * Rolagem autom√°tica do chat para o final.
             */
            function scrollToBottom() {
                previewChatBody.scrollTop = previewChatBody.scrollHeight;
            }

            /**
             * Espera por uma escolha do utilizador atrav√©s de bot√µes.
             * @param {Array<string>} choices - Array de textos das op√ß√µes.
             * @returns {Promise<number>} Uma promessa que resolve com o √≠ndice da escolha selecionada.
             */
            function waitForUserChoice(choices) {
                return new Promise(resolve => {
                    const choiceContainer = document.createElement('div');
                    choiceContainer.className = 'choice-container';
                    choices.forEach((choiceText, index) => {
                        const button = document.createElement('button');
                        button.className = 'choice-button';
                        // Replace flowVariables in choiceText
                        let processedChoiceText = choiceText;
                        for (const key in flowVariables) {
                            processedChoiceText = processedChoiceText.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), flowVariables[key]);
                        }
                        button.textContent = processedChoiceText;
                        button.onclick = () => {
                            choiceContainer.remove(); // Remove os bot√µes ap√≥s a escolha
                            resolve(index); // Resolve com o √≠ndice da escolha
                        };
                        choiceContainer.appendChild(button);
                    });
                    previewChatBody.appendChild(choiceContainer);
                    scrollToBottom();
                });
            }

            /**
             * Espera pela entrada de texto do utilizador.
             * @param {string} promptText - O texto da pergunta para o utilizador.
             * @returns {Promise<string>} Uma promessa que resolve com o texto digitado pelo utilizador.
             */
            function waitForUserInput(promptText) {
                return new Promise(resolve => {
                    // Replace flowVariables in promptText
                    let processedPromptText = promptText;
                    for (const key in flowVariables) {
                        processedPromptText = processedPromptText.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), flowVariables[key]);
                    }
                    addMessage(processedPromptText, "received"); // Mostra a pergunta do bot

                    const inputContainer = document.createElement('div');
                    inputContainer.className = 'user-input-container';
                    const inputField = document.createElement('input');
                    inputField.type = 'text';
                    inputField.placeholder = 'Digite sua resposta...';
                    const sendButton = document.createElement('button');
                    sendButton.textContent = 'Enviar';

                    sendButton.onclick = () => {
                        const userText = inputField.value.trim();
                        if (userText) {
                            inputContainer.remove(); // Remove o campo de entrada e o bot√£o
                            resolve(userText);
                        }
                    };
                    // Permite enviar com Enter
                    inputField.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            sendButton.click();
                        }
                    });

                    inputContainer.appendChild(inputField);
                    inputContainer.appendChild(sendButton);
                    previewChatBody.appendChild(inputContainer);
                    scrollToBottom();
                    inputField.focus(); // Foca no campo de input
                });
            }


            /**
             * Simula a execu√ß√£o do fluxo de chat na pr√©-visualiza√ß√£o.
             * @param {string} currentNodeId - O ID do n√≥ atual a ser processado.
             */
            async function simulateFlow(currentNodeId) {
                const currentNode = nodes[currentNodeId];
                if (!currentNode) {
                    addMessage("Fluxo terminado ou n√≥ inv√°lido alcan√ßado.", "received");
                    return;
                }

                try {
                    // Replace variables in node content before processing
                    let processedContent = currentNode.content.map(c => {
                        let text = c;
                        for (const key in flowVariables) {
                            text = text.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), flowVariables[key]);
                        }
                        return text;
                    });

                    switch (currentNode.type) {
                        case 'start':
                            // Encontra a pr√≥xima conex√£o do n√≥ de in√≠cio
                            const startConnection = connections.find(c => c.from === currentNode.id);
                            if (startConnection) {
                                await simulateFlow(startConnection.to); // Continua para o pr√≥ximo n√≥
                            } else {
                                addMessage("N√≥ 'In√≠cio' n√£o conectado a nenhum outro n√≥. Fluxo terminou.", "received");
                            }
                            break;

                        case 'message':
                            addMessage(processedContent[0], "received");
                            await new Promise(r => setTimeout(r, 500)); // Pequeno atraso para "leitura"
                            // Encontra a pr√≥xima conex√£o e continua
                            const msgConnection = connections.find(c => c.from === currentNode.id);
                            if (msgConnection) await simulateFlow(msgConnection.to);
                            else addMessage("N√≥ 'Mensagem' n√£o conectado. Fluxo terminou.", "received");
                            break;

                        case 'image':
                            addMessage("Enviando imagem...", "received", processedContent[0]);
                            await new Promise(r => setTimeout(r, 1000)); // Pequeno atraso para "carregar"
                            const imgConnection = connections.find(c => c.from === currentNode.id);
                            if (imgConnection) await simulateFlow(imgConnection.to);
                            else addMessage("N√≥ 'Imagem' n√£o conectado. Fluxo terminou.", "received");
                            break;

                        case 'question':
                            const questionText = processedContent[0];
                            const choiceSelected = await waitForUserChoice(['Sim', 'N√£o']);
                            addMessage(choiceSelected === 0 ? 'Sim' : 'N√£o', 'sent'); // Resposta do utilizador

                            // Encontra a pr√≥xima conex√£o baseada na escolha
                            const questionChoice = (choiceSelected === 0) ? 'yes' : 'no';
                            const questionConnection = connections.find(c => c.from === currentNode.id && c.choice === questionChoice);
                            if (questionConnection) await simulateFlow(questionConnection.to);
                            else showAlertModal('Aviso', `Nenhuma conex√£o definida para a op√ß√£o "${questionChoice === 'yes' ? 'Sim' : 'N√£o'}". Fluxo terminou.`);
                            break;

                        case 'multipleChoice':
                            const mcQuestionText = processedContent[0];
                            const mcOptions = processedContent.slice(1);
                            
                            addMessage(mcQuestionText, "received");
                            const mcChoiceIndex = await waitForUserChoice(mcOptions);
                            addMessage(mcOptions[mcChoiceIndex], 'sent'); // Resposta do utilizador

                            // Encontra a pr√≥xima conex√£o baseada no √≠ndice da escolha
                            const mcConnection = connections.find(c => c.from === currentNode.id && parseInt(c.choice) === mcChoiceIndex);
                            if (mcConnection) await simulateFlow(mcConnection.to);
                            else showAlertModal('Aviso', `Nenhuma conex√£o definida para a op√ß√£o "${mcOptions[mcChoiceIndex]}". Fluxo terminou.`);
                            break;

                        case 'userInput':
                            const inputPrompt = processedContent[0];
                            const variableName = processedContent[1] || 'user_input'; // Default variable name
                            const userInput = await waitForUserInput(inputPrompt);
                            addMessage(userInput, 'sent'); // Mostra a entrada do utilizador
                            flowVariables[variableName] = userInput; // Armazena a entrada
                            
                            const userInputConnection = connections.find(c => c.from === currentNode.id);
                            if (userInputConnection) await simulateFlow(userInputConnection.to);
                            else addMessage("N√≥ 'Entrada do Utilizador' n√£o conectado. Fluxo terminou.", "received");
                            break;

                        case 'delay':
                            const delayMs = parseInt(processedContent[0] || '1500', 10);
                            const indicator = addTypingIndicator();
                            await new Promise(r => setTimeout(r, delayMs));
                            removeTypingIndicator(indicator);
                            
                            const delayConnection = connections.find(c => c.from === currentNode.id);
                            if (delayConnection) await simulateFlow(delayConnection.to);
                            else addMessage("N√≥ 'Atraso' n√£o conectado. Fluxo terminou.", "received");
                            break;

                        case 'cta':
                            const ctaText = processedContent[0] || 'Visitar Link';
                            const ctaUrl = processedContent[1] || '#';
                            const ctaContainer = document.createElement('div');
                            ctaContainer.className = 'cta-button-container';
                            const ctaButton = document.createElement('a');
                            ctaButton.className = 'cta-button';
                            ctaButton.href = ctaUrl;
                            ctaButton.textContent = ctaText;
                            ctaButton.target = '_blank'; // Abre em nova aba
                            ctaContainer.appendChild(ctaButton);
                            previewChatBody.appendChild(ctaContainer);
                            scrollToBottom();
                            addMessage("Fluxo conclu√≠do! Clique no bot√£o final.", "received");
                            break;

                        default:
                            addMessage(`Tipo de n√≥ desconhecido: ${currentNode.type}. Fluxo terminado.`, "received");
                            break;
                    }
                } catch (error) {
                    console.error("Erro durante a simula√ß√£o do fluxo:", error);
                    showAlertModal('Erro de Simula√ß√£o', 'Ocorreu um erro durante a simula√ß√£o do fluxo. Verifique suas conex√µes e conte√∫dos.');
                }
            }

            // Inicia a simula√ß√£o do fluxo
            runFlowBtn.addEventListener('click', async () => {
                previewChatBody.innerHTML = ''; // Limpa o chat de pr√©-visualiza√ß√£o
                flowVariables = {}; // Reseta as vari√°veis do fluxo
                
                // Encontra o n√≥ de in√≠cio
                const startNode = Object.values(nodes).find(node => node.type === 'start');
                if (!startNode) {
                    showAlertModal('Erro', 'Nenhum n√≥ de "In√≠cio" encontrado no fluxo. Por favor, adicione um.');
                    return;
                }
                
                addMessage("Simula√ß√£o do fluxo iniciada.", "received");
                await new Promise(r => setTimeout(r, 1000)); // Pequeno atraso antes de come√ßar o fluxo real
                simulateFlow(startNode.id); // Inicia a simula√ß√£o a partir do n√≥ de in√≠cio
            });

            // --- INICIALIZA√á√ÉO ---
            function init() {
                loadState(); // Tenta carregar o estado salvo
                if (Object.keys(nodes).length === 0) {
                    // Se n√£o houver n√≥s, cria um n√≥ de in√≠cio padr√£o
                    createNode('start', 50, 150, 'node-0');
                    saveState();
                }
            }
            init(); // Chama a fun√ß√£o de inicializa√ß√£o
        }
    });
    </script>
</body>
</html>
