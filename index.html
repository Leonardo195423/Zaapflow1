<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZAPFLOW - Chat Interativo</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        :root {
            --bg-color: #1a1a2e;
            --panel-color: #16213e;
            --canvas-color: #0f1524;
            --primary-accent: #e94560;
            --secondary-accent: #4fc3f7;
            --success-color: #25D366;
            --warning-color: #f7b731;
            --text-light: #e0e0e0;
            --border-color: #2c3e50;
            --shadow-color: rgba(0, 0, 0, 0.4);
            --connector-color: #6c757d; /* Default connector color */
            --button-hover-dark: #c33a50; /* Darker primary accent for hover */
            --button-hover-light: #6ad1fc; /* Lighter secondary accent for hover */
        }

        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap');

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-light);
            overflow: hidden;
            height: 100vh; /* Garante que o corpo ocupe toda a altura da viewport */
            display: flex;
        }

        .hidden { display: none !important; }

        /* --- TELA DE LOGIN --- */
        #login-screen {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            background-image: url('https://i.ibb.co/B5CH90Vp/Chat-GPT-Image-29-de-jun-de-2025-23-12-16.png');
            background-size: cover; background-position: center;
            z-index: 1000;
        }
        #login-box {
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            padding: 40px; border-radius: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            width: 100%; max-width: 400px; text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #login-box h2 { font-size: 2.5rem; margin-bottom: 10px; color: #fff; }
        #login-box p { color: #ccc; margin-bottom: 30px; }
        .input-group { margin-bottom: 20px; text-align: left; }
        .input-group label { display: block; margin-bottom: 8px; color: #ccc; }
        .input-group input { width: 100%; padding: 12px; background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.2); border-radius: 8px; color: #fff; font-size: 1rem; }
        .input-group input:focus { outline: none; border-color: var(--primary-accent); }
        #login-button { width: 100%; padding: 15px; background: var(--primary-accent); border: none; border-radius: 8px; color: #fff; font-size: 1.2rem; font-weight: bold; cursor: pointer; transition: background-color 0.3s; }
        #login-button:hover { background-color: var(--button-hover-dark); }
        #login-error { color: #ff5555; margin-top: 15px; height: 20px; }

        /* --- LAYOUT PRINCIPAL DA APLICAÇÃO --- */
        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr 420px;
            width: 100%;
            height: 100%;
            gap: 10px;
            padding: 10px;
        }

        .panel {
            background-color: var(--panel-color);
            border-radius: 12px;
            padding: 15px;
            display: flex;
            flex-direction: column;
            box-shadow: 5px 0 15px var(--shadow-color);
            z-index: 10;
        }
        .panel-header {
            font-size: 1.4em;
            font-weight: 700;
            padding-bottom: 15px;
            margin-bottom: 15px;
            border-bottom: 1px solid var(--border-color);
            color: var(--primary-accent);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0; /* Impede que o cabeçalho encolha */
        }
        .panel-header i { margin-right: 10px; }
        #logout-button { background: none; border: none; color: var(--primary-accent); cursor: pointer; font-size: 1.2rem; }
        #logout-button:hover { color: var(--button-hover-dark); }
        
        /* --- PAINEL LATERAL DE BLOCOS --- */
        #side-panel {
            overflow-y: auto; /* Permite rolagem vertical */
        }
        #side-panel .node-template {
            background-color: var(--canvas-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 12px;
            cursor: grab;
            transition: background-color 0.3s, transform 0.2s;
            font-weight: 500;
            font-size: 0.95em;
        }
        #side-panel .node-template:hover {
            background-color: #2c3e50;
            transform: translateY(-2px);
        }
        #side-panel .node-template i {
            margin-right: 10px;
            color: var(--secondary-accent);
            width: 20px;
            text-align: center;
        }
        #side-panel .controls {
            margin-top: auto; /* Empurra os controles para o final do painel */
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            flex-shrink: 0; /* Impede que os controles encolham */
        }
        .control-btn {
            padding: 12px 10px;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s, transform 0.2s;
            font-size: 0.9em;
        }
        .control-btn:hover { transform: translateY(-2px); }
        #run-flow-btn { background-color: var(--primary-accent); grid-column: 1 / -1; }
        #run-flow-btn:hover { background-color: var(--button-hover-dark); }
        #clear-flow-btn { background-color: #555; }
        #clear-flow-btn:hover { background-color: #777; }
        #download-html-btn { background-color: var(--success-color); }
        #download-html-btn:hover { background-color: #128C7E; }
        #import-flow-btn { background-color: var(--warning-color); }
        #import-flow-btn:hover { background-color: #f7a000; }
        #export-flow-btn { background-color: var(--secondary-accent); }
        #export-flow-btn:hover { background-color: var(--button-hover-light); }
        
        /* --- CANVAS CENTRAL --- */
        #canvas-container {
            position: relative;
            background-color: var(--canvas-color);
            background-image: radial-gradient(var(--border-color) 1px, transparent 1px);
            background-size: 20px 20px;
            border-radius: 12px;
            overflow: hidden;
            cursor: grab;
        }
        #canvas-container:active { cursor: grabbing; }

        #flow-canvas {
            width: 100%;
            height: 100%;
            position: relative;
            transform-origin: 0 0;
        }
        
        #svg-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Make SVG layer non-interactive */
        }

        /* --- BLOCOS NO CANVAS --- */
        .flow-node {
            position: absolute;
            background-color: var(--panel-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            width: 240px;
            min-height: 80px;
            box-shadow: 0 4px 12px var(--shadow-color);
            cursor: move;
            transition: box-shadow 0.3s, border-color 0.3s;
            display: flex;
            flex-direction: column;
            z-index: 5; /* Ensure nodes are above SVG lines by default */
        }
        .flow-node.selected {
            border-color: var(--primary-accent);
            box-shadow: 0 0 15px rgba(233, 69, 96, 0.5);
            z-index: 6; /* Bring selected node to front */
        }
        .flow-node.dragging {
            z-index: 999 !important; /* High z-index to ensure it's always on top */
        }

        .node-header {
            background-color: #2c3e50;
            color: var(--text-light);
            padding: 8px 10px;
            font-weight: bold;
            border-top-left-radius: 7px;
            border-top-right-radius: 7px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .node-header i { margin-right: 8px; }
        .delete-node-btn {
            background: none;
            border: none;
            color: #ccc;
            font-size: 1em;
            cursor: pointer;
            margin-left: 10px;
            transition: color 0.2s;
        }
        .delete-node-btn:hover {
            color: var(--primary-accent);
        }

        .node-content {
            padding: 10px;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }
        .node-content textarea, .node-content input {
            width: 100%;
            background-color: var(--canvas-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-light);
            padding: 8px;
            resize: vertical;
        }
        .node-content textarea { min-height: 40px; }
        .node-content textarea:focus, .node-content input:focus {
            outline: none;
            border-color: var(--secondary-accent);
        }
        .node-content label {
            font-size: 0.8em;
            color: var(--text-light-muted, #aaa);
            margin-bottom: -4px;
        }
        /* Specific node type styles */
        .flow-node[data-type="start"] { border-color: var(--success-color); }
        .flow-node[data-type="start"] .node-header { background-color: #128C7E; }
        .flow-node[data-type="end"] { border-color: #f7b731; }
        .flow-node[data-type="end"] .node-header { background-color: #e09f25; }
        .flow-node[data-type="question"], .flow-node[data-type="multipleChoice"] { border-color: var(--secondary-accent); }
        .flow-node[data-type="question"] .node-header, .flow-node[data-type="multipleChoice"] .node-header { background-color: #3b5998; }
        
        .connector {
            width: 16px; height: 16px;
            background-color: #fff;
            border: 2px solid var(--connector-color);
            border-radius: 50%;
            position: absolute;
            cursor: crosshair;
            transition: background-color 0.3s, border-color 0.3s;
            z-index: 10; /* Keep connectors on top of node content */
        }
        .connector:hover { 
            background-color: var(--primary-accent); 
            border-color: var(--primary-accent); /* Highlight border on hover */
        }
        .connector.highlight-target {
            background-color: var(--secondary-accent) !important;
            border-color: var(--primary-accent) !important;
            box-shadow: 0 0 8px rgba(233, 69, 96, 0.7);
        }
        .connector.output { right: -8px; }
        .connector.input { left: -8px; top: 50%; transform: translateY(-50%); }

        .button-option { display: flex; align-items: center; gap: 5px; }
        .button-option input { flex-grow: 1; }
        .remove-btn { cursor: pointer; color: #e94560; }
        .remove-btn:hover { color: var(--button-hover-dark); }
        .add-btn {
            background: none; border: 1px dashed var(--connector-color); color: var(--connector-color);
            padding: 5px; border-radius: 4px; cursor: pointer; margin-top: 5px;
        }
        .add-btn:hover { background-color: rgba(255,255,255,0.05); }

        /* --- PRÉ-VISUALIZAÇÃO (CELULAR) --- */
        #preview-panel { align-items: center; justify-content: center; }
        .mobile-preview {
            width: 100%; max-width: 380px; height: 95%; background-color: #111;
            border-radius: 40px; border: 10px solid #000; box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column; overflow: hidden;
        }
        .chat-header {
            background-color: #075E54; color: white; padding: 10px 15px; display: flex;
            align-items: center; gap: 15px; flex-shrink: 0;
        }
        .chat-header img { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; }
        .chat-header .name { font-weight: bold; }
        .chat-header .status { font-size: 0.8em; color: #d1d1d1; }
        .chat-body {
            flex-grow: 1; padding: 15px 10px; overflow-y: auto; display: flex; flex-direction: column;
            gap: 12px; background-color: #e5ddd5;
            background-image: url('https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png');
        }
        .message { max-width: 80%; padding: 8px 12px; border-radius: 8px; line-height: 1.4; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .message.received { background-color: #ffffff; align-self: flex-start; color: black; /* Alterado para preto */ }
        .message.sent { background-color: #dcf8c6; align-self: flex-end; color: black; /* Alterado para preto */ }
        .message img { max-width: 100%; border-radius: 8px; margin-top: 5px; }
        .typing-indicator { align-self: flex-start; padding: 10px 15px; display: flex; align-items: center; justify-content: center; background-color: #ffffff; border-radius: 8px; max-width: 80px; }
        .typing-indicator span { height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out; }
        .typing-indicator span:nth-child(2) { animation-delay: 0.1s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.2s; }
        @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
        .choice-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; padding: 5px 10px; align-self: flex-end; }
        .choice-button { background-color: #fff; border: 1px solid #075E54; color: #075E54; padding: 8px 15px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: background-color 0.2s, color 0.2s; }
        .choice-button:hover { background-color: #075E54; color: white; }
        .cta-button-container { padding: 10px; align-self: stretch; }
        .cta-button { background: linear-gradient(45deg, #25D366, #128C7E); color: white; text-align: center; text-decoration: none; font-size: 1.1em; font-weight: bold; padding: 15px; border-radius: 30px; display: block; transition: transform 0.2s; }
        .cta-button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
        .user-input-container { display: flex; gap: 5px; margin-top: 10px; align-self: stretch; }
        .user-input-container input { flex-grow: 1; padding: 8px; border-radius: 20px; border: 1px solid #ccc; }
        .user-input-container button { padding: 8px 15px; border-radius: 20px; border: none; background-color: #075E54; color: white; cursor: pointer; }


        /* --- CUSTOM MODAL --- */
        .custom-modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex; align-items: center; justify-content: center;
            z-index: 2000;
        }
        .custom-modal {
            background-color: var(--panel-color);
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 5px 20px var(--shadow-color);
            max-width: 450px;
            width: 90%;
            text-align: center;
            border: 1px solid var(--border-color);
        }
        .custom-modal h3 {
            color: var(--primary-accent);
            margin-bottom: 20px;
            font-size: 1.5em;
        }
        .custom-modal p {
            color: var(--text-light);
            margin-bottom: 30px;
            line-height: 1.5;
        }
        .custom-modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
        }
        .custom-modal-buttons button {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s, transform 0.2s;
        }
        .custom-modal-buttons .confirm-btn {
            background-color: var(--primary-accent);
            color: white;
        }
        .custom-modal-buttons .confirm-btn:hover {
            background-color: var(--button-hover-dark);
            transform: translateY(-2px);
        }
        .custom-modal-buttons .cancel-btn {
            background-color: #555;
            color: white;
        }
        .custom-modal-buttons .cancel-btn:hover {
            background-color: #777;
            transform: translateY(-2px);
        }

        /* New styles for Bot Settings */
        .bot-settings {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid var(--border-color);
            flex-shrink: 0; /* Impede que as configurações do bot encolham */
        }
        .bot-settings .input-group {
            margin-bottom: 15px;
        }
    </style>
</head>
<body>

    <!-- TELA DE LOGIN -->
    <div id="login-screen">
        <div id="login-box">
            <h2>Bem-vindo ao ZAPFLOW</h2>
            <p>Faça login para aceder ao Flow Builder</p>
            <form id="login-form">
                <div class="input-group">
                    <label for="username">Utilizador</label>
                    <input type="text" id="username" value="admin" required>
                </div>
                <div class="input-group">
                    <label for="password">Senha</label>
                    <input type="password" id="password" value="admin123" required>
                </div>
                <div id="login-error"></div>
                <button type="submit" id="login-button">Entrar</button>
            </form>
        </div>
    </div>

    <!-- APLICAÇÃO PRINCIPAL (INICIALMENTE OCULTA) -->
    <div id="app-container" class="app-container hidden">
        <div id="side-panel" class="panel">
            <div class="panel-header">
                <span><i class="fas fa-sitemap"></i> Blocos do Fluxo</span>
                <button id="logout-button" title="Sair"><i class="fas fa-sign-out-alt"></i></button>
            </div>
            <!-- Novo: Nó de Início Arrastável -->
            <div class="node-template" draggable="true" data-type="start">
                <i class="fas fa-flag-checkered"></i> Início do Fluxo
            </div>
            <div class="node-template" draggable="true" data-type="message">
                <i class="fas fa-comment-dots"></i> Mensagem do Bot
            </div>
            <div class="node-template" draggable="true" data-type="image">
                <i class="fas fa-image"></i> Imagem
            </div>
            <div class="node-template" draggable="true" data-type="question">
                <i class="fas fa-question-circle"></i> Pergunta (Sim/Não)
            </div>
            <div class="node-template" draggable="true" data-type="multipleChoice">
                <i class="fas fa-check-double"></i> Múltiplas Escolhas
            </div>
            <div class="node-template" draggable="true" data-type="userInput">
                <i class="fas fa-keyboard"></i> Entrada do Utilizador
            </div>
            <div class="node-template" draggable="true" data-type="delay">
                <i class="fas fa-clock"></i> Atraso / Pausa
            </div>
            <div class="node-template" draggable="true" data-type="cta">
                <i class="fas fa-rocket"></i> Botão Final (CTA)
            </div>
            <!-- Novo: Nó de Fim Arrastável -->
            <div class="node-template" draggable="true" data-type="end">
                <i class="fas fa-stop-circle"></i> Fim do Fluxo
            </div>

            <!-- Bot Settings Section -->
            <div class="bot-settings">
                <div class="panel-header">
                    <span><i class="fas fa-robot"></i> Configurações do Bot</span>
                </div>
                <div class="input-group">
                    <label for="bot-name-input">Nome do Bot</label>
                    <input type="text" id="bot-name-input" placeholder="Nome do Bot">
                </div>
                <div class="input-group">
                    <label for="bot-profile-pic-input">URL da Foto de Perfil</label>
                    <input type="text" id="bot-profile-pic-input" placeholder="https://exemplo.com/bot.png">
                </div>
            </div>

            <div class="controls">
                <button id="run-flow-btn" class="control-btn"><i class="fas fa-play"></i> Testar Fluxo</button>
                <button id="import-flow-btn" class="control-btn"><i class="fas fa-upload"></i> Importar Fluxo</button>
                <button id="export-flow-btn" class="control-btn"><i class="fas fa-download"></i> Exportar Fluxo</button>
                <button id="clear-flow-btn" class="control-btn"><i class="fas fa-trash-alt"></i> Limpar</button>
                <button id="download-html-btn" class="control-btn"><i class="fas fa-code"></i> Baixar HTML</button>
                <input type="file" id="import-file-input" style="display: none;" accept=".json">
            </div>
        </div>

        <div id="canvas-container">
            <div id="flow-canvas">
                <svg id="svg-layer">
                </svg>
            </div>
        </div>

        <div id="preview-panel" class="panel">
            <div class="panel-header"><i class="fas fa-mobile-alt"></i> Pré-visualização</div>
            <div class="mobile-preview">
                <div class="chat-header">
                    <img id="preview-bot-avatar" src="https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png" alt="Atendente">
                    <div class="contact-info">
                        <div id="preview-bot-name" class="name">ZAPFLOW BOT</div>
                        <div class="status">online</div>
                    </div>
                </div>
                <div class="chat-body" id="preview-chat-body"></div>
            </div>
        </div>
    </div>

    <!-- CUSTOM MODAL HTML -->
    <div id="custom-modal-overlay" class="custom-modal-overlay hidden">
        <div class="custom-modal">
            <h3 id="modal-title"></h3>
            <p id="modal-message"></p>
            <div class="custom-modal-buttons">
                <button id="modal-confirm-btn" class="confirm-btn">Confirmar</button>
                <button id="modal-cancel-btn" class="cancel-btn">Cancelar</button>
            </div>
        </div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- CUSTOM MODAL LOGIC ---
        const modalOverlay = document.getElementById('custom-modal-overlay');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        let onConfirmCallback;
        let onCancelCallback;

        /**
         * Displays a custom confirmation modal.
         * @param {string} title - The modal title.
         * @param {string} message - The message to display in the modal.
         * @param {function} onConfirm - Callback function to execute if confirmed.
         * @param {function} [onCancel] - Optional callback function to execute if cancelled.
         */
        function showConfirmModal(title, message, onConfirm, onCancel) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            onConfirmCallback = onConfirm;
            onCancelCallback = onCancel;
            
            modalCancelBtn.classList.remove('hidden'); // Ensure cancel button is visible

            modalConfirmBtn.onclick = () => {
                modalOverlay.classList.add('hidden');
                if (onConfirmCallback) onConfirmCallback();
            };
            modalCancelBtn.onclick = () => {
                modalOverlay.classList.add('hidden');
                if (onCancelCallback) onCancelCallback();
            };

            modalOverlay.classList.remove('hidden');
        }

        /**
         * Displays a custom alert modal (only confirmation button).
         * @param {string} title - The modal title.
         * @param {string} message - The message to display in the modal.
         * @param {function} [onClose] - Optional callback function to execute when closed.
         */
        function showAlertModal(title, message, onClose) {
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            modalCancelBtn.classList.add('hidden'); // Hide cancel button for alerts
            
            onConfirmCallback = onClose; // Use confirm button to close alert
            modalConfirmBtn.onclick = () => {
                modalOverlay.classList.add('hidden');
                modalCancelBtn.classList.remove('hidden'); // Show cancel button for next use
                if (onConfirmCallback) onConfirmCallback();
            };

            modalOverlay.classList.remove('hidden');
        }


        // --- LOGIN LOGIC ---
        const loginScreen = document.getElementById('login-screen');
        const appContainer = document.getElementById('app-container');
        const loginForm = document.getElementById('login-form');
        const usernameInput = document.getElementById('username');
        const passwordInput = document.getElementById('password');
        const loginError = document.getElementById('login-error');
        const logoutButton = document.getElementById('logout-button');

        loginForm.addEventListener('submit', (e) => {
            e.preventDefault();
            const username = usernameInput.value;
            const password = passwordInput.value;

            if (username === 'admin' && password === 'admin123') {
                loginScreen.classList.add('hidden');
                appContainer.classList.remove('hidden');
                initFlowBuilder(); // Initialize builder ONLY after login
            } else {
                loginError.textContent = 'Utilizador ou senha inválidos.';
                setTimeout(() => loginError.textContent = '', 3000);
            }
        });

        logoutButton.addEventListener('click', () => {
            showConfirmModal('Sair?', 'Tem a certeza que deseja sair?',
                () => {
                    loginScreen.classList.remove('hidden');
                    appContainer.classList.add('hidden');
                }
            );
        });
        
        // --- START OF FLOW BUILDER CODE ---
        function initFlowBuilder() {
            const sidePanel = document.getElementById('side-panel'),
                canvasContainer = document.getElementById('canvas-container'),
                flowCanvas = document.getElementById('flow-canvas'),
                svgLayer = document.getElementById('svg-layer'),
                runFlowBtn = document.getElementById('run-flow-btn'),
                clearFlowBtn = document.getElementById('clear-flow-btn'),
                downloadHtmlBtn = document.getElementById('download-html-btn'),
                previewChatBody = document.getElementById('preview-chat-body'),
                importFlowBtn = document.getElementById('import-flow-btn'),
                exportFlowBtn = document.getElementById('export-flow-btn'),
                importFileInput = document.getElementById('import-file-input');

            // New bot settings elements
            const botNameInput = document.getElementById('bot-name-input');
            const botProfilePicInput = document.getElementById('bot-profile-pic-input');
            const previewBotName = document.getElementById('preview-bot-name');
            const previewBotAvatar = document.getElementById('preview-bot-avatar');

            let nodes = {}, connections = [], nodeIdCounter = 0, selectedNodeId = null,
                isConnecting = false, connectionStart = {};
            let pan = { x: 0, y: 0, scale: 1, isPanning: false, startX: 0, startY: 0 };
            let currentTempLine = null;
            let hoveredInputConnector = null;

            // --- ZOOM AND PAN LOGIC ---
            canvasContainer.addEventListener('wheel', (e) => {
                e.preventDefault();
                const rect = canvasContainer.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;
                const oldScale = pan.scale;
                const newScale = oldScale * (e.deltaY > 0 ? 0.9 : 1.1);
                pan.scale = Math.max(0.2, Math.min(newScale, 2));

                // Adjust pan so zoom is centered on mouse pointer
                pan.x = mouseX - (mouseX - pan.x) * (pan.scale / oldScale);
                pan.y = mouseY - (mouseY - pan.y) * (pan.scale / oldScale);
                
                updateCanvasTransform();
            });

            canvasContainer.addEventListener('mousedown', (e) => {
                if (e.target.closest('.flow-node') || e.target.closest('.connector')) {
                    return; 
                }
                
                selectNode(null); // Deselect any node when starting canvas pan
                pan.isPanning = true;
                pan.startX = e.clientX;
                pan.startY = e.clientY; 
            });

            canvasContainer.addEventListener('mousemove', (e) => {
                if (!pan.isPanning) return;
                pan.x += e.clientX - pan.startX;
                pan.y += e.clientY - pan.startY;
                pan.startX = e.clientX;
                pan.startY = e.clientY; 
                updateCanvasTransform();
            });

            canvasContainer.addEventListener('mouseup', () => pan.isPanning = false);
            canvasContainer.addEventListener('mouseleave', () => pan.isPanning = false);

            function updateCanvasTransform() {
                flowCanvas.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${pan.scale})`;
                redrawAllConnections(); 
            }

            function toCanvasCoords(e) {
                const rect = canvasContainer.getBoundingClientRect();
                return {
                    x: (e.clientX - rect.left - pan.x) / pan.scale,
                    y: (e.clientY - rect.top - pan.y) / pan.scale
                };
            }

            // --- DRAG & DROP LOGIC ---
            sidePanel.querySelectorAll('.node-template').forEach(template => {
                template.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', e.target.dataset.type);
                });
            });

            canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
            canvasContainer.addEventListener('drop', (e) => {
                e.preventDefault();
                const type = e.dataTransfer.getData('text/plain');
                if (!type) return;
                const coords = toCanvasCoords(e);
                createNode(type, coords.x, coords.y);
            });

            // --- BLOCK CREATION ---
            function createNode(type, x, y, id = null, content = []) {
                const nodeId = id || `node-${nodeIdCounter++}`;
                const nodeEl = document.createElement('div');
                nodeEl.className = 'flow-node';
                nodeEl.id = nodeId;
                nodeEl.dataset.type = type;
                nodeEl.style.left = `${x}px`;
                nodeEl.style.top = `${y}px`;

                let headerText = '', headerIcon = '', contentHtml = '';
                let hasInputConnector = true, hasOutputConnector = true;

                switch(type) {
                    case 'start':
                        headerText = 'Início';
                        headerIcon = 'fa-flag-checkered';
                        contentHtml = `<p style="text-align:center;">Ponto de partida do fluxo</p>`;
                        hasInputConnector = false;
                        break;
                    case 'end':
                        headerText = 'Fim';
                        headerIcon = 'fa-stop-circle';
                        contentHtml = `<p style="text-align:center;">Ponto final do fluxo</p>`;
                        hasOutputConnector = false;
                        break;
                    case 'message':
                        headerText = 'Mensagem';
                        headerIcon = 'fa-comment-dots';
                        contentHtml = `<label>Texto da Mensagem:</label><textarea placeholder="Digite a mensagem do bot">${content[0] || ''}</textarea>`;
                        break;
                    case 'image':
                        headerText = 'Imagem';
                        headerIcon = 'fa-image';
                        contentHtml = `<label>URL da Imagem:</label><textarea placeholder="https://exemplo.com/imagem.png">${content[0] || ''}</textarea>`;
                        break;
                    case 'question':
                        headerText = 'Pergunta (Sim/Não)';
                        headerIcon = 'fa-question-circle';
                        contentHtml = `<label>Texto da Pergunta:</label><textarea placeholder="Faça uma pergunta (Sim/Não)">${content[0] || ''}</textarea>`;
                        break;
                    case 'userInput':
                        headerText = 'Entrada do Utilizador';
                        headerIcon = 'fa-keyboard';
                        contentHtml = `
                            <label>Texto da Pergunta:</label>
                            <textarea placeholder="Pergunte algo ao utilizador">${content[0] || ''}</textarea>
                            <label>Variável para Salvar:</label>
                            <input type="text" placeholder="Nome da variável (ex: nome)" value="${content[1] || ''}">
                        `;
                        break;
                    case 'delay':
                        headerText = 'Atraso / Pausa';
                        headerIcon = 'fa-clock';
                        contentHtml = `<label>Duração do Atraso (ms):</label><input type="number" placeholder="1500" value="${content[0] || '1500'}">`;
                        break;
                    case 'cta':
                        headerText = 'Botão Final (CTA)';
                        headerIcon = 'fa-rocket';
                        contentHtml = `
                            <label>Texto do Botão:</label><textarea placeholder="Comprar Agora">${content[0] || 'Comprar Agora'}</textarea>
                            <label>URL do Link:</label><textarea placeholder="https://seusite.com">${content[1] || ''}</textarea>
                        `;
                        hasOutputConnector = false;
                        break;
                    case 'multipleChoice':
                        headerText = 'Múltiplas Escolhas';
                        headerIcon = 'fa-check-double';
                        let buttonsHtml = '';
                        const options = content.length > 1 ? content.slice(1) : ['Opção 1'];
                        buttonsHtml = options.map((text, i) =>
                            `<div class="button-option" data-index="${i}"><input type="text" value="${text}"><i class="fas fa-times remove-btn"></i></div>`
                        ).join('');
                        
                        contentHtml = `
                            <label>Texto da Pergunta:</label>
                            <textarea placeholder="Faça uma pergunta com opções">${content[0] || ''}</textarea>
                            <label>Opções:</label>
                            <div id="buttons-container">${buttonsHtml}</div>
                            <button class="add-btn"><i class="fas fa-plus"></i> Adicionar Opção</button>
                        `;
                        break;
                    default:
                        headerText = 'Tipo Desconhecido';
                        headerIcon = 'fa-times-circle';
                        contentHtml = `<p>Tipo de nó desconhecido: ${type}</p>`;
                        break;
                }

                nodeEl.innerHTML = `
                    <div class="node-header"><i class="fas ${headerIcon}"></i> ${headerText} <button class="delete-node-btn"><i class="fas fa-trash-alt"></i></button></div>
                    <div class="node-content">${contentHtml}</div>
                `;
                
                if (hasInputConnector) {
                    nodeEl.insertAdjacentHTML('beforeend', `<div class="connector input"></div>`);
                }
                
                if (hasOutputConnector) {
                    if (type === 'question') {
                        nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" data-choice="yes" style="top: 35%;"><span style="position: absolute; right: 20px; font-size: 11px; color: #aaffaa;">Sim</span></div>`);
                        nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" data-choice="no" style="top: 65%;"><span style="position: absolute; right: 20px; font-size: 11px; color: #ffaaaa;">Não</span></div>`);
                    } else if (type !== 'multipleChoice') {
                        nodeEl.insertAdjacentHTML('beforeend', `<div class="connector output" style="top: 50%; transform: translateY(-50%);"></div>`);
                    }
                }

                flowCanvas.appendChild(nodeEl);

                nodes[nodeId] = {
                    id: nodeId,
                    el: nodeEl,
                    type: type,
                    x: x,
                    y: y,
                    content: content.length > 0 ? content : (type === 'multipleChoice' ? ['Nova Pergunta?', 'Opção 1'] : [''])
                };
                if (type === 'userInput' || type === 'cta') {
                    nodes[nodeId].content = [content[0] || '', content[1] || ''];
                } else if (type === 'delay') {
                    nodes[nodeId].content = [content[0] || '1500'];
                }


                if (type === 'multipleChoice') {
                    if (content.length === 0) {
                        nodes[nodeId].content = ['Nova Pergunta?', 'Opção 1'];
                    } else if (content.length === 1) {
                        nodes[nodeId].content = [content[0], 'Opção 1'];
                    }
                    updateMultipleChoiceConnectors(nodeEl);
                }

                makeNodeDraggable(nodeEl);
                setupNodeEventListeners(nodeEl);
                if (!id) saveState();
                return nodeEl;
            }

            function updateMultipleChoiceConnectors(nodeEl) {
                nodeEl.querySelectorAll('.connector.output').forEach(c => c.remove());
                
                const optionDivs = nodeEl.querySelectorAll('.button-option');
                const totalHeight = nodeEl.querySelector('.node-content').offsetHeight;
                const startY = nodeEl.querySelector('.node-header').offsetHeight + 80; // Approximate start after question
                const spacing = (totalHeight - startY) / (optionDivs.length + 1);

                optionDivs.forEach((optionDiv, i) => {
                    const connector = document.createElement('div');
                    connector.className = 'connector output';
                    connector.dataset.choice = i;
                    const optionText = optionDiv.querySelector('input').value.substring(0, 10) + '...';
                    connector.innerHTML = `<span style="position: absolute; right: 20px; font-size: 11px; color: #aaa;">${optionText}</span>`;
                    
                    const topPosition = optionDiv.offsetTop + (optionDiv.offsetHeight / 2);
                    connector.style.top = `${topPosition}px`;
                    
                    nodeEl.appendChild(connector);
                });
                setupNodeEventListeners(nodeEl);
            }

            function setupNodeEventListeners(nodeEl) {
                const addBtn = nodeEl.querySelector('.add-btn');
                if (addBtn) {
                    addBtn.onclick = () => {
                        const node = nodes[nodeEl.id];
                        const newOptionText = `Opção ${node.content.length}`;
                        node.content.push(newOptionText);
                        const newIndex = node.content.length - 2;
                        const container = nodeEl.querySelector('#buttons-container');
                        container.insertAdjacentHTML('beforeend', `<div class="button-option" data-index="${newIndex}"><input type="text" value="${newOptionText}"><i class="fas fa-times remove-btn"></i></div>`);
                        updateMultipleChoiceConnectors(nodeEl);
                        setupNodeEventListeners(nodeEl);
                        saveState();
                    };
                }
                nodeEl.querySelectorAll('.remove-btn').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        const node = nodes[nodeEl.id];
                        const optionDiv = btn.closest('.button-option');
                        const indexToRemove = parseInt(optionDiv.dataset.index, 10);
                        node.content.splice(indexToRemove + 1, 1);
                        optionDiv.remove();

                        nodeEl.querySelectorAll('.button-option').forEach((div, i) => div.dataset.index = i);
                        updateMultipleChoiceConnectors(nodeEl);
                        setupNodeEventListeners(nodeEl);
                        saveState();
                    };
                });
                nodeEl.querySelectorAll('textarea, input').forEach((input) => {
                    input.addEventListener('input', () => {
                        const newContent = Array.from(nodeEl.querySelectorAll('.node-content textarea, .node-content input'))
                                                .map(el => el.value);
                        nodes[nodeEl.id].content = newContent;
                        if(nodes[nodeEl.id].type === 'multipleChoice') {
                            updateMultipleChoiceConnectors(nodeEl);
                        }
                        saveState();
                    });
                    input.addEventListener('mousedown', (e) => e.stopPropagation());
                });

                const deleteBtn = nodeEl.querySelector('.delete-node-btn');
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showConfirmModal(
                            'Excluir Bloco?',
                            `Tem certeza que deseja excluir este bloco?`,
                            () => deleteNode(nodeEl.id)
                        );
                    });
                }

                nodeEl.querySelectorAll('.connector').forEach(c => {
                    c.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        handleConnectorClick(nodeEl.id, c, e);
                    });
                     c.addEventListener('mouseover', () => {
                        if (isConnecting && c.classList.contains('input') && connectionStart.nodeId !== nodeEl.id) {
                            c.classList.add('highlight-target');
                            hoveredInputConnector = c;
                        }
                    });
                    c.addEventListener('mouseout', () => {
                        if (hoveredInputConnector) {
                            hoveredInputConnector.classList.remove('highlight-target');
                            hoveredInputConnector = null;
                        }
                    });
                });
            }
            
            function makeNodeDraggable(nodeEl) {
                let dragOffsetX, dragOffsetY;
                let isDraggingNode = false;

                const onMouseMove = (e) => {
                    if (!isDraggingNode) return;
                    e.preventDefault(); 
                    const newX = (e.clientX - pan.x) / pan.scale - dragOffsetX;
                    const newY = (e.clientY - pan.y) / pan.scale - dragOffsetY;
                    nodeEl.style.left = `${newX}px`;
                    nodeEl.style.top = `${newY}px`;
                    nodes[nodeEl.id].x = newX;
                    nodes[nodeEl.id].y = newY;
                    updateConnectionsForNode(nodeEl.id);
                };

                const onMouseUp = () => {
                    isDraggingNode = false;
                    nodeEl.classList.remove('dragging');
                    document.removeEventListener('mousemove', onMouseMove);
                    document.removeEventListener('mouseup', onMouseUp);
                    saveState();
                };

                nodeEl.addEventListener('mousedown', (e) => {
                    if (e.target.tagName === 'TEXTAREA' || e.target.tagName === 'INPUT' || e.target.closest('.connector') || e.target.closest('.delete-node-btn')) {
                        return;
                    }
                    
                    e.preventDefault();
                    selectNode(nodeEl.id);
                    isDraggingNode = true;
                    nodeEl.classList.add('dragging');

                    dragOffsetX = (e.clientX - pan.x) / pan.scale - nodes[nodeEl.id].x;
                    dragOffsetY = (e.clientY - pan.y) / pan.scale - nodes[nodeEl.id].y;
                    
                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
            }
            
            function getConnectorPosition(connectorEl) {
                const nodeEl = connectorEl.closest('.flow-node');
                return {
                    x: nodeEl.offsetLeft + connectorEl.offsetLeft + connectorEl.offsetWidth / 2,
                    y: nodeEl.offsetTop + connectorEl.offsetTop + connectorEl.offsetHeight / 2
                };
            }
            
            function selectNode(nodeId) {
                if (selectedNodeId && nodes[selectedNodeId] && nodes[selectedNodeId].el) {
                    nodes[selectedNodeId].el.classList.remove('selected');
                }
                selectedNodeId = nodeId;
                if (selectedNodeId && nodes[selectedNodeId] && nodes[selectedNodeId].el) {
                    nodes[selectedNodeId].el.classList.add('selected');
                }
            }

            function deleteNode(nodeId) {
                connections = connections.filter(conn => conn.from !== nodeId && conn.to !== nodeId);
                if (nodes[nodeId] && nodes[nodeId].el) {
                    nodes[nodeId].el.remove();
                }
                delete nodes[nodeId];
                selectedNodeId = null;
                redrawAllConnections();
                saveState();
            }

            document.addEventListener('keydown', (e) => {
                if ((e.key === 'Delete' || e.key === 'Backspace') && selectedNodeId) {
                    if (document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'INPUT') {
                        return;
                    }
                    showConfirmModal(
                        'Excluir Bloco?',
                        `Tem certeza que deseja excluir o bloco selecionado?`,
                        () => deleteNode(selectedNodeId)
                    );
                }
            });

            function handleGlobalMouseUp(e) {
                if (!isConnecting) return;
                
                const targetConnector = hoveredInputConnector;
                
                if (targetConnector) {
                    const targetNodeId = targetConnector.closest('.flow-node').id;
                    connections = connections.filter(c => !(c.from === connectionStart.nodeId && c.choice === connectionStart.choice));
                    connections = connections.filter(c => c.to !== targetNodeId);
                    createConnection(connectionStart.nodeId, targetNodeId, connectionStart.choice);
                }
                resetConnectionState();
            }

            function handleConnectorClick(nodeId, connector, e) {
                e.preventDefault(); 
                e.stopPropagation(); 

                if (isConnecting) {
                    resetConnectionState();
                }

                if (connector.classList.contains('output')) {
                    startNewConnection(nodeId, connector);
                }
            }

            function startNewConnection(nodeId, connector) {
                isConnecting = true;
                connectionStart = {
                    nodeId: nodeId,
                    choice: connector.dataset.choice !== undefined ? connector.dataset.choice : null
                };
                currentTempLine = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                currentTempLine.setAttribute('stroke', 'var(--primary-accent)');
                currentTempLine.setAttribute('stroke-width', '2');
                currentTempLine.setAttribute('fill', 'none');
                currentTempLine.style.pointerEvents = 'none';
                svgLayer.appendChild(currentTempLine);
                
                document.addEventListener('mousemove', onDrawingConnection);
                document.addEventListener('mouseup', handleGlobalMouseUp, { once: true });
            }

            function getBezierPath(x1, y1, x2, y2) {
                const dx = Math.abs(x2 - x1) * 0.6;
                const cp1x = x1 + dx;
                const cp1y = y1;
                const cp2x = x2 - dx;
                const cp2y = y2;
                return `M ${x1} ${y1} C ${cp1x} ${cp1y}, ${cp2x} ${cp2y}, ${x2} ${y2}`;
            }

            function onDrawingConnection(e) {
                if (!currentTempLine) return;
                const startPos = getConnectorPosition(nodes[connectionStart.nodeId].el.querySelector(`.connector.output[data-choice="${connectionStart.choice}"]`) || nodes[connectionStart.nodeId].el.querySelector('.connector.output'));
                const endCoords = toCanvasCoords({ clientX: e.clientX, clientY: e.clientY });
                currentTempLine.setAttribute('d', getBezierPath(startPos.x, startPos.y, endCoords.x, endCoords.y));
            }

            function resetConnectionState() { 
                isConnecting = false;
                connectionStart = {};
                if (currentTempLine) {
                    currentTempLine.remove();
                    currentTempLine = null;
                }
                if (hoveredInputConnector) {
                    hoveredInputConnector.classList.remove('highlight-target');
                    hoveredInputConnector = null;
                }
                document.removeEventListener('mousemove', onDrawingConnection);
                document.removeEventListener('mouseup', handleGlobalMouseUp);
            }

            function createConnection(fromId, toId, choice = null) {
                const newConnection = { from: fromId, to: toId, choice };
                connections.push(newConnection);
                redrawAllConnections();
                saveState();
            }

            function updateConnectionLine(conn) {
                const fromNode = nodes[conn.from];
                const toNode = nodes[conn.to];
                if (!fromNode || !toNode || !conn.lineEl) return;

                let fromConnector;
                if (conn.choice !== null) {
                    fromConnector = fromNode.el.querySelector(`.connector.output[data-choice="${conn.choice}"]`);
                } else {
                    fromConnector = fromNode.el.querySelector('.connector.output:not([data-choice])');
                }
                const toConnector = toNode.el.querySelector('.connector.input');

                if (!fromConnector || !toConnector) return;

                const startPos = getConnectorPosition(fromConnector);
                const endPos = getConnectorPosition(toConnector);

                conn.lineEl.setAttribute('d', getBezierPath(startPos.x, startPos.y, endPos.x, endPos.y));
            }

            function updateConnectionsForNode(nodeId) {
                connections.forEach(conn => {
                    if (conn.from === nodeId || conn.to === nodeId) {
                        updateConnectionLine(conn);
                    }
                });
            }

            function redrawAllConnections() {
                svgLayer.innerHTML = '';
                connections.forEach(conn => {
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                    line.setAttribute('stroke', 'var(--connector-color)');
                    line.setAttribute('stroke-width', '2');
                    line.setAttribute('fill', 'none');
                    conn.lineEl = line;
                    svgLayer.appendChild(line);
                    updateConnectionLine(conn);
                });
            }
            
            // --- IMPORT / EXPORT / CLEAR LOGIC ---
            exportFlowBtn.addEventListener('click', () => {
                const dataToExport = {
                    nodes: Object.values(nodes).map(n => ({
                        id: n.id, type: n.type, x: n.x, y: n.y, content: n.content
                    })),
                    connections: connections.map(c => ({
                        from: c.from, to: c.to, choice: c.choice
                    })),
                    nodeIdCounter,
                    pan,
                    botSettings: {
                        name: botNameInput.value,
                        profilePic: botProfilePicInput.value
                    }
                };
                const dataStr = JSON.stringify(dataToExport, null, 2);
                const blob = new Blob([dataStr], {type: 'application/json'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'zapflow_flow.json';
                a.click();
                URL.revokeObjectURL(url);
                showAlertModal('Sucesso!', 'Fluxo exportado com sucesso como "zapflow_flow.json".');
            });

            importFlowBtn.addEventListener('click', () => importFileInput.click());
            importFileInput.addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        showConfirmModal(
                            'Importar Fluxo?',
                            'Isto irá substituir o fluxo atual. Tem a certeza?',
                            () => loadState(data),
                            () => showAlertModal('Importação Cancelada', 'A importação do fluxo foi cancelada.')
                        );
                    } catch (err) {
                        showAlertModal('Erro', 'Erro ao ler o ficheiro JSON. Verifique se é um arquivo de fluxo válido.');
                        console.error("Erro ao importar fluxo:", err);
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            });

            function resetCanvas() {
                flowCanvas.innerHTML = '<svg id="svg-layer"></svg>'; // Re-create svg layer
                nodes = {};
                connections = [];
                selectedNodeId = null;
                nodeIdCounter = 0;
                pan = { x: 0, y: 0, scale: 1 };
                updateCanvasTransform();
            }

            function saveState() {
                const state = {
                    nodes: Object.values(nodes).map(n => ({
                        id: n.id, type: n.type, x: n.x, y: n.y, content: n.content
                    })),
                    connections: connections.map(c => ({
                        from: c.from, to: c.to, choice: c.choice
                    })),
                    nodeIdCounter,
                    pan,
                    botSettings: {
                        name: botNameInput.value,
                        profilePic: botProfilePicInput.value
                    }
                };
                localStorage.setItem('zapflowBuilderState', JSON.stringify(state));
            }

            function loadState(data = null) {
                const state = data || JSON.parse(localStorage.getItem('zapflowBuilderState'));
                if (!state) {
                    botNameInput.value = 'ZAPFLOW BOT';
                    botProfilePicInput.value = 'https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png';
                    updateBotPreview();
                    return;
                }

                resetCanvas();
                nodeIdCounter = state.nodeIdCounter || 0;
                pan = state.pan || {x:0, y:0, scale:1, isPanning: false, startX: 0, startY: 0 };
                updateCanvasTransform();

                if (state.nodes) {
                    state.nodes.forEach(n => createNode(n.type, n.x, n.y, n.id, n.content));
                }
                connections = state.connections || [];
                redrawAllConnections();

                if (state.botSettings) {
                    botNameInput.value = state.botSettings.name || 'ZAPFLOW BOT';
                    botProfilePicInput.value = state.botSettings.profilePic || 'https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png';
                }
                updateBotPreview();
            }

            clearFlowBtn.addEventListener('click', () => {
                showConfirmModal('Limpar Fluxo?', 'Tem certeza que deseja limpar todo o fluxo? Esta ação não pode ser desfeita.',
                    () => {
                        resetCanvas();
                        saveState();
                        showAlertModal('Fluxo Limpo', 'O canvas foi limpo.');
                    }
                );
            });

            // --- BOT SETTINGS LOGIC ---
            function updateBotPreview() {
                previewBotName.textContent = botNameInput.value || 'ZAPFLOW BOT';
                previewBotAvatar.src = botProfilePicInput.value || 'https://i.ibb.co/zTTD7BJf/Ezbc8zz-X0-AQ5-F7p.png';
                previewBotAvatar.onerror = function() {
                    this.onerror=null;
                    this.src='https://placehold.co/45x45/CCCCCC/000000?text=Bot';
                };
            }

            botNameInput.addEventListener('input', () => {
                updateBotPreview();
                saveState();
            });

            botProfilePicInput.addEventListener('input', () => {
                updateBotPreview();
                saveState();
            });
            
            // --- FLOW SIMULATION LOGIC ---
            let flowVariables = {};

            function addMessage(text, type, imageUrl = null) {
                const messageDiv = document.createElement('div');
                messageDiv.className = `message ${type}`;
                if (imageUrl) {
                    const img = document.createElement('img');
                    img.src = imageUrl;
                    img.onerror = function() {
                        this.onerror=null;
                        this.src='https://placehold.co/150x100/CCCCCC/000000?text=Imagem+N%C3%A3o+Encontrada';
                    };
                    messageDiv.appendChild(img);
                }
                if(text) {
                    const span = document.createElement('span');
                    span.innerHTML = text.replace(/\n/g, '<br>');
                    messageDiv.appendChild(span);
                }
                previewChatBody.appendChild(messageDiv);
                scrollToBottom();
            }

            function addTypingIndicator() {
                const indicator = document.createElement('div');
                indicator.className = 'typing-indicator';
                indicator.innerHTML = '<span></span><span></span><span></span>';
                previewChatBody.appendChild(indicator);
                scrollToBottom();
                return indicator;
            }

            function removeTypingIndicator(indicatorEl) {
                if (indicatorEl) indicatorEl.remove();
            }

            function scrollToBottom() {
                previewChatBody.scrollTop = previewChatBody.scrollHeight;
            }

            function waitForUserChoice(choices) {
                return new Promise(resolve => {
                    const choiceContainer = document.createElement('div');
                    choiceContainer.className = 'choice-container';
                    choices.forEach((choiceText, index) => {
                        const button = document.createElement('button');
                        button.className = 'choice-button';
                        let processedChoiceText = choiceText;
                        for (const key in flowVariables) {
                            processedChoiceText = processedChoiceText.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), flowVariables[key]);
                        }
                        button.textContent = processedChoiceText;
                        button.onclick = () => {
                            choiceContainer.remove();
                            resolve(index);
                        };
                        choiceContainer.appendChild(button);
                    });
                    previewChatBody.appendChild(choiceContainer);
                    scrollToBottom();
                });
            }

            function waitForUserInput(promptText) {
                return new Promise(resolve => {
                    let processedPromptText = promptText;
                    for (const key in flowVariables) {
                        processedPromptText = processedPromptText.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), flowVariables[key]);
                    }
                    addMessage(processedPromptText, "received");

                    const inputContainer = document.createElement('div');
                    inputContainer.className = 'user-input-container';
                    const inputField = document.createElement('input');
                    inputField.type = 'text';
                    inputField.placeholder = 'Digite sua resposta...';
                    const sendButton = document.createElement('button');
                    sendButton.innerHTML = '<i class="fas fa-paper-plane"></i>';

                    const submitResponse = () => {
                        const userText = inputField.value.trim();
                        if (userText) {
                            inputContainer.remove();
                            resolve(userText);
                        }
                    };

                    sendButton.onclick = submitResponse;
                    inputField.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') submitResponse();
                    });

                    inputContainer.appendChild(inputField);
                    inputContainer.appendChild(sendButton);
                    previewChatBody.appendChild(inputContainer);
                    scrollToBottom();
                    inputField.focus();
                });
            }

            async function simulateFlow(currentNodeId) {
                const currentNode = nodes[currentNodeId];
                if (!currentNode) {
                    addMessage("Fluxo terminado ou nó inválido alcançado.", "received");
                    return;
                }

                let processedContent = currentNode.content.map(c => {
                    let text = c || '';
                    for (const key in flowVariables) {
                        text = text.replace(new RegExp(`\\{\\{${key}\\}\\}`, 'g'), flowVariables[key]);
                    }
                    return text;
                });

                switch (currentNode.type) {
                    case 'start':
                        const startConnection = connections.find(c => c.from === currentNode.id);
                        if (startConnection) await simulateFlow(startConnection.to);
                        else addMessage("Nó 'Início' não conectado.", "received");
                        break;
                    case 'end':
                        addMessage("Fluxo finalizado.", "received");
                        break;
                    case 'message':
                        addMessage(processedContent[0], "received");
                        await new Promise(r => setTimeout(r, 500));
                        const msgConnection = connections.find(c => c.from === currentNode.id);
                        if (msgConnection) await simulateFlow(msgConnection.to);
                        break;
                    case 'image':
                        addMessage(null, "received", processedContent[0]);
                        await new Promise(r => setTimeout(r, 1000));
                        const imgConnection = connections.find(c => c.from === currentNode.id);
                        if (imgConnection) await simulateFlow(imgConnection.to);
                        break;
                    case 'question':
                        addMessage(processedContent[0], "received");
                        const choiceSelected = await waitForUserChoice(['Sim', 'Não']);
                        addMessage(choiceSelected === 0 ? 'Sim' : 'Não', 'sent');
                        const questionChoice = (choiceSelected === 0) ? 'yes' : 'no';
                        const questionConnection = connections.find(c => c.from === currentNode.id && c.choice === questionChoice);
                        if (questionConnection) await simulateFlow(questionConnection.to);
                        else showAlertModal('Aviso', `Nenhuma conexão definida para a opção "${questionChoice === 'yes' ? 'Sim' : 'Não'}".`);
                        break;
                    case 'multipleChoice':
                        addMessage(processedContent[0], "received");
                        const mcOptions = processedContent.slice(1);
                        const mcChoiceIndex = await waitForUserChoice(mcOptions);
                        addMessage(mcOptions[mcChoiceIndex], 'sent');
                        const mcConnection = connections.find(c => c.from === currentNode.id && parseInt(c.choice) === mcChoiceIndex);
                        if (mcConnection) await simulateFlow(mcConnection.to);
                        else showAlertModal('Aviso', `Nenhuma conexão definida para a opção "${mcOptions[mcChoiceIndex]}".`);
                        break;
                    case 'userInput':
                        const inputPrompt = processedContent[0];
                        const variableName = currentNode.content[1] || 'user_input'; // Use original content for var name
                        const userInput = await waitForUserInput(inputPrompt);
                        addMessage(userInput, 'sent');
                        flowVariables[variableName] = userInput;
                        const userInputConnection = connections.find(c => c.from === currentNode.id);
                        if (userInputConnection) await simulateFlow(userInputConnection.to);
                        break;
                    case 'delay':
                        const delayMs = parseInt(processedContent[0] || '1500', 10);
                        const indicator = addTypingIndicator();
                        await new Promise(r => setTimeout(r, delayMs));
                        removeTypingIndicator(indicator);
                        const delayConnection = connections.find(c => c.from === currentNode.id);
                        if (delayConnection) await simulateFlow(delayConnection.to);
                        break;
                    case 'cta':
                        const ctaText = processedContent[0] || 'Visitar Link';
                        const ctaUrl = processedContent[1] || '#';
                        const ctaContainer = document.createElement('div');
                        ctaContainer.className = 'cta-button-container';
                        ctaContainer.innerHTML = `<a class="cta-button" href="${ctaUrl}" target="_blank">${ctaText}</a>`;
                        previewChatBody.appendChild(ctaContainer);
                        scrollToBottom();
                        addMessage("Fluxo concluído! Clique no botão final.", "received");
                        break;
                    default:
                        addMessage(`Tipo de nó desconhecido: ${currentNode.type}.`, "received");
                        break;
                }
            }

            runFlowBtn.addEventListener('click', () => {
                previewChatBody.innerHTML = '';
                flowVariables = {};
                const startNode = Object.values(nodes).find(node => node.type === 'start');
                if (!startNode) {
                    showAlertModal('Erro', 'Nenhum nó de "Início" encontrado no fluxo.');
                    return;
                }
                simulateFlow(startNode.id);
            });

            // --- MODIFIED: GENERATE AND DOWNLOAD EXECUTABLE HTML ---
            function generateAndDownloadExecutableHtml() {
                const startNode = Object.values(nodes).find(node => node.type === 'start');
                if (!startNode) {
                    showAlertModal('Erro', 'É necessário um nó de "Início" para criar um funil executável.');
                    return;
                }
                
                // 1. Get Flow Data
                const flowState = {
                    nodes: Object.values(nodes).map(n => ({ id: n.id, type: n.type, content: n.content })),
                    connections: connections.map(c => ({ from: c.from, to: c.to, choice: c.choice })),
                    botSettings: {
                        name: botNameInput.value,
                        profilePic: botProfilePicInput.value
                    }
                };

                // 2. Get necessary CSS
                const chatCss = `
                    body { font-family: 'Roboto', sans-serif; background-color: #f0f0f0; display: flex; justify-content: center; align-items: center; min-height: 100vh; margin: 0; }
                    .mobile-preview { width: 100%; max-width: 400px; height: 90vh; max-height: 800px; background-color: #111; border-radius: 40px; border: 10px solid #000; box-shadow: 0 10px 30px rgba(0,0,0,0.5); display: flex; flex-direction: column; overflow: hidden; }
                    .chat-header { background-color: #075E54; color: white; padding: 10px 15px; display: flex; align-items: center; gap: 15px; flex-shrink: 0; }
                    .chat-header img { width: 45px; height: 45px; border-radius: 50%; object-fit: cover; }
                    .chat-header .name { font-weight: bold; }
                    .chat-header .status { font-size: 0.8em; color: #d1d1d1; }
                    .chat-body { flex-grow: 1; padding: 15px 10px; overflow-y: auto; display: flex; flex-direction: column; gap: 12px; background-color: #e5ddd5; background-image: url('https://user-images.githubusercontent.com/15075759/28719144-86dc0f70-73b1-11e7-911d-60d70fcded21.png'); }
                    .message { max-width: 80%; padding: 8px 12px; border-radius: 8px; line-height: 1.4; word-wrap: break-word; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
                    .message.received { background-color: #ffffff; align-self: flex-start; color: black; }
                    .message.sent { background-color: #dcf8c6; align-self: flex-end; color: black; }
                    .message img { max-width: 100%; border-radius: 8px; margin-top: 5px; }
                    .typing-indicator { align-self: flex-start; padding: 10px 15px; display: flex; align-items: center; justify-content: center; background-color: #ffffff; border-radius: 8px; max-width: 80px; }
                    .typing-indicator span { height: 8px; width: 8px; background-color: #888; border-radius: 50%; display: inline-block; margin: 0 2px; animation: bounce 1.3s infinite ease-in-out; }
                    .typing-indicator span:nth-child(2) { animation-delay: 0.1s; }
                    .typing-indicator span:nth-child(3) { animation-delay: 0.2s; }
                    @keyframes bounce { 0%, 80%, 100% { transform: scale(0); } 40% { transform: scale(1.0); } }
                    .choice-container { display: flex; flex-wrap: wrap; gap: 10px; justify-content: flex-end; padding: 5px 10px; align-self: flex-end; }
                    .choice-button { background-color: #fff; border: 1px solid #075E54; color: #075E54; padding: 8px 15px; border-radius: 20px; cursor: pointer; font-weight: bold; transition: background-color 0.2s, color 0.2s; }
                    .choice-button:hover { background-color: #075E54; color: white; }
                    .cta-button-container { padding: 10px; align-self: stretch; }
                    .cta-button { background: linear-gradient(45deg, #25D366, #128C7E); color: white; text-align: center; text-decoration: none; font-size: 1.1em; font-weight: bold; padding: 15px; border-radius: 30px; display: block; transition: transform 0.2s; }
                    .cta-button:hover { transform: translateY(-2px); box-shadow: 0 4px 8px rgba(0,0,0,0.2); }
                    .user-input-container { display: flex; gap: 5px; margin-top: 10px; align-self: stretch; }
                    .user-input-container input { flex-grow: 1; padding: 8px; border-radius: 20px; border: 1px solid #ccc; }
                    .user-input-container button { padding: 8px 15px; border-radius: 20px; border: none; background-color: #075E54; color: white; cursor: pointer; }
                `;

                // 3. Get necessary JS functions as strings
                const runnerJs = `
                    const flowData = ${JSON.stringify(flowState, null, 2)};
                    const nodes = {};
                    flowData.nodes.forEach(n => { nodes[n.id] = n; });
                    const connections = flowData.connections;
                    let flowVariables = {};
                    const previewChatBody = document.getElementById('preview-chat-body');

                    // --- Paste simulation functions here ---
                    ${addMessage.toString()}
                    ${addTypingIndicator.toString()}
                    ${removeTypingIndicator.toString()}
                    ${scrollToBottom.toString()}
                    ${waitForUserChoice.toString()}
                    ${waitForUserInput.toString()}
                    
                    const simulateFlow = ${simulateFlow.toString()};

                    // --- Startup script ---
                    document.addEventListener('DOMContentLoaded', () => {
                        const startNode = Object.values(nodes).find(node => node.type === 'start');
                        if (startNode) {
                            simulateFlow(startNode.id);
                        } else {
                            addMessage('Erro: Nó de início não encontrado.', 'received');
                        }
                    });
                `;

                // 4. Assemble the final HTML
                const finalHtml = `
                    <!DOCTYPE html>
                    <html lang="pt-BR">
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>${flowState.botSettings.name || 'ZAPFLOW Chat'}</title>
                        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
                        <link rel="preconnect" href="https://fonts.googleapis.com">
                        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
                        <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
                        <style>${chatCss}</style>
                    </head>
                    <body>
                        <div class="mobile-preview">
                            <div class="chat-header">
                                <img src="${flowState.botSettings.profilePic || 'https://placehold.co/45x45/CCCCCC/000000?text=Bot'}" alt="Atendente" onerror="this.onerror=null;this.src='https://placehold.co/45x45/CCCCCC/000000?text=Bot';">
                                <div class="contact-info">
                                    <div class="name">${flowState.botSettings.name || 'ZAPFLOW BOT'}</div>
                                    <div class="status">online</div>
                                </div>
                            </div>
                            <div class="chat-body" id="preview-chat-body"></div>
                        </div>
                        <script>
                            ${runnerJs}
                        <\/script>
                    </body>
                    </html>
                `;

                // 5. Trigger download
                const blob = new Blob([finalHtml], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'funil_interativo.html';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                showAlertModal('Sucesso!', 'Seu funil interativo foi baixado como "funil_interativo.html".');
            }

            downloadHtmlBtn.addEventListener('click', generateAndDownloadExecutableHtml);


            // --- INITIALIZATION ---
            function init() {
                loadState();
                if (Object.keys(nodes).length === 0) {
                   console.log("Canvas está vazio. Arraste um bloco para começar.");
                }
            }
            init();
        }
    });
    </script>
</body>
</html>
